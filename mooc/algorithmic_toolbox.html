<head>
    <meta manifest='mooc1535041718734.appcache'>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, Helvetica Neue, PingFang SC, Microsoft YaHei, Source Han Sans SC, Noto Sans CJK SC, WenQuanYi Micro Hei, sans-serif;
            font-size: 15px;
            color: #262626;
            background: #e2eee2;
            -webkit-tap-highlight-color: rgba(26, 26, 26, 0);
        }

        h3,
        p {
            max-width: 800px;
            margin: 5px auto;
        }

        .line_aplit {
            margin-top: 100px;
            margin-bottom: 30px;
            text-align: center;
        }

        .line_zh {
            margin-bottom: 16px;
        }

        .chapter_title {
            font-size: 14px;
            margin-top: 10px;
            margin-bottom: 10px;
            color: #8590a6;
        }

        .chapter_title a {
            color: #8590a6;
        }

        .to_top {
            margin-left: 10px;

        }
    </style>
</head>

<body>
    <p>
        <a href="../index.html">ROOT</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_1">第01章 welcome</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_2">第04章 solving the problem screencast</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_3">第03章 solving the problem improving the naive solution testing debugging</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_4">第05章 stress test implementation</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_5">第06章 stress test find the test and debug</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_6">第07章 stress test more testing submit and pass</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_7">第01章 why study algorithms</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_8">第02章 coming up</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_9">第01章 problem overview</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_10">第02章 naive algorithm</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_11">第03章 efficient algorithm</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_12">第01章 problem overview and naive algorithm</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_13">第02章 efficient algorithm</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_14">第01章 computing runtimes</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_15">第02章 asymptotic notation</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_16">第03章 big o notation</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_17">第04章 using big o</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_18">第01章 course overview</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_19">第01章 largest number</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_20">第02章 car fueling</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_21">第03章 car fueling implementation and analysis</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_22">第04章 main ingredients of greedy algorithms</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_23">第01章 celebration party problem</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_24">第02章 efficient algorithm for grouping children</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_25">第03章 analysis and implementation of the efficient algorithm</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_26">第01章 long hike</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_27">第02章 fractional knapsack implementation analysis and optimization</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_28">第03章 review of greedy algorithms</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_29">第01章 intro</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_30">第02章 linear search</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_31">第03章 binary search</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_32">第04章 binary search runtime</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_33">第01章 problem overview and naive solution</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_34">第02章 naive divide and conquer algorithm</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_35">第03章 faster divide and conquer algorithm</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_36">第01章 what is the master theorem</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_37">第02章 proof of the master theorem</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_38">第01章 problem overview</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_39">第02章 selection sort</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_40">第03章 merge sort</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_41">第04章 lower bound for comparison based sorting</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_42">第05章 non comparison based sorting algorithms</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_43">第01章 overview</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_44">第02章 algorithm</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_45">第03章 random pivot</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_46">第04章 running time analysis optional</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_47">第05章 equal elements</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_48">第06章 final remarks</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_49">第01章 change problem</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_50">第01章 the alignment game</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_51">第02章 computing edit distance</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_52">第03章 reconstructing an optimal alignment</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_53">第01章 problem overview</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_54">第02章 knapsack with repetitions</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_55">第03章 knapsack without repetitions</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_56">第04章 final remarks</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_57">第01章 problem overview</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_58">第02章 subproblems</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_59">第03章 algorithm</a>
    </p>
    <p class="chapter_title">
        <a href="#chapter_60">第04章 reconstructing a solution</a>
    </p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 1 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_1">第01章 welcome
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01欢迎</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Algorithms are everywhere.</p>
    <p class="line_zh">算法无处不在。</p>
    <p class="">Whether you are writing software, analyzing a genome, predicting traffic jams, producing automatic movie recommendations,
        or just surfing the Internet, you're dealing with algorithms.</p>
    <p class="line_zh">无论您是在编写软件，分析基因组，预测交通拥堵，制作自动电影推荐，还是只是上网，您都在处理算法。</p>
    <p class="">Every single branch of computer science uses algorithms, so a course on algorithms and data structures is an essential
        part of any CS curriculum.</p>
    <p class="line_zh">计算机科学的每一个分支都使用算法，因此关于算法和数据结构的课程是任何CS课程的重要组成部分。</p>
    <p class="">>> It's important that the algorithms we use are efficient as users want to see the search results in a blink of an eye
        even if they search through trillions of web pages.</p>
    <p class="line_zh">>>重要的是我们使用的算法是高效的，因为即使用户搜索数万亿个网页，用户也希望在眨眼之间看到搜索结果。</p>
    <p class="">A poorly thought out algorithm could take literally centuries to process all the webpages indexed by a search engine
        or all the Facebook posts.</p>
    <p class="line_zh">一个经过深思熟虑的算法可能花费几个世纪的时间来处理由搜索引擎或所有Facebook帖子索引的所有网页。</p>
    <p class="">And thus, algorithmic improvements are necessary to make these systems practical.</p>
    <p class="line_zh">因此，需要算法改进才能使这些系统变得实用。</p>
    <p class="">That's why tech companies always ask lots of algorithmic questions at the interviews.</p>
    <p class="line_zh">这就是为什么科技公司总是在面试中提出许多算法问题。</p>
    <p class="">>> In data science problems, like ranking internet search results, predicting road accidents, and recommending movies
        to users, advanced algorithms are used to achieve excellent search quality, high prediction accuracy, and to make
        relevant recommendations.</p>
    <p class="line_zh">>>在数据科学问题中，例如对互联网搜索结果进行排名，预测道路交通事故以及向用户推荐电影，使用高级算法来实现出色的搜索质量，高预测准确度以及提出相关建议。</p>
    <p class="">However, even for a simple machine learning algorithm like linear regression to be able to process big data is usually
        a challenge.</p>
    <p class="line_zh">然而，即使像线性回归这样的简单机器学习算法能够处理大数据通常也是一个挑战。</p>
    <p class="">When advanced algorithms such as deep neural networks are applied to huge data sets they make extremely accurate predictions.</p>
    <p class="line_zh">当诸如深度神经网络的高级算法应用于大型数据集时，它们可以进行非常准确的预测。</p>
    <p class="">Recently starting to even outperform humans in some areas of vision and speech recognition, but getting those algorithms
        to work in hours instead of years on a large dataset is hard.</p>
    <p class="line_zh">最近在视觉和语音识别的某些领域甚至开始甚至超过人类，但是在大型数据集上使这些算法在数小时而不是数年内工作是很困难的。</p>
    <p class="">And performing experiments quickly is crucial in data science.</p>
    <p class="line_zh">快速进行实验对数据科学至关重要。</p>
    <p class="">>> Algorithms are everywhere.</p>
    <p class="line_zh">>>算法无处不在。</p>
    <p class="">Each of trillions of cells in your body executes a complex and still poorly understood algorithm.</p>
    <p class="line_zh">身体中每万亿个细胞执行一个复杂且仍然难以理解的算法。</p>
    <p class="">And algorithm are the key for solving important biomedical problems such as what are the mutations that differentiate
        you from me and how is it they relate to diseases.</p>
    <p class="line_zh">算法是解决重要生物医学问题的关键，例如哪些突变可以使您与我区别开来，以及它们与疾病的关系如何。</p>
    <p class="">In this specialization you will learn the theory behind the algorithm.</p>
    <p class="line_zh">在这个专业化中，您将学习算法背后的理论。</p>
    <p class="">Implement algorithm in the programming language of your choice and apply them to solving practical problems such as assembling
        the genome from millions of tiny fragments, the largest jigsaw puzzle ever assembled by humans.</p>
    <p class="line_zh">在您选择的编程语言中实现算法，并将其应用于解决实际问题，例如从数百万个微小碎片组装基因组，这是人类组装过的最大的拼图游戏。</p>
    <p class="">>> To conclude, algorithms are everywhere.</p>
    <p class="line_zh">>>总而言之，算法无处不在。</p>
    <p class="">And it is important to design your algorithms and to implement them.</p>
    <p class="line_zh">设计算法并实现它们非常重要。</p>
    <p class="">To turn you into a pro in algorithm design we will give you nearly 100 programming assignments in this class.</p>
    <p class="line_zh">为了使您成为算法设计专家，我们将在此课程中为您提供近100个编程作业。</p>
    <p class="">Your solutions will be checked automatically, and you will learn how to implement, test, and debug fast algorithms solving
        large and difficult problems in seconds.</p>
    <p class="line_zh">您的解决方案将自动检查，您将学习如何实现，测试和调试快速算法，在几秒钟内解决大型和困难的问题。</p>
    <p class="">We look forward to seeing you in this class.</p>
    <p class="line_zh">我们期待在这堂课上见到你。</p>
    <p class="">We know it will make you a better programmer.</p>
    <p class="line_zh">我们知道它会让你成为更好的程序员。</p>
    <p class="">>> Algorithms are everywhere.</p>
    <p class="line_zh">>>算法无处不在。</p>
    <p class="">In fact you just saw five algorithms solving the fundamental sorting problem in computer science, and they all have different
        running times.</p>
    <p class="line_zh">事实上，你刚刚看到五种算法解决了计算机科学中的基本排序问题，它们都有不同的运行时间。</p>
    <p class="">In fact while four of them are about to finish one will take a much longer time.</p>
    <p class="line_zh">事实上，虽然其中四个即将完成，但需要更长的时间。</p>
    <p class="">In this specialization you'll be able to implement all of these algorithms, and master the skill of answering both algorithmic
        and programming questions at your next interview.</p>
    <p class="line_zh">在这个专业化中，您将能够实现所有这些算法，并掌握在下次面试时回答算法和编程问题的技巧。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 2 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_2">第04章 solving the problem screencast
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">04解决问题截屏</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hi, in this short video, we will solve a code problem together.</p>
    <p class="line_zh">嗨，在这个简短的视频中，我们将一起解决代码问题。</p>
    <p class="">The problem itself is quite elementary.</p>
    <p class="line_zh">问题本身是非常基本的。</p>
    <p class="">So the main purpose of this video is to show you the general pipeline of solving code problems in this class.</p>
    <p class="line_zh">因此，本视频的主要目的是向您展示解决此类中的代码问题的一般流程。</p>
    <p class="">The problem is called A plus B.</p>
    <p class="">这个问题叫A + B.</p>
    <p class="">In this problem, we are given two digits on the standard input and our goal is to output their sum on the standard output.</p>
    <p class="line_zh">在这个问题中，我们给出了标准输入的两位数，我们的目标是在标准输出上输出它们的总和。</p>
    <p class="">You can see two sample tests here on the page.</p>
    <p class="line_zh">您可以在页面上看到两个示例测试。</p>
    <p class="">For example, if the input for your program consists of the integers 3 and 2, then your program should output 5.</p>
    <p class="line_zh">例如，如果程序的输入包含整数3和2，则程序应输出5。</p>
    <p class="">If, on the other hand, the input consists of two integers 7 and 9, then your program is supposed to output 16, of course.</p>
    <p class="line_zh">另一方面，如果输入包含两个整数7和9，那么当然你的程序输出16。</p>
    <p class="">The next section consists of three Starter files.</p>
    <p class="line_zh">下一节包含三个Starter文件。</p>
    <p class="">Which in this particular case are actually solutions, not just starter files.</p>
    <p class="line_zh">在这种特殊情况下，实际上是解决方案，而不仅仅是初始文件。</p>
    <p class="">So the files are for programming languages Python, Java, and C++.</p>
    <p class="line_zh">因此这些文件适用于Python，Java和C ++编程语言。</p>
    <p class="">Finally the last section contains an instruction consisting of four steps on how to solve this problem.</p>
    <p class="line_zh">最后，最后一节包含一个指令，该指令包含有关如何解决此问题的四个步骤。</p>
    <p class="">So let's go through these four steps together.</p>
    <p class="line_zh">让我们一起完成这四个步骤。</p>
    <p class="">The first step is to download one of the starter files.</p>
    <p class="line_zh">第一步是下载其中一个入门文件。</p>
    <p class="">For this, let's select the C++ starter file, and let's download it.</p>
    <p class="line_zh">为此，让我们选择C ++启动文件，然后下载它。</p>
    <p class="">Okay.</p>
    <p class="line_zh">好的。</p>
    <p class="">Now the file is here and let's take a look inside.</p>
    <p class="line_zh">现在文件在这里，我们来看看里面。</p>
    <p class="">So, this is a very simple solution which, first, creates three variables.</p>
    <p class="line_zh">所以，这是一个非常简单的解决方案，首先创建三个变量。</p>
    <p class="">Then it reads a and b from the standard input.</p>
    <p class="line_zh">然后它从标准输入读取a和b。</p>
    <p class="">Then it computes the sum.</p>
    <p class="line_zh">然后它计算总和。</p>
    <p class="">And then finally it outputs the sum on the standard output.</p>
    <p class="line_zh">最后它输出标准输出的总和。</p>
    <p class="">So to run this program we first need to compile it.</p>
    <p class="line_zh">所以要运行这个程序，我们首先需要编译它。</p>
    <p class="">So this is the second step of our instruction.</p>
    <p class="line_zh">所以这是我们指导的第二步。</p>
    <p class="">For this we highly recommend to use the same compiler flags that are shown on this page.</p>
    <p class="line_zh">为此，我们强烈建议使用此页面上显示的相同编译器标志。</p>
    <p class="">This will ensure that your program behaves in the same way on the testing system and on your local machine.</p>
    <p class="line_zh">这将确保您的程序在测试系统和本地计算机上的行为方式相同。</p>
    <p class="">So in this case let's just copy the flags and use it to compile our program.</p>
    <p class="line_zh">所以在这种情况下，让我们只复制标志并使用它来编译我们的程序。</p>
    <p class="">So this produced an executable file a.out and we can now run it.</p>
    <p class="line_zh">所以这产生了一个可执行文件a.out，我们现在可以运行它了。</p>
    <p class="">Let's give this program for example 2 and 3.</p>
    <p class="line_zh">让我们给出这个例子2和3的程序。</p>
    <p class="">So the output is 5.</p>
    <p class="line_zh">所以输出是5。</p>
    <p class="">Well, one more test.</p>
    <p class="line_zh">好吧，还有一个测试。</p>
    <p class="">9 and 4, the output is 13 as expected.</p>
    <p class="line_zh">如图9和4所示，输出为预期的13。</p>
    <p class="">So far, so good.</p>
    <p class="line_zh">到现在为止还挺好。</p>
    <p class="">And now the next step is to actually submit this solution to this problem.</p>
    <p class="line_zh">现在，下一步是实际提交此解决方案以解决此问题。</p>
    <p class="">Let's go to my submission tab.</p>
    <p class="line_zh">我们去我的提交标签。</p>
    <p class="">Press create submission, then replace a file by this .cpp file And press the Submit button.</p>
    <p class="line_zh">按创建提交，然后用此.cpp文件替换文件并按“提交”按钮。</p>
    <p class="">So after a while, the testing system shows that our solution passed all the tests, which is quite satisfactory.</p>
    <p class="line_zh">经过一段时间后，测试系统显示我们的解决方案通过了所有测试，这是非常令人满意的。</p>
    <p class="">In this particular case, the grader output is empty, meaning that there is no error message in this case.</p>
    <p class="line_zh">在这种特殊情况下，分级器输出为空，这意味着在这种情况下没有错误消息。</p>
    <p class="">To illustrate it one more time, let me repeat the whole procedure quickly for the Python programming language.</p>
    <p class="line_zh">为了再次说明，让我快速重复Python编程语言的整个过程。</p>
    <p class="">So we first download the starter Python file.</p>
    <p class="line_zh">所以我们首先下载入门Python文件。</p>
    <p class="">Let's take a look at what is inside.</p>
    <p class="line_zh">我们来看看里面是什么。</p>
    <p class="">So the program is again very simple as expected.</p>
    <p class="line_zh">所以程序再次非常简单，如预期的那样。</p>
    <p class="">So we just take a and be from the standard input and we output the sum of a and b.</p>
    <p class="line_zh">所以我们只需从标准输入中取出a并输出a和b的总和。</p>
    <p class="">Now we need to run this program for this you might want to go to this available programming languages page.</p>
    <p class="line_zh">现在我们需要为此运行此程序，您可能希望转到此可用的编程语言页面。</p>
    <p class="">Again just to check how we run Python scripts so we just use Python, Python 3.</p>
    <p class="line_zh">再次，只是为了检查我们如何运行Python脚本，所以我们只使用Python，Python 3。</p>
    <p class="">So let's do this.</p>
    <p class="line_zh">所以，让我们这样做。</p>
    <p class="">For example 4, 4 and the output is 8 which is as expected.</p>
    <p class="line_zh">例如4,4，输出为8，这是预期的。</p>
    <p class="">So let's just go ahead and submit this solution.</p>
    <p class="line_zh">所以，让我们继续提交此解决方案。</p>
    <p class="">So you go to the my submission tab, you press the Create Submission button and then you replace this file by APlusB.py.</p>
    <p class="line_zh">因此，您转到我的提交选项卡，按“创建提交”按钮，然后用APlusB.py替换此文件。</p>
    <p class="">So when the file is uploaded, you finally press the Submit button.</p>
    <p class="line_zh">因此，当文件上传时，您最后按“提交”按钮。</p>
    <p class="">So in a few seconds, this solution will be accepted by the testing system.</p>
    <p class="line_zh">因此，在几秒钟内，该解决方案将被测试系统接受。</p>
    <p class="">Well this wasn't very challenging, right? In the next video we will see a much more interesting example of a computational
        problem.
    </p>
    <p class="line_zh">那么这不是很具挑战性，对吧？在下一个视频中，我们将看到一个更有趣的计算问题示例。</p>
    <p class="">For this problem we will start with a naive solution.</p>
    <p class="line_zh">对于这个问题，我们将从一个天真的解决方案开始。</p>
    <p class="">We will submit this solution to a testing system to figure out that it is buggy actually.</p>
    <p class="line_zh">我们将这个解决方案提交给测试系统，以确定它实际上是错误的。</p>
    <p class="">That there is a bug.</p>
    <p class="line_zh">那有一个bug。</p>
    <p class="">So we will fix this bug, submit it again, to find out that our solution is slow.</p>
    <p class="line_zh">因此，我们将修复此错误，再次提交，以发现我们的解决方案很慢。</p>
    <p class="">We will get a time limit exceeded feedback message from the testing system.</p>
    <p class="line_zh">我们将从测试系统获得超出时间限制的反馈消息。</p>
    <p class="">Meaning that for large data sets it works in more than one second, for example.</p>
    <p class="line_zh">例如，对于大型数据集，它的工作时间超过一秒。</p>
    <p class="">So this will require us to come up with a much, more faster solution.</p>
    <p class="line_zh">因此，这需要我们提出更快，更快的解决方案。</p>
    <p class="">We will implement it, submit it to the system, again, to find out that it is still buggy.</p>
    <p class="line_zh">我们将实施它，再次将其提交给系统，以发现它仍然是错误的。</p>
    <p class="">We will use stress testing to locate the bug, to fix it, and to finally submit a correct solution to the system which
        will pass all the tests.</p>
    <p class="line_zh">我们将使用压力测试来定位错误，修复它，并最终向系统提交正确的解决方案，该解决方案将通过所有测试。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 3 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_3">第03章 solving the problem improving the naive solution testing debugging
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">03解决问题改进天真解决方案测试调试</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this video, we will consider a more interesting code problem.</p>
    <p class="line_zh">在本视频中，我们将考虑更有趣的代码问题。</p>
    <p class="">This problem will require us to implement a faster than a naive solution first, then to debug it, then to stress test
        it before we actually come up with a correct solution that will be able to pass all the tests in the testing system.</p>
    <p class="line_zh">这个问题要求我们先实现一个比天真的解决方案更快，然后调试它，然后在我们真正提出一个能够通过测试系统中所有测试的正确解决方案之前对其进行压力测试。</p>
    <p class="">So the problem is called the maximum prioritized product problem.</p>
    <p class="line_zh">因此，该问题被称为最大优先级产品问题。</p>
    <p class="">In this problem, we're given an array, or a sequence of n numbers.</p>
    <p class="line_zh">在这个问题中，我们给出了一个数组或一个n个数字的序列。</p>
    <p class="">And our goal is to find a number which can be obtained by multiplying some two numbers from this sequence.</p>
    <p class="line_zh">我们的目标是找到一个数字，可以通过从这个序列中乘以两个数字来获得。</p>
    <p class="">So recall that our problem is given a sequence of n non-negative integers to find the maximum pairwise product.</p>
    <p class="line_zh">所以回想一下，我们的问题给出了一系列n个非负整数来找到最大的成对乘积。</p>
    <p class="">So the input to this problem consists of two lines.</p>
    <p class="line_zh">所以这个问题的输入包括两行。</p>
    <p class="">The first line contains just a single number n, which is at least 2 and at most 2 multiplied by 10 to the 5.</p>
    <p class="line_zh">第一行只包含一个数字n，它至少为2，最多2乘以10到5。</p>
    <p class="">The next line contains the sequence of n numbers which are non-negative integers not exceeding 10 to the 5.</p>
    <p class="line_zh">下一行包含n个数字的序列，这些数字是非负整数，不超过10到5。</p>
    <p class="">So our goal is to output a single number, the maximum pairwise product.</p>
    <p class="line_zh">所以我们的目标是输出一个数字，即最大的成对产品。</p>
    <p class="">The page contains also two sample tests.</p>
    <p class="line_zh">该页面还包含两个示例测试。</p>
    <p class="">For example, if an input to our program is a sequence of length 3 consisting of numbers 1, 2, 3, then the output should
        be, of course, 6, because this is just 2 multiplied by 3.</p>
    <p class="line_zh">例如，如果我们程序的输入是长度为3的序列，由数字1,2,3组成，那么输出当然应该是6，因为这只是2乘以3。</p>
    <p class="">For a slightly longer sequence of size 10, the output should be 140, and this is 10 multiplied by 14.</p>
    <p class="line_zh">对于稍长的10号序列，输出应为140，这是10乘以14。</p>
    <p class="">So as usual there is also a section that contains starter files and let's begin, choose C++ as our programming language
        for this problem.</p>
    <p class="line_zh">像往常一样，还有一个包含起始文件的部分，让我们开始吧，选择C ++作为我们这个问题的编程语言。</p>
    <p class="">This is how the starter C++ solution file looks like.</p>
    <p class="line_zh">这就是初学者C ++解决方案文件的样子。</p>
    <p class="">So we start by reading the number n from the standard input.</p>
    <p class="line_zh">因此，我们首先从标准输入中读取数字n。</p>
    <p class="">We then create an array, or a vector of size n.</p>
    <p class="line_zh">然后我们创建一个数组或大小为n的向量。</p>
    <p class="">We then fill in this vector by elements of our sequence, element by element.</p>
    <p class="line_zh">然后，我们通过元素逐个元素填充此向量。</p>
    <p class="">Then we read from the standard input.</p>
    <p class="line_zh">然后我们从标准输入中读取。</p>
    <p class="">We then pass the real numbers to the function MaxPairwiseProduct that computes the answer to our problem.</p>
    <p class="line_zh">然后我们将实数传递给MaxPairwiseProduct函数，该函数计算我们问题的答案。</p>
    <p class="">Let's see what is going on inside the function MaxPairwiseProduct.</p>
    <p class="line_zh">让我们看看MaxPairwiseProduct函数内部发生了什么。</p>
    <p class="">So we start by initializing the variable result by 0 and we then go through all possible pairs of different elements.</p>
    <p class="line_zh">因此，我们首先将变量结果初始化为0，然后我们遍历所有可能的不同元素对。</p>
    <p class="">That is, we go through all possible i and j, where i is less than j.</p>
    <p class="line_zh">也就是说，我们经历了所有可能的i和j，其中我小于j。</p>
    <p class="">We do this by two nested loops.</p>
    <p class="line_zh">我们通过两个嵌套循环来完成此操作。</p>
    <p class="">And for each such pair, we check whether the product of the corresponding two numbers is greater than our current result.</p>
    <p class="line_zh">对于每个这样的对，我们检查相应两个数字的乘积是否大于我们当前的结果。</p>
    <p class="">And if it is, we update the result.</p>
    <p class="line_zh">如果是，我们更新结果。</p>
    <p class="">Finally, we return the result.</p>
    <p class="line_zh">最后，我们返回结果。</p>
    <p class="">So this algorithm is correct for an obvious reason.</p>
    <p class="line_zh">所以这个算法是正确的，原因很明显。</p>
    <p class="">The goal in our problem is to find the maximum pairwise product, right? So to do this we just go through all possible
        pairs and select the maximum product.</p>
    <p class="line_zh">我们的问题的目标是找到最大的成对产品，对吧？所以要做到这一点，我们只需通过所有可能的对并选择最大产品。</p>
    <p class="">Okay, to check that it is indeed correct, let's, as usual, compile it.</p>
    <p class="line_zh">好的，要检查它是否确实正确，让我们像往常一样编译它。</p>
    <p class="">So for this we use.</p>
    <p class="line_zh">所以我们用它。</p>
    <p class="">The compiler flags for C++.</p>
    <p class="line_zh">C ++的编译器标志。</p>
    <p class="">Okay, and then, we test it.</p>
    <p class="line_zh">好的，然后，我们测试它。</p>
    <p class="">For example, for the sequence of length 3, consisting of numbers 1 through 3, then say 6.</p>
    <p class="line_zh">例如，对于长度为3的序列，由数字1到3组成，然后说6。</p>
    <p class="">Let's test it one more time.</p>
    <p class="line_zh">让我们再试一次吧。</p>
    <p class="">For example, this sequence of length 5.</p>
    <p class="line_zh">例如，这个长度为5的序列。</p>
    <p class="">Consisting of numbers 3, 4, 5, 1, 2.</p>
    <p class="line_zh">由数字3,4,5,1,2组成。</p>
    <p class="">So the answer is 20 as expected, because this is the product of 4 and 5.</p>
    <p class="line_zh">所以答案是预期的20，因为这是4和5的乘积。</p>
    <p class="">Okay, so it seems that this solution is correct and let's just go ahead and submit it as a solution to the testing system.</p>
    <p class="line_zh">好的，所以看来这个解决方案是正确的，让我们继续把它作为测试系统的解决方案提交。</p>
    <p class="">So I've just submitted our current solution to the grading system, but unfortunately it hadn't passed all the tests.</p>
    <p class="line_zh">所以我刚刚将我们当前的解决方案提交给了评分系统，但不幸的是它没有通过所有的测试。</p>
    <p class="">In particular, there is an error message shown in the grading system.</p>
    <p class="line_zh">特别是，评分系统中显示错误消息。</p>
    <p class="">Let's take a look.</p>
    <p class="line_zh">让我们来看看。</p>
    <p class="">So it says that our solution failed test case number three, which consists of just two numbers.</p>
    <p class="line_zh">所以它说我们的解决方案失败了第三个测试案例，它只包含两个数字。</p>
    <p class="">The first one is 10 to the 5, and the second one is 90,000.</p>
    <p class="line_zh">第一个是10到5，第二个是90,000。</p>
    <p class="">Let's check whether we can reproduce this behavior on our local machine.</p>
    <p class="line_zh">让我们检查一下我们是否可以在本地计算机上重现此行为。</p>
    <p class="">So let's call our program with just two numbers, 10 to the 5 and 90,000.</p>
    <p class="line_zh">所以我们只用两个数字来调用我们的程序，10到5和90,000。</p>
    <p class="">So indeed, as a result, instead of getting nine billions as we would expect, we got some random number.</p>
    <p class="line_zh">事实上，结果，我们得到了一些随机数，而不是像我们预期的那样获得九十亿。</p>
    <p class="">So this usually happens when there is an integer overflow.</p>
    <p class="line_zh">所以这通常发生在整数溢出时。</p>
    <p class="">And indeed, so we use the standard integer type for storing the result of multiplying two numbers.</p>
    <p class="line_zh">事实上，我们使用标准整数类型来存储两个数相乘的结果。</p>
    <p class="">While nine billion is too much for the integer type, so it doesn't fit into the integer type.</p>
    <p class="line_zh">虽然整数类型的90亿太多，但它不适合整数类型。</p>
    <p class="">So what we are supposed to do is actually to use a long, long C++ type.</p>
    <p class="line_zh">所以我们应该做的实际上是使用长而长的C ++类型。</p>
    <p class="">So let's do this and check whether this will fix our problem, our solution.</p>
    <p class="line_zh">所以，让我们这样做，检查这是否能解决我们的问题，我们的解决方案。</p>
    <p class="">So for this we need to change all the places where we compute and store the results.</p>
    <p class="line_zh">因此，我们需要更改计算和存储结果的所有位置。</p>
    <p class="">So first of all we change the declaration of this variable, we change also the type of the return observe returns result.</p>
    <p class="line_zh">所以首先我们改变这个变量的声明，我们也改变了返回观察返回结果的类型。</p>
    <p class="">When computing the product of this to numbers we first cast.</p>
    <p class="line_zh">在计算我们首先投射的数字的乘积时。</p>
    <p class="">For example, the first one to the long, long type.</p>
    <p class="line_zh">例如，第一个是long，long类型。</p>
    <p class="">Okay, and also here, great.</p>
    <p class="line_zh">好的，也在这里，很棒。</p>
    <p class="">Let's now compile it once again.</p>
    <p class="line_zh">我们现在再次编译它。</p>
    <p class="">Yes, and let's run it to check whether it correctly processes our previous data set.</p>
    <p class="line_zh">是的，让我们运行它来检查它是否正确处理我们以前的数据集。</p>
    <p class="">So 10 to the 5 and 90,000.</p>
    <p class="line_zh">所以10到5和90,000。</p>
    <p class="">Great, so it correctly outputs nine billion.</p>
    <p class="line_zh">太好了，所以它正确输出了90亿。</p>
    <p class="">So now, we must be completely sure that our solution is correct.</p>
    <p class="line_zh">所以现在，我们必须完全确定我们的解决方案是正确的。</p>
    <p class="">Because, well, first of all, to find the maximum pairwise product, we'd just go through all possible pairs and select
        the maximum product.</p>
    <p class="line_zh">因为，首先，要找到最大的成对产品，我们只需通过所有可能的配对并选择最大产品。</p>
    <p class="">So what can we do else? And also, we now use the right type for storing the result.</p>
    <p class="line_zh">那么我们还能做些什么呢？而且，我们现在使用正确的类型来存储结果。</p>
    <p class="">So let's go ahead and submit our new solution to the grading system.</p>
    <p class="line_zh">那么让我们继续将我们的新解决方案提交给评分系统。</p>
    <p class="">Unfortunately our solution is still incorrect.</p>
    <p class="">不幸的是我们的解决方</p>
    <p class="">So in this particular case, the output of the grading system is the following: Failed case 4, time limit exceeded.</p>
    <p class="line_zh">因此，在这种特殊情况下，评分系统的输出如下：案例4失败，超出时间限制。</p>
    <p class="">So it means that our solution is quite slow, that for large datasets it runs in more than one second.</p>
    <p class="line_zh">因此，这意味着我们的解决方案非常缓慢，对于大型数据集而言，它的运行时间超过一秒钟。</p>
    <p class="">So let's try to understand why it so happens.</p>
    <p class="line_zh">所以让我们试着理解为什么会这样。</p>
    <p class="">First of all, the maximum size of a data set is the maximum size of a sequence for this problem, in our case, it is roughly
        10 to the 5.</p>
    <p class="line_zh">首先，数据集的最大大小是此问题的序列的最大大小，在我们的例子中，它大约是10到5。</p>
    <p class="">So what is the number of operations performed by our algorithm on such a sequence? So recall that in our algorithm we
        just go through all possible pairs of input numbers.</p>
    <p class="line_zh">那么我们的算法在这样的序列上执行的操作数量是多少？所以请记住，在我们的算法中，我们只需要检查所有可能的输入数字对。</p>
    <p class="">So this is roughly n squared.</p>
    <p class="line_zh">所以这大致是n平方。</p>
    <p class="">So when n is equal to 10 to the 5, this is 10 to the 10.</p>
    <p class="line_zh">所以当n等于10到5时，这是10到10。</p>
    <p class="">And this is more than one billion.</p>
    <p class="line_zh">这超过十亿。</p>
    <p class="">And one billion is roughly the number of basic operations that modern computers can perform in one second.</p>
    <p class="line_zh">10亿大约是现代计算机在一秒钟内可以执行的基本操作的数量。</p>
    <p class="">So we conclude that we need a faster algorithm to solve this problem.</p>
    <p class="line_zh">因此我们得出结论，我们需要一种更快的算法来解决这个问题。</p>
    <p class="">In particular, we realize that we need to find the maximum pairwise product, without actually going through all possible
        pairs of numbers.</p>
    <p class="line_zh">特别是，我们意识到我们需要找到最大的成对产品，而不是实际经历所有可能的数字对。</p>
    <p class="">So in search of an inspiration, let's take a look at the problem page.</p>
    <p class="line_zh">因此，在寻找灵感时，让我们来看一下问题页面。</p>
    <p class="">In particular let's review the second sample case.</p>
    <p class="line_zh">特别让我们回顾一下第二个案例。</p>
    <p class="">In this case, our input consists of ten integers, and the output in this case, is 140.</p>
    <p class="line_zh">在这种情况下，我们的输入由十个整数组成，在这种情况下，输出为140。</p>
    <p class="">And why is that? Well, this is just because in our sequence there are two numbers, 14 and 10.</p>
    <p class="line_zh">为什么是这样？嗯，这只是因为在我们的序列中有两个数字，14和10。</p>
    <p class="">These two numbers are two maximal numbers actually.</p>
    <p class="line_zh">这两个数字实际上是两个最大数。</p>
    <p class="">So for any other two numbers, their product are less than 140.</p>
    <p class="line_zh">因此，对于任何其他两个数字，他们的产品不到140。</p>
    <p class="">So this gives us an idea: that to find the maximum product of two numbers from our sequence, it is actually enough to
        find two maximal numbers in our sequence.</p>
    <p class="line_zh">所以这给了我们一个想法：为了从我们的序列中找到两个数的最大乘积，实际上足以在我们的序列中找到两个最大数。</p>
    <p class="">This is because all of our integers in this sequence are non-negative.</p>
    <p class="line_zh">这是因为这个序列中的所有整数都是非负的。</p>
    <p class="">So let's just implement this idea in our C++ file.</p>
    <p class="line_zh">所以，让我们在C ++文件中实现这个想法。</p>
    <p class="">So this is already implemented, and it looks as follows.</p>
    <p class="line_zh">所以这已经实现了，它看起来如下。</p>
    <p class="">So the new function is called MaxPairwiseProductFast.</p>
    <p class="line_zh">因此新函数称为MaxPairwiseProductFast。</p>
    <p class="">So it already uses the long.long type for storing the result and we do the following.</p>
    <p class="line_zh">所以它已经使用long.long类型来存储结果，我们执行以下操作。</p>
    <p class="">Just by scanning the input array two times, we find two maximal numbers.</p>
    <p class="line_zh">只需扫描输入数组两次，我们就会发现两个最大数字。</p>
    <p class="">So in the first block, we find the first maximum and we store its index in the max_index variable, and in the second
        block, we find the second maximal element.</p>
    <p class="line_zh">所以在第一个块中，我们找到第一个最大值，我们将其索引存储在max_index变量中，而在第二个块中，我们找到第二个最大元素。</p>
    <p class="">So the difference in the second block is that we also need to skip the first maximal element while scanning the array.</p>
    <p class="line_zh">所以第二个块的不同之处在于我们还需要在扫描数组时跳过第一个最大元素。</p>
    <p class="">So what we do is, we do this in this check.</p>
    <p class="line_zh">所以我们做的是，我们在这个检查中这样做。</p>
    <p class="">Okay, and then we just return the product of two maximum numbers in our array, right? Let's, as usual, compile it and
        see that everything works correctly.</p>
    <p class="line_zh">好的，然后我们只返回数组中两个最大数字的乘积，对吧？让我们像往常一样编译它，看看一切正常。</p>
    <p class="">So, this is our new file, max_pairwise_product_fast.ccp.</p>
    <p class="line_zh">所以，这是我们的新文件max_pairwise_product_fast.ccp。</p>
    <p class="">We compile it and we first run it on some small sequence.</p>
    <p class="line_zh">我们编译它，我们首先在一些小序列上运行它。</p>
    <p class="">For example, size 3, for example, 2, 3, 4 it gives us 12 as expected.</p>
    <p class="line_zh">例如，大小3，例如2,3,4，它按预期给出了12。</p>
    <p class="">Great, now let's do the following.</p>
    <p class="line_zh">太好了，现在让我们做以下几点。</p>
    <p class="">Let's check what is the running time when a huge data set.</p>
    <p class="line_zh">让我们来看看庞大数据集的运行时间。</p>
    <p class="">So for this, let's instead of reading the data from the standard input, let's just generate a huge array here.</p>
    <p class="line_zh">所以对于这个，我们不是从标准输入中读取数据，而是在这里生成一个巨大的数组。</p>
    <p class="">Let's use vector of int of size 10 to the 5, and let it be an array filled by zeroes, let's compile it and let's run
        it.
    </p>
    <p class="line_zh">让我们使用大小为10的int到5的向量，让它成为一个由零填充的数组，让我们编译它然后让它运行它。</p>
    <p class="">So it outputs zero immediately which means that it, well, it is much faster then the previous algorithm.</p>
    <p class="line_zh">所以它立即输出零，这意味着它，它比以前的算法快得多。</p>
    <p class="">So now our solution just must be completely correct.</p>
    <p class="line_zh">所以现在我们的解决方案必须完全正确。</p>
    <p class="">So it is fast, it uses the right type for storing the solution and it is also obviously correct because, well it selects
        two maximal numbers, right, and multiplies them.</p>
    <p class="line_zh">所以它很快，它使用正确的类型来存储解决方案，它也显然是正确的，因为它选择两个最大数字，正确，并将它们相乘。</p>
    <p class="">No other product of two numbers can be larger because we selected two maximal numbers.</p>
    <p class="line_zh">没有其他两个数字的乘积可以更大，因为我们选择了两个最大数字。</p>
    <p class="">However, unfortunately, even this solution is not correct.</p>
    <p class="line_zh">然而，遗憾的是，即使这种解决方案也不正确。</p>
    <p class="">So you can submit it to the testing system and see that the output will be wrong answer for some test case.</p>
    <p class="line_zh">因此，您可以将其提交给测试系统，并看到输出对于某些测试用例来说是错误的答案。</p>
    <p class="">In the next video, Michael will tell you about stress testing and will show you how to fix this solution.</p>
    <p class="line_zh">在下一个视频中，迈克尔将告诉您有关压力测试的信息，并将向您展示如何修复此解决方案。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 4 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_4">第05章 stress test implementation
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">05压力测试实施</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">The previous video ended on an unsuccessful attempt to submit our solution to the max pairwise product problem.</p>
    <p class="line_zh">之前的视频以尝试提交我们的最大成对产品问题解决方案而告终。</p>
    <p class="">Even worse, we don't know what is the test on which our program fails because the system doesn't show it to us.</p>
    <p class="line_zh">更糟糕的是，我们不知道我们的程序失败的测试是什么，因为系统没有向我们展示。</p>
    <p class="">This is actually a pretty standard situation when solving algorithmic programming assignments.</p>
    <p class="line_zh">在解决算法编程分配时，这实际上是一个非常标准的情况。</p>
    <p class="">In this, and the next few videos, we will learn how to overcome this situation and to even avoid it in the first place.</p>
    <p class="line_zh">在此以及接下来的几个视频中，我们将学习如何克服这种情况，甚至首先避免它。</p>
    <p class="">I will explain to you and show you in action a powerful technique called stress testing.</p>
    <p class="line_zh">我将向您解释并向您展示一种称为压力测试的强大技术。</p>
    <p class="">By the end, you will be able to implement a stress test for your solution of an algorithmic problem, use it to find a
        small and easy test on which your program fails, debug your program, and make sure it works correctly afterwards
        with high confidence.</p>
    <p class="line_zh">最后，您将能够针对算法问题的解决方案实施压力测试，使用它来查找程序失败的小而简单的测试，调试程序，并确保它在之后以高可信度正常工作。</p>
    <p class="">Also, you will be able to list and apply the set of standard testing techniques, which should be always applied when
        solving algorithmic programming assignments.</p>
    <p class="line_zh">此外，您将能够列出并应用一组标准测试技术，在解决算法编程任务时应始终应用这些技术。</p>
    <p class="">So what is stress testing? In general, it is a program that generates random tests in an infinite loop, and for each
        test, it launches your solution on this test and an alternative solution on the same test and compares the results.</p>
    <p class="line_zh">什么是压力测试？通常，它是一个在无限循环中生成随机测试的程序，对于每个测试，它会在此测试中启动您的解决方案，并在同一测试中启动替代解决方案并比较结果。</p>
    <p class="">This alternative solution you also have to invent and implement yourself, but it is usually easy, because it can be any
        simple, slow, brute force solution, or just any other solution that you can come up with.</p>
    <p class="line_zh">这个替代解决方案您还必须自己发明和实现，但它通常很容易，因为它可以是任何简单，缓慢，强力的解决方案，或者您可以提出的任何其他解决方案。</p>
    <p class="">The only requirement is that it should be significantly different from your main solution.</p>
    <p class="line_zh">唯一的要求是它应该与您的主要解决方案有很大不同。</p>
    <p class="">Then you just wait until you find a test on which your solutions differ.</p>
    <p class="line_zh">然后你要等到找到解决方案不同的测试。</p>
    <p class="">If one of them is correct and another is wrong, then it is guaranteed to happen, because there is some test for which
        your wrong solution gives the wrong answer, and your correct solution gives correct answer, and so they differ.</p>
    <p class="line_zh">如果其中一个是正确的而另一个是错误的，那么肯定会发生，因为有一些测试，你的错误解决方案给出了错误的答案，而你的正确解决方案给出了正确答案，因此它们有所不同。</p>
    <p class="">If, however, both of your solutions are wrong, which also happens often, they are still almost guaranteed to have some
        test on which one of them gives wrong answer and another one gives correct answer because they're probably wrong
        in different places.</p>
    <p class="line_zh">但是，如果你的两个解决方案都是错误的，这也经常发生，他们几乎可以保证对其中一个给出错误答案进行一些测试，另一个给出正确答案，因为它们在不同的地方可能是错误的。</p>
    <p class="">When you find a test on which your solutions' answers differ, you can determine which one of them returns wrong answer
        and debug it, fix it, and then repeat the stress testing.</p>
    <p class="line_zh">当您找到解决方案的答案不同的测试时，您可以确定其中哪一个返回错误的答案并进行调试，修复它，然后重复压力测试。</p>
    <p class="">Now let's look at the practical implementation.</p>
    <p class="line_zh">现在让我们来看看实际的实现。</p>
    <p class="">I've already implemented the stress test for this problem.</p>
    <p class="line_zh">我已经针对这个问题实施了压力测试。</p>
    <p class="">It is in the file called stress_test.cpp.</p>
    <p class="line_zh">它位于名为stress_test.cpp的文件中。</p>
    <p class="">Let's look into that.</p>
    <p class="line_zh">让我们来看看。</p>
    <p class="">So it is almost the same as the solution that we've sent in the previous video, but I've added some things.</p>
    <p class="line_zh">所以它与我们在之前的视频中发送的解决方案几乎相同，但我添加了一些内容。</p>
    <p class="">First, we add this #include
        <cstd.lib>.</p>
    <p class="line_zh">首先，我们添加#include
        <cstd.lib>。</p>
    <p class="">And this include just allows us to use a part of standard library to generate some random numbers.</p>
    <p class="line_zh">这包括只允许我们使用标准库的一部分来生成一些随机数。</p>
    <p class="">And we will use it to generate some random tests automatically.</p>
    <p class="line_zh">我们将使用它自动生成一些随机测试。</p>
    <p class="">Then we have the same code of two functions, MaxPairwiseProduct and MaxPairwiseProductFast, which we used in our last
        solution which was submitted in the system.</p>
    <p class="line_zh">然后我们有两个函数的相同代码，MaxPairwiseProduct和MaxPairwiseProductFast，我们在系统中提交的最后一个解决方案中使用了它们。</p>
    <p class="">But now in the main function, we have a whole additional while loop.</p>
    <p class="line_zh">但是现在在main函数中，我们有一个完整的while循环。</p>
    <p class="">Here it is, and this is where the stress test itself is.</p>
    <p class="line_zh">在这里，这是压力测试本身的地方。</p>
    <p class="">So what do we do in principle is we generate some random tests, then we launch both solutions, MaxPairwiseProduct and
        MaxPairwiseProductFast on this random test, and we compare the results.</p>
    <p class="line_zh">那么我们原则上做的是生成一些随机测试，然后我们在这个随机测试中启动两个解决方案，MaxPairwiseProduct和MaxPairwiseProductFast，然后我们比较结果。</p>
    <p class="">And the idea is if you have a correct solution and another correct solution and the correct answer for your problem is
        the only correct answer, then any two correct solutions will give the same answers for any test.</p>
    <p class="line_zh">这个想法是，如果你有一个正确的解决方案和另一个正确的解决方案，你的问题的正确答案是唯一正确的答案，那么任何两个正确的解决方案将为任何测试给出相同的答案。</p>
    <p class="">And if you have some wrong solution and some correct solution, then on some tests, their answers will differ.</p>
    <p class="line_zh">如果你有一些错误的解决方案和一些正确的解决方案，那么在一些测试中，他们的答案会有所不同。</p>
    <p class="">And also if you have two wrong solutions, then probably they're wrong in a different way, and then there will also be
        some test, hopefully, on which their answers differ.</p>
    <p class="line_zh">而且如果你有两个错误的解决方案，那么他们可能会以不同的方式出错，然后还会有一些测试，希望他们的答案不同。</p>
    <p class="">If you generate a lot of tests, then with some probability, at some point, you will generate a test for which the answers
        of the solutions differ.</p>
    <p class="line_zh">如果您生成了大量测试，那么在某些时候，您将生成一个测试，解决方案的答案会有所不同。</p>
    <p class="">You can detect that situation, and then look at the input test and at the answers.</p>
    <p class="line_zh">您可以检测到这种情况，然后查看输入测试和答案。</p>
    <p class="">And you can determine which of the algorithms was right, and which was wrong, maybe both were wrong.</p>
    <p class="line_zh">而且你可以确定哪些算法是正确的，哪些是错误的，也许两者都是错的。</p>
    <p class="">But anyway, you will find at least one of the algorithms which are wrong because if their answers are different, then
        at least one of them gives wrong answer.</p>
    <p class="line_zh">但无论如何，你会发现至少有一个算法是错误的，因为如果他们的答案不同，那么至少有一个算法会给出错误的答案。</p>
    <p class="">And then you will be able to debug that algorithm, fix the bug, and then run the stress test again.</p>
    <p class="line_zh">然后您将能够调试该算法，修复错误，然后再次运行压力测试。</p>
    <p class="">And either, you will again find some difference, or you won't find any difference anymore, and then hopefully, you fixed
        all the bugs in all the solutions, and you can submit it.</p>
    <p class="line_zh">或者，你会再次发现一些差异，或者你不会再发现任何差异，然后希望你能解决所有解决方案中的所有错误，并且你可以提交它。</p>
    <p class="">So how it works in practice.</p>
    <p class="line_zh">那么它在实践中是如何运作的。</p>
    <p class="">First, we need to generate the test for our problem.</p>
    <p class="line_zh">首先，我们需要为我们的问题生成测试。</p>
    <p class="">We'll start with generating number n, the number of numbers.</p>
    <p class="line_zh">我们将从生成数字n（数字的数量）开始。</p>
    <p class="">And our problem states that n should be at least 2.</p>
    <p class="line_zh">我们的问题是n应该至少为2。</p>
    <p class="">So we first generate a big random number using function rand.</p>
    <p class="line_zh">所以我们首先使用函数rand生成一个大的随机数。</p>
    <p class="">Then we take it modulo 10, and it gives us some random number between 0 and 9, and then we add 2.</p>
    <p class="line_zh">然后我们取模10，它给我们一些0到9之间的随机数，然后我们加2。</p>
    <p class="">And so we get a random number between 2 and 11.</p>
    <p class="line_zh">所以我们得到一个2到11之间的随机数。</p>
    <p class="">Why is it so small? Well, we first want both our solutions to work fast enough.</p>
    <p class="line_zh">它为什么这么小？好吧，我们首先希望我们的解决方案能够足够快地运行。</p>
    <p class="">And also if we create a big random test, it will be hard for us to debug it, so we start with some relatively small value
        of n.</p>
    <p class="line_zh">而且如果我们创建一个大的随机测试，我们将很难调试它，所以我们从一些相对较小的n值开始。</p>
    <p class="">We immediately output it on the screen, so that if we find some tests for which our solution is wrong, we immediately
        see it on the screen.</p>
    <p class="line_zh">我们立即在屏幕上输出它，这样如果我们找到一些我们的解决方案错误的测试，我们会立即在屏幕上看到它。</p>
    <p class="">After generating n, we should generate the array of numbers, a, itself.</p>
    <p class="line_zh">在生成n之后，我们应该生成数字数组a，它本身。</p>
    <p class="">So we iterate n times, and we add random numbers from 0 to 99,999 to the end of array a.</p>
    <p class="line_zh">所以我们迭代n次，然后我们将0到99,999之间的随机数添加到数组a的末尾。</p>
    <p class="">So these are the numbers in the range which is allowed.</p>
    <p class="line_zh">所以这些是允许范围内的数字。</p>
    <p class="">And then we also output all these numbers in one line, separated by spaces and a newline character.</p>
    <p class="line_zh">然后我们还将所有这些数字输出到一行中，用空格和换行符分隔。</p>
    <p class="">So by this time, we've already output the whole input test on the screen.</p>
    <p class="line_zh">所以到目前为止，我们已经在屏幕上输出了整个输入测试。</p>
    <p class="">Now what we need to do is actually need to launch both our solutions on this input test and get two results, the result
        of the main solution and the result of the fast solution.</p>
    <p class="line_zh">现在我们需要做的是实际上需要在此输入测试中启动我们的解决方案并获得两个结果，主要解决方案的结果和快速解决方案的结果。</p>
    <p class="">After that, we compare those two results.</p>
    <p class="line_zh">之后，我们比较这两个结果。</p>
    <p class="">If they are different, it means that at least one of the solutions was wrong.</p>
    <p class="line_zh">如果它们不同，则意味着至少有一种解决方案是错误的。</p>
    <p class="">So we output words Wrong answer on the screen, and we also output the first result, a space, and the second result and
        a newline character.</p>
    <p class="line_zh">所以我们在屏幕上输出错误的答案，我们还输出第一个结果，一个空格，第二个结果和一个换行符。</p>
    <p class="">After that, we break our loop.</p>
    <p class="line_zh">在那之后，我们打破了循环。</p>
    <p class="">We can notice that our while loop is a so-called infinite loop, but we actually end it as soon as we find some test for
        which our solutions differ.</p>
    <p class="line_zh">我们可以注意到我们的while循环是一个所谓的无限循环，但是一旦我们找到一些我们的解决方案不同的测试，我们就会立即结束它。</p>
    <p class="">If we don't find the different sum test, we just output the word OK on the screen, to denote that actually both solutions
        have already computed the answers, but the answers are the same.</p>
    <p class="line_zh">如果我们没有找到不同的总和测试，我们只是在屏幕上输出单词OK，表示实际上两个解决方案都已经计算了答案，但答案是相同的。</p>
    <p class="">And then we continue.</p>
    <p class="line_zh">然后我们继续。</p>
    <p class="">So we continue our infinite loop, in the search of the test that will save us, that we can use to debug our solution.</p>
    <p class="line_zh">所以我们继续我们的无限循环，在搜索将拯救我们的测试中，我们可以用来调试我们的解决方案。</p>
    <p class="">And we wrote that code just in front of all the code to read the numbers from the input, to compute the answer, and to
        output it to the screen.</p>
    <p class="line_zh">我们在所有代码前面编写了代码，以便从输入中读取数字，计算答案，并将其输出到屏幕。</p>
    <p class="">So we basically inserted this code in our regular program.</p>
    <p class="line_zh">所以我们基本上在常规程序中插入了这段代码。</p>
    <p class="">But instead of reading numbers from the input, it will first try to find the test for which our two solutions differ.</p>
    <p class="line_zh">但是，它不是从输入中读取数字，而是首先尝试找到我们的两个解决方案不同的测试。</p>
    <p class="">And in the next video, we will launch this stress test to find a test in which our solutions differ, debug our fast solution,
        and fix it.</p>
    <p class="line_zh">在下一个视频中，我们将启动此压力测试，以找到我们的解决方案不同的测试，调试我们的快速解决方案并进行修复。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 5 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_5">第06章 stress test find the test and debug
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">06压力测试找到测试和调试</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this video we will launch the stress test to find a test on which our main solution and alternative solutions differ,
        use this test to debug our main solution and fix it.</p>
    <p class="line_zh">在本视频中，我们将启动压力测试以找到我们的主要解决方案和替代解决方案不同的测试，使用此测试来调试我们的主要解决方案并进行修复。</p>
    <p class="">So we save the file.</p>
    <p class="line_zh">所以我们保存文件。</p>
    <p class="">Now we will compile this file because we will want to run it.</p>
    <p class="line_zh">现在我们将编译此文件，因为我们想要运行它。</p>
    <p class="">And to compile this file, we go to the section Solving Programming Assignments.</p>
    <p class="line_zh">要编译此文件，我们转到解决编程分配部分。</p>
    <p class="">We look at the C++ Flags, copy them, and then use them to compile our file.</p>
    <p class="line_zh">我们查看C ++ Flags，复制它们，然后使用它们来编译我们的文件。</p>
    <p class="">Also, of course, specify which file want to compile and also the name for the output file will be stress_test, without
        .cpp.
    </p>
    <p class="line_zh">当然，还要指定要编译的文件，输出文件的名称也是stress_test，不带.cpp。</p>
    <p class="">So we compile our stress test and then we launch it and see what happens.</p>
    <p class="line_zh">所以我们编译压力测试，然后启动它，看看会发生什么。</p>
    <p class="">So we see, our screen was filled with a lot of lines.</p>
    <p class="line_zh">所以我们看到，我们的屏幕充满了很多线条。</p>
    <p class="">Actually, those lines were words, OK, and some numbers, like number n from 2 to 11, and input numbers, which are big.</p>
    <p class="line_zh">实际上，那些行是单词，OK，还有一些数字，比如2到11之间的数字n，以及很大的输入数字。</p>
    <p class="">And there are a lot of tests for which our solutions didn't differ, and that all went pretty fast.</p>
    <p class="line_zh">有很多测试我们的解决方案没有区别，而且一切都进行得非常快。</p>
    <p class="">And then in the end, we have number 11, which is n, and then 11 big numbers, which is the input test, and then the words,
        Wrong answer and two very big numbers which are different, which are the answers correspondingly of the first and
        the second solution we implemented.</p>
    <p class="line_zh">然后最后，我们有11号，这是n，然后是11个大数字，这是输入测试，然后是单词，错误答案和两个非常大的数字，它们是相应的答案。我们实施的第一个和第二个解决方案</p>
    <p class="">So now, we already have a test on which at least one of our solution runs incorrectly.</p>
    <p class="line_zh">所以现在，我们已经有一个测试，其中至少有一个解决方案运行不正确。</p>
    <p class="">But it is very hard to work with this test because we have 11 numbers and they are very big and the answer to this problem
        is even bigger.</p>
    <p class="line_zh">但是这个测试很难处理，因为我们有11个数字而且非常大，这个问题的答案更大。</p>
    <p class="">So let us try to find a smaller test on which our solution still fails.</p>
    <p class="line_zh">因此，让我们尝试找一个我们的解决方案仍然失败的较小测试。</p>
    <p class="">Usually we can create a very small test with this technique.</p>
    <p class="line_zh">通常我们可以用这种技术创建一个非常小的测试。</p>
    <p class="">So let's go back to our code, stress_test.cpp.</p>
    <p class="line_zh">那么让我们回到我们的代码，stress_test.cpp。</p>
    <p class="">And let's decrease the restrictions on n and on the numbers.</p>
    <p class="line_zh">让我们减少对n和数字的限制。</p>
    <p class="">So, for example, we want our number n to be no more than 5, then we first generate a random number modulo 4 so it will
        be from 0 to 3.</p>
    <p class="line_zh">因此，例如，我们希望我们的数字n不超过5，然后我们首先生成一个模4的随机数，因此它将从0到3。</p>
    <p class="">And then, after adding 2, it will be from 2 to 5.</p>
    <p class="line_zh">然后，在添加2之后，它将从2到5。</p>
    <p class="">And also, we want our numbers to be less than 10.</p>
    <p class="line_zh">而且，我们希望我们的数字小于10。</p>
    <p class="">So we just generate numbers modulo ten.</p>
    <p class="line_zh">所以我们只生成模数十。</p>
    <p class="">And that's everything we change.</p>
    <p class="line_zh">这就是我们改变的一切。</p>
    <p class="">Now we save the file.</p>
    <p class="line_zh">现在我们保存文件。</p>
    <p class="">We recompile with the same options.</p>
    <p class="line_zh">我们使用相同的选项重新编译。</p>
    <p class="">And we again launch our stress test.</p>
    <p class="line_zh">我们再次启动压力测试。</p>
    <p class="">Now, we found a test on which solutions differ even faster.</p>
    <p class="line_zh">现在，我们找到了一个测试，解决方案的差异更快。</p>
    <p class="">Only maybe five or seven tests were OK.</p>
    <p class="line_zh">只有五到七次测试都可以。</p>
    <p class="">And now we have a test with five numbers, which are 2, 9, 3, 1, and 9, on which our solutions differ.</p>
    <p class="line_zh">现在我们有一个测试，有五个数字，分别是2个，9个，3个，1个和9个，我们的解决方案就不同了。</p>
    <p class="">And the answer of the first solution is 81.</p>
    <p class="line_zh">第一个解决方案的答案是81。</p>
    <p class="">And the answer of the second solution is 27.</p>
    <p class="line_zh">而第二个解决方案的答案是27。</p>
    <p class="">Which one of those is correct? Of course, the first one is correct, because we have numbers 9 and second 9, which are
        the biggest in the input, and their product is 81.</p>
    <p class="line_zh">哪一个是正确的？当然，第一个是正确的，因为我们有数字9和第二9，这是输入中最大的，他们的产品是81。</p>
    <p class="">So our first naive solution gives a correct answer, but our second fast solution gives an incorrect answer.</p>
    <p class="">所以我们的第一个天真的解决方案给出了正确的答案，但我们的第二个快速解决方案给出了错</p>
    <p class="">And let's think why that can be.</p>
    <p class="line_zh">让我们想想为什么会这样。</p>
    <p class="">Well, that can be if it multiplies wrong numbers from the array.</p>
    <p class="line_zh">好吧，如果它从数组中乘以错误的数字就可以了。</p>
    <p class="">So, let's go back in the code and check which are those numbers.</p>
    <p class="line_zh">那么，让我们回到代码中并检查这些数字。</p>
    <p class="">We can go into the code and we look into the code for function MaxPairwiseProductFast.</p>
    <p class="line_zh">我们可以进入代码，然后查看函数MaxPairwiseProductFast的代码。</p>
    <p class="">It's very convenient that we have a separate function for this solution because the error should be localized somewhere
        here.
    </p>
    <p class="line_zh">我们为此解决方案提供单独的功能非常方便，因为错误应该在此处的某处进行本地化。</p>
    <p class="">So to simplify our goal of debugging, let's output the indices of the maximum number and of the second maximum number
        that at least this function thinks are two maximums in the array.</p>
    <p class="line_zh">因此，为了简化我们的调试目标，让我们输出最大数量和第二个最大数量的索引，至少这个函数认为是数组中的两个最大值。</p>
    <p class="">So we output them to cout.</p>
    <p class="line_zh">所以我们将它们输出到cout。</p>
    <p class="">First the first index, then a space to separate them, then the second index, and then newline character.</p>
    <p class="line_zh">首先是第一个索引，然后是一个空格来分隔它们，然后是第二个索引，然后是换行符。</p>
    <p class="">So we save our program.</p>
    <p class="line_zh">所以我们保存我们的程序。</p>
    <p class="">We again recompile it, and we again launch the stress test.</p>
    <p class="line_zh">我们再次重新编译它，我们再次启动压力测试。</p>
    <p class="">So note that although we generate random tests, it is safe to launch our stress test again because those are pseudo random.</p>
    <p class="line_zh">所以请注意，虽然我们生成随机测试，但再次启动压力测试是安全的，因为它们是伪随机的。</p>
    <p class="">The sequence of generated random values is the same.</p>
    <p class="line_zh">生成的随机值的序列是相同的。</p>
    <p class="">So this is a reproducible test.</p>
    <p class="line_zh">所以这是一个可重复的测试。</p>
    <p class="">So now, again, we have the same test in which two solutions differ with five numbers, the same five numbers.</p>
    <p class="line_zh">所以现在，我们再次进行相同的测试，其中两个解决方案有五个数字相同，相同的五个数字。</p>
    <p class="">And now, under the line with five numbers, we have another line which says 1 2.</p>
    <p class="line_zh">现在，在有五个数字的行下，我们有另一行说1 2。</p>
    <p class="">This is actually our debug output, which means that the index of the first number, which is maximum, is 1 and it corresponds
        to number 9 because we enumerate our numbers from 0 in our C++ array.</p>
    <p class="line_zh">这实际上是我们的调试输出，这意味着第一个数字的索引（最大值）为1，它对应于数字9，因为我们在C ++数组中枚举了0的数字。</p>
    <p class="">And the second number has index 2, and this is number 3, again, because we enumerate from 0.</p>
    <p class="line_zh">第二个数字有索引2，这也是数字3，因为我们从0开始枚举。</p>
    <p class="">So, our fast solution thinks that the second maximum number in the array is the number 3 instead of number 9, which is
        in position four.</p>
    <p class="line_zh">因此，我们的快速解决方案认为数组中的第二个最大数字是数字3而不是数字9，它位于第四位。</p>
    <p class="">So let's go back to the code and see why it happened.</p>
    <p class="line_zh">那么让我们回到代码，看看它为什么会发生。</p>
    <p class="">Again, we open the file with the code.</p>
    <p class="line_zh">再次，我们用代码打开文件。</p>
    <p class="">We go to the function MaxPairwiseProductFast.</p>
    <p class="line_zh">我们转到函数MaxPairwiseProductFast。</p>
    <p class="">We ignore the code for the max_index1 and we're very interested in the code for max_index2.</p>
    <p class="line_zh">我们忽略了max_index1的代码，我们对max_index2的代码非常感兴趣。</p>
    <p class="">So now let's look at this complex if expression, where we try to determine whether a number at position j may be a new
        maximum, which is different from the maximum we've already found.</p>
    <p class="line_zh">现在让我们看看这个复杂的if表达式，我们试图确定位置j的数字是否是新的最大值，这与我们已经找到的最大值不同。</p>
    <p class="">And let's look more closely at this particular first condition.</p>
    <p class="line_zh">让我们更仔细地看一下这个特殊的第一个条件。</p>
    <p class="">So here, what we do is we check that number at position number j is different from the maximum we've already found.</p>
    <p class="line_zh">所以在这里，我们要做的是检查位置编号j处的数字是否与我们已经找到的最大数字不同。</p>
    <p class="">But that's exactly the problem.</p>
    <p class="line_zh">但这正是问题所在。</p>
    <p class="">What we need is instead, that j is different from max_index1 because we don't want to find the same number, but we can
        find number which is equal to the first found maximum.</p>
    <p class="line_zh">我们需要的是，j与max_index1不同，因为我们不想找到相同的数字，但是我们可以找到等于第一个找到的最大值的数字。</p>
    <p class="">So, instead of this comparison, what we actually need is to compare j, To max_index1.</p>
    <p class="line_zh">因此，我们实际需要的是比较j，To max_index1，而不是这种比较。</p>
    <p class="">If we fix our code this way, then we will be at least able to find the second number 9 in our input array 2 9 3 1 9,
        which we saw.</p>
    <p class="line_zh">如果我们以这种方式修复代码，那么我们至少能够在我们看到的输入数组2 9 3 1 9中找到第二个数字9。</p>
    <p class="">So let's see how it goes after we fix this.</p>
    <p class="line_zh">所以，让我们看看我们解决这个问题后的情况。</p>
    <p class="">So we save the file, we again recompile it with the same options and we launch our stress test.</p>
    <p class="line_zh">所以我们保存文件，我们再次使用相同的选项重新编译它，然后我们启动压力测试。</p>
    <p class="">So now what we see is a screen which is very quickly filling with some numbers, some words OK, and then some numbers
        again and words OK.</p>
    <p class="line_zh">所以现在我们看到的是一个快速填充一些数字的屏幕，一些单词可以，然后再一些数字和单词OK。</p>
    <p class="">And we should wait for some time, for maybe 10 seconds or even 30 seconds to be sure that we cannot find a test in which
        our solutions differ.</p>
    <p class="line_zh">我们应该等待一段时间，大概10秒甚至30秒，以确保我们找不到我们的解决方案不同的测试。</p>
    <p class="">But, by now, it seems that that is the case.</p>
    <p class="line_zh">但是，到现在为止，似乎就是这样。</p>
    <p class="">And in the next video, we will do more testing and then submit our main solution to the system and see how it goes.</p>
    <p class="line_zh">在下一个视频中，我们将进行更多测试，然后将我们的主要解决方案提交给系统，看看它是如何进行的。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 6 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_6">第07章 stress test more testing submit and pass
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">07压力测试更多测试提交和通过</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this video, we will do more testing first, and then submit our main solution to the system, and see how it goes.</p>
    <p class="line_zh">在本视频中，我们将首先进行更多测试，然后将我们的主要解决方案提交给系统，看看它是如何进行的。</p>
    <p class="">By the end, you will be fully prepared to test your programming assignments in the future.</p>
    <p class="line_zh">到最后，您将完全准备好在将来测试您的编程作业。</p>
    <p class="">For some small tests with a small n and small numbers, we cannot actually find any tests in which our solutions differ.</p>
    <p class="line_zh">对于一些小n和小数的小测试，我们实际上找不到任何我们的解决方案不同的测试。</p>
    <p class="">That doesn't yet mean that both our solutions work.</p>
    <p class="line_zh">这并不意味着我们的解决方案都有效。</p>
    <p class="">Maybe they will break for bigger values of n, or for bigger values of the input numbers.</p>
    <p class="line_zh">也许他们会为更大的n值或更大的输入数值而破坏。</p>
    <p class="">Let's check for that.</p>
    <p class="line_zh">我们来检查一下。</p>
    <p class="">So we stop our problem with a control-C.</p>
    <p class="line_zh">所以我们用control-C来解决我们的问题。</p>
    <p class="">We go into the code, again.</p>
    <p class="line_zh">我们再次进入代码。</p>
    <p class="">And, we increase back the restrictions on n, on the numbers.</p>
    <p class="line_zh">并且，我们在数字上增加了对n的限制。</p>
    <p class="">For example, n will be up to 100.</p>
    <p class="line_zh">例如，n将高达100。</p>
    <p class="">And the numbers will be up to 100,000, the maximum value permitted in the problem statement.</p>
    <p class="line_zh">这些数字最多可达100,000，即问题陈述中允许的最大值。</p>
    <p class="">We save the code, recompile, and launch the stress test again.</p>
    <p class="line_zh">我们保存代码，重新编译并再次启动压力测试。</p>
    <p class="">And now we see that, again, our screen is filling with numbers and sometimes words OK.</p>
    <p class="line_zh">现在我们再次看到，我们的屏幕上充满了数字，有时还有单词。</p>
    <p class="">But, there are many more numbers in each test, and the numbers are bigger.</p>
    <p class="line_zh">但是，每个测试中有更多的数字，而且数字更大。</p>
    <p class="">And still we're waiting and waiting and nothing happens.</p>
    <p class="line_zh">我们仍在等待和等待，没有任何反应。</p>
    <p class="">Our program just proceeds filling the screen with OKs.</p>
    <p class="line_zh">我们的程序只需用OK即可填满屏幕。</p>
    <p class="">So, maybe it works.</p>
    <p class="line_zh">所以，也许它有效。</p>
    <p class="">Or maybe we can test for even bigger values of n, because the numbers we used for testing are already big, but n is not
        that big yet.</p>
    <p class="line_zh">或者我们可以测试更大的n值，因为我们用于测试的数字已经很大，但是n还不是那么大。</p>
    <p class="">So, let's estimate what is the value of n for which we still can test.</p>
    <p class="line_zh">那么，让我们估计一下我们仍然可以测试的n值是多少。</p>
    <p class="">Our slow solution works in quadratic time.</p>
    <p class="line_zh">我们的慢速解决方案适用于二次时间。</p>
    <p class="">So, testing on 100,000 numbers would be probably too long.</p>
    <p class="line_zh">因此，测试100,000个数字可能会太长。</p>
    <p class="">So maybe we can test for a value of n up to 1,000.</p>
    <p class="line_zh">所以也许我们可以测试n值高达1,000的值。</p>
    <p class="">Let's do that, recompile, launch the stress test again.</p>
    <p class="line_zh">让我们这样做，重新编译，再次启动压力测试。</p>
    <p class="">So now our screen is almost completely filled with numbers.</p>
    <p class="line_zh">所以现在我们的屏幕几乎完全充满了数字。</p>
    <p class="">But we will know if we find a test in which our program breaks, because it will then stop.</p>
    <p class="line_zh">但是我们会知道我们是否找到了一个我们的程序中断的测试，因为它会停止。</p>
    <p class="">And as soon as it doesn't stop and proceeds filling our screen with numbers, it means that for all those tests, everything
        works correctly.</p>
    <p class="line_zh">一旦它没有停止并继续用数字填充我们的屏幕，这意味着对于所有这些测试，一切正常。</p>
    <p class="">So by now, we're pretty sure that our solution should work correctly.</p>
    <p class="line_zh">所以到现在为止，我们非常确定我们的解决方案应该正常运行。</p>
    <p class="">We stop the stress test.</p>
    <p class="line_zh">我们停止压力测试。</p>
    <p class="">And now we want to make it back a solution to the initial problem on the stress test.</p>
    <p class="line_zh">现在我们想让它回到压力测试的初始问题的解决方案。</p>
    <p class="">And to do that, we go to the main function, and we comment out the while loop, which implements the stress test.</p>
    <p class="line_zh">为此，我们转到main函数，然后注释掉while循环，它实现了压力测试。</p>
    <p class="">And now, everything else in the main loop is the solution of the initial problem.</p>
    <p class="line_zh">而现在，主循环中的其他所有内容都是初始问题的解决方案。</p>
    <p class="">So, that's it, we can probably already submit this file.</p>
    <p class="line_zh">所以，就是这样，我们可能已经提交了这个文件。</p>
    <p class="">So let's save it, and just in case, recompile it.</p>
    <p class="line_zh">所以让我们保存它，以防万一，重新编译它。</p>
    <p class="">And test it on some simple test case.</p>
    <p class="line_zh">并在一些简单的测试用例上测试它。</p>
    <p class="">For example, we input number two as the two numbers.</p>
    <p class="line_zh">例如，我们输入第二个作为两个数字。</p>
    <p class="">And then three and five as the input numbers.</p>
    <p class="line_zh">然后三和五作为输入数字。</p>
    <p class="">What we see is, instead of just number 15, on the screen, we also see some number one and zero.</p>
    <p class="line_zh">我们看到的是，屏幕上不仅仅是数字15，我们也看到了第一和零。</p>
    <p class="">What is that? Well, disregarding what is that, if we submitted this exact solution to the system, we would get an incorrect
        result on the first test we encounter in the system, because we only have to output the correct answer to the problem
        and nothing else to their output.</p>
    <p class="line_zh">那是什么？好吧，无视那是什么，如果我们将这个确切的解决方案提交给系统，我们会在系统遇到的第一个测试中得到错误的结果，因为我们只需要输出问题的正确答案而不是其他任何问题。输出。</p>
    <p class="">And that is a very frequent mistake that people do in their first programming assignment, so please beware of that.</p>
    <p class="line_zh">这是人们在第一次编程任务中经常犯的错误，所以请注意这一点。</p>
    <p class="">Please only output what is stated in the problem statement and nothing more than that, nothing less than that.</p>
    <p class="line_zh">请仅输出问题陈述中所述的内容，仅此而已。</p>
    <p class="">So in this case, we only need to output number 15.</p>
    <p class="line_zh">所以在这种情况下，我们只需要输出数字15。</p>
    <p class="">So let's fix this additional output.</p>
    <p class="line_zh">所以让我们修复这个额外的输出。</p>
    <p class="">Now we probably already guessed that this additional output is this debug output of indices, which our fast solution
        finds.
    </p>
    <p class="line_zh">现在我们可能已经猜到了这个额外的输出是索引的这个调试输出，我们的快速解决方案找到了。</p>
    <p class="">So let's comment this also out.</p>
    <p class="line_zh">所以我们也要评论一下。</p>
    <p class="">Save the file, recompile, and launch our program again.</p>
    <p class="line_zh">保存文件，重新编译，然后再次启动我们的程序。</p>
    <p class="">And then input the same test.</p>
    <p class="line_zh">然后输入相同的测试。</p>
    <p class="">Now we see that it only outputs 15, which is the correct answer.</p>
    <p class="line_zh">现在我们看到它只输出15，这是正确的答案。</p>
    <p class="">So now, we're pretty safe.</p>
    <p class="line_zh">所以现在，我们非常安全。</p>
    <p class="">We can try to submit that solution to Coursera, actually.</p>
    <p class="line_zh">我们可以尝试将该解决方案提交给Coursera。</p>
    <p class="">So, let's go and do that.</p>
    <p class="line_zh">所以，我们去做吧。</p>
    <p class="">So we create a new submission, and we upload the file, the file is stress_test.cpp.</p>
    <p class="line_zh">所以我们创建了一个新的提交，我们上传文件，文件是stress_test.cpp。</p>
    <p class="">That is the file with which we worked, right now.</p>
    <p class="line_zh">这是我们现在工作的文件。</p>
    <p class="">We wait for it to upload.</p>
    <p class="line_zh">我们等待它上传。</p>
    <p class="">And then, we submit.</p>
    <p class="line_zh">然后，我们提交。</p>
    <p class="">Now we have to wait for the grader to grade our solution.</p>
    <p class="line_zh">现在我们必须等待评分员对我们的解决方案进行评分。</p>
    <p class="">And, great, it passed in the system.</p>
    <p class="line_zh">而且，很棒，它通过了系统。</p>
    <p class="">This illustrates the stress test technique.</p>
    <p class="line_zh">这说明了压力测试技术。</p>
    <p class="">But let us give you some additional advice.</p>
    <p class="line_zh">但是，让我们给你一些额外的建议。</p>
    <p class="">First, you notice that the stress test magically gave us the test in which our main solution and alternative solution
        differed very quickly.</p>
    <p class="line_zh">首先，您注意到压力测试神奇地给了我们测试，其中我们的主要解决方案和替代解决方案非常快速地不同。</p>
    <p class="">But that's not always the case.</p>
    <p class="line_zh">但情况并非总是如此。</p>
    <p class="">For example, in this problem, max pairwise product, the only test cases on which our main and alternative solution differed
        were the test cases where the two biggest numbers are the same.</p>
    <p class="line_zh">例如，在这个问题中，最大成对产品，我们的主要和替代解决方案不同的唯一测试案例是两个最大数字相同的测试案例。</p>
    <p class="">And that's a rare event, especially when you generate big random numbers from zero to 100,000.</p>
    <p class="line_zh">这是一个罕见的事件，特别是当您生成从0到100,000的大随机数时。</p>
    <p class="">So we were actually lucky to quickly generate such a test.</p>
    <p class="line_zh">所以我们很幸运能够快速生成这样的测试。</p>
    <p class="">And that's true in the general case.</p>
    <p class="line_zh">在一般情况下这是正确的。</p>
    <p class="">Often, the cases when there are equal numbers are some kinds of corner cases.</p>
    <p class="line_zh">通常情况下，有相同数字的情况是某种角落情况。</p>
    <p class="">Also, the same happens when you are working, for example, with strings of Latin letters and, the cases where the strings
        only contain one letter, A, or only contain two different letters, for example A and B, as opposed to strings which
        can contain arbitrary Latin letters.</p>
    <p class="line_zh">此外，当您工作时也会发生同样的情况，例如，拉丁字母的字符串，以及字符串只包含一个字母，A或仅包含两个不同字母的情况，例如A和B，而不是字符串可以包含任意拉丁字母。</p>
    <p class="">Those cases with only a few different letters are sometimes corner cases.</p>
    <p class="line_zh">那些只有几个不同字母的情况有时是极端情况。</p>
    <p class="">So, when you want to do stress testing and you cannot find quickly a test on which your main solution and alternative
        solution differ, try to generate tests in a more focused subspace of full possible tests.</p>
    <p class="line_zh">因此，当您想要进行压力测试并且无法快速找到主要解决方案和替代解决方案不同的测试时，请尝试在完全可能的测试的更集中的子空间中生成测试。</p>
    <p class="">For example, if you are working with graphs, try generating a disconnected graph, a full graph, a bipartite graph.</p>
    <p class="line_zh">例如，如果您正在处理图形，请尝试生成断开连接的图形，完整图形，二分图形。</p>
    <p class="">Another important point is that if you found a test in which your solutions differ, don't hurry to debug something.</p>
    <p class="line_zh">另一个重要的一点是，如果您找到了解决方案不同的测试，请不要急于调试。</p>
    <p class="">First try to generate the smallest and easiest test on which your solutions differ.</p>
    <p class="line_zh">首先尝试生成解决方案不同的最小且最简单的测试。</p>
    <p class="">This will simplify your debugging a lot.</p>
    <p class="line_zh">这将简化您的调试。</p>
    <p class="">Don't expect stress testing to be a silver bullet.</p>
    <p class="line_zh">不要指望压力测试成为一颗银弹。</p>
    <p class="">For example, it probably won't find out that your main solution is too slow because your alternative solution will probably
        be even slower, some brute force solution.</p>
    <p class="line_zh">例如，它可能不会发现您的主要解决方案太慢，因为您的替代解决方案可能会更慢，一些暴力解决方案。</p>
    <p class="">And you will have to generate only small random tests to compare them.</p>
    <p class="line_zh">而且你必须只生成小的随机测试来比较它们。</p>
    <p class="">In other cases, integer overflow.</p>
    <p class="line_zh">在其他情况下，整数溢出。</p>
    <p class="">Even if you generate random tests with big numbers, both of your solutions could potentially have integer overflow problems.</p>
    <p class="line_zh">即使您使用大数字生成随机测试，您的两个解决方案都可能存在整数溢出问题。</p>
    <p class="">And then you will not notice that your main solution has them in the stress test.</p>
    <p class="line_zh">然后你不会注意到你的主要解决方案是在压力测试中有它们。</p>
    <p class="">So first, test for those cases, and then apply stress testing.</p>
    <p class="line_zh">首先，测试这些情况，然后应用压力测试。</p>
    <p class="">However, if you've done manual tests, integer overflow testing, and max test, and then apply stress testing, you're almost
        guaranteed to have success with it.</p>
    <p class="line_zh">但是，如果您已经完成了手动测试，整数溢出测试和最大测试，然后应用压力测试，那么您几乎可以保证取得成功。</p>
    <p class="">Because the authors of the problem do basically the same when they make the test sets for you.</p>
    <p class="line_zh">因为问题的作者在为您制作测试集时基本相同。</p>
    <p class="">They make some manual tests, they make tests with big numbers for integer flow, they make big tests for checking time
        limit, and then they generate some random tests and maybe some focused random tests.</p>
    <p class="line_zh">他们进行了一些手动测试，他们使用大数字进行整数流测试，他们为检查时间限制做了大量测试，然后他们生成一些随机测试，也许是一些集中的随机测试。</p>
    <p class="">But that's all.</p>
    <p class="line_zh">但就是这样。</p>
    <p class="">So, you will probably find all the traps they've set up for you with just testing.</p>
    <p class="line_zh">因此，您可能会通过测试找到他们为您设置的所有陷阱。</p>
    <p class="">In conclusion, know that it is very important to write programs that work on all of the allowed test cases, not just
        on most of the allowed test cases.</p>
    <p class="line_zh">总之，要知道编写适用于所有允许的测试用例的程序非常重要，而不仅仅是在大多数允许的测试用例上。</p>
    <p class="">In practice, if you write programs with bugs that only rarely reveal themselves, still some of your users will encounter
        those bugs, and their experience will deteriorate significantly.</p>
    <p class="line_zh">在实践中，如果您编写的程序中只有很少会发现自己的错误，那么您的某些用户仍然会遇到这些错误，并且他们的体验会显着恶化。</p>
    <p class="">Also, sometimes in the start of a project, you want to test some hypothesis and you write some code to check it.</p>
    <p class="line_zh">此外，有时在项目开始时，您想要测试一些假设并编写一些代码来检查它。</p>
    <p class="">Then you get some results and base your decisions on that result.</p>
    <p class="line_zh">然后，您将获得一些结果，并根据该结果做出决定。</p>
    <p class="">Only to later learn that you had a bug in the code and all your decisions were wrong.</p>
    <p class="line_zh">只是为了后来才知道你的代码中有错误，所有的决定都是错误的。</p>
    <p class="">That's why we've prepared thorough test suites to check all the aspects of your problems.</p>
    <p class="line_zh">这就是为什么我们准备了全面的测试套件来检查问题的所有方面。</p>
    <p class="">And here, stress testing will be very helpful when your solution fails on some test and you don't even know what is the
        test on which your program fails.</p>
    <p class="line_zh">在这里，当您的解决方案在某些测试中失败并且您甚至不知道您的程序失败的测试时，压力测试将非常有用。</p>
    <p class="">We hide the tests on purpose.</p>
    <p class="line_zh">我们故意隐藏测试。</p>
    <p class="">In real life, you often also won't know what are the exact conditions under which your program fails.</p>
    <p class="line_zh">在现实生活中，您通常也不会知道程序失败的确切条件。</p>
    <p class="">But now, you are fully prepared to test your programs, debug them, and fix them.</p>
    <p class="line_zh">但现在，您已准备好测试程序，调试它们并修复它们。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 7 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_7">第01章 why study algorithms
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01为什么学习算法</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello everybody.</p>
    <p class="line_zh">大家好。</p>
    <p class="">I'm Daniel Kane.</p>
    <p class="line_zh">我是丹尼尔凯恩。</p>
    <p class="">Welcome to the data structures and algorithms specialization.</p>
    <p class="line_zh">欢迎使用数据结构和算法专业化。</p>
    <p class="">For this very first lecture, we're going to start at the very beginning and talk about why do you need to study algorithms
        in the first place.</p>
    <p class="line_zh">对于这第一个讲座，我们将从一开始就开始讨论为什么你需要首先学习算法。</p>
    <p class="">So the basic goal in this lecture is to sort of talk about what are the sorts of problems that we're going to be discussing
        in this algorithms class and why they're important.</p>
    <p class="line_zh">因此，本讲座的基本目标是讨论我们将在此算法类中讨论的问题类型以及它们为何如此重要。</p>
    <p class="">And in the context of doing this, we're also going to discuss some problems that you might run into when writing computer
        programs that might not actually require sophisticated techniques that we'll be discussing in this course.</p>
    <p class="line_zh">在这样做的背景下，我们还将讨论在编写可能实际上不需要我们将在本课程中讨论的复杂技术的计算机程序时可能遇到的一些问题。</p>
    <p class="">And on the other hand, we'll discuss some other sorts of problems that you might want to solve that go beyond the sort
        of material that we will be talking about here.</p>
    <p class="line_zh">另一方面，我们将讨论您可能想要解决的其他一些问题，这些问题超出了我们将在此处讨论的那种材料。</p>
    <p class="">So, to begin with, suppose that you're writing a computer program.</p>
    <p class="line_zh">所以，首先，假设你正在编写一个计算机程序。</p>
    <p class="">There are a lot of tasks that you might want to perform that you don't really need to think about very hard.</p>
    <p class="line_zh">您可能想要执行许多任务，而您实际上并不需要非常努力地考虑这些任务。</p>
    <p class="">These are things like displaying a given text on the screen, or copying a file from one location to another, or searching
        a file for a given word.</p>
    <p class="line_zh">这些是在屏幕上显示给定文本，或将文件从一个位置复制到另一个位置，或在文件中搜索给定单词。</p>
    <p class="">Each of these algorithms has essentially a linear scan.</p>
    <p class="line_zh">这些算法中的每一个基本上都具有线性扫描。</p>
    <p class="">You go through every word in the file, one at a time and you do the appropriate thing.</p>
    <p class="line_zh">您可以浏览文件中的每个单词，一次一个，然后执行相应的操作。</p>
    <p class="">And for each of these problems there's essentially a linear scan that you really can't do much better than.</p>
    <p class="line_zh">对于这些问题中的每一个，基本上都是线性扫描，你真的不能做得更好。</p>
    <p class="">In order to do whatever task it is you're doing, you have to go through all the data one at a time and process it appropriately.</p>
    <p class="line_zh">为了完成你正在做的任何任务，你必须一次查看所有数据并适当地处理它。</p>
    <p class="">And so when you do more or less the obvious thing, you have a program that works.</p>
    <p class="line_zh">因此，当你做或多或少的显而易见的事情，你有一个有效的程序。</p>
    <p class="">It solves the problem that you need.</p>
    <p class="line_zh">它解决了您需要的问题。</p>
    <p class="">And it does so approximately as efficiently as you could expect.</p>
    <p class="line_zh">它的效果与您预期的一样高效。</p>
    <p class="">So for these sorts of problems you might not have to think very hard about what algorithm you are using.</p>
    <p class="line_zh">因此，对于这些类型的问题，您可能不必非常认真地考虑使用何种算法。</p>
    <p class="">On the other hand, there are some other problems, actual algorithms problems, where it's not so clear what it is you
        need to do.</p>
    <p class="line_zh">另一方面，还有一些其他问题，实际的算法问题，你不清楚你需要做什么。</p>
    <p class="">For example, you might be given a map and need to find the shortest path between two locations on this map.</p>
    <p class="line_zh">例如，您可能会获得一张地图，需要在此地图上找到两个位置之间的最短路径。</p>
    <p class="">Or you might be given, you might be trying to find the best pairing between students and dorm rooms given some sort of
        list of preferences, or you might be trying to measure the similarity of two different documents.</p>
    <p class="line_zh">或者您可能会给出，您可能会尝试在某些偏好列表中找到学生和宿舍之间的最佳配对，或者您可能尝试测量两个不同文档的相似性。</p>
    <p class="">Now, for these problems it's a lot more complicated, it's not immediately clear how to solve these problems.</p>
    <p class="line_zh">现在，对于这些问题，它要复杂得多，如何解决这些问题还不是很明确。</p>
    <p class="">And even when you do come up with solutions, often the simple solutions to these problems are going to be far too slow.</p>
    <p class="line_zh">即使你提出解决方案，通常这些问题的简单解决方案也会太慢。</p>
    <p class="">You could end up with some simple algorithm, you could try all possible pairings between people and dorm rooms and return
        the one that optimizes some function that you're trying to deal with.</p>
    <p class="line_zh">您最终可能会得到一些简单的算法，您可以尝试在人和宿舍之间进行所有可能的配对，并返回优化您正在尝试处理的某些功能的配对。</p>
    <p class="">On the other hand, if you did that, it would probably take a very, very, very long time.</p>
    <p class="line_zh">另一方面，如果你这样做，可能需要非常非常长的时间。</p>
    <p class="">And you might not have enough time to wait, and so you might need to do something better.</p>
    <p class="line_zh">你可能没有足够的时间等待，所以你可能需要做更好的事情。</p>
    <p class="">And then even once you have a reasonably efficient algorithm for these problems, there's often a lot of room for further
        optimization.
    </p>
    <p class="line_zh">然后，即使你有一个合理有效的算法来解决这些问题，通常还有很大的空间可以进一步优化。</p>
    <p class="">Improve things so that things run in an hour rather than a day.</p>
    <p class="line_zh">改善事物，使事物在一小时而不是一天内运行。</p>
    <p class="">Or a minute rather than an hour.</p>
    <p class="line_zh">或者一分钟而不是一小时。</p>
    <p class="">Or a second rather than a minute.</p>
    <p class="line_zh">或者一秒而不是一分钟。</p>
    <p class="">And all of these improvements will have a large effect on how useful this program you've written is.</p>
    <p class="line_zh">所有这些改进都会对您编写的这个程序的有用性产生很大影响。</p>
    <p class="">Now, on the other hand, there are some things that you might want to try and do with your computer that go a little bit
        beyond the sort of things we're discussing in this course.</p>
    <p class="line_zh">现在，另一方面，有些事情你可能想要尝试和你的计算机做的事情有点超出我们在本课程中讨论的那些事情。</p>
    <p class="">We might want to call these Artificial Intelligence Problems.</p>
    <p class="line_zh">我们可能想称这些人工智能问题。</p>
    <p class="">And these are problems where it's sort of hard to clearly state what it is that you're trying to do.</p>
    <p class="line_zh">这些都是一些问题，很难清楚地说明你要做的是什么。</p>
    <p class="">An example of this might be, to try and write a computer program to understand natural language.</p>
    <p class="line_zh">这方面的一个例子可能是尝试编写计算机程序来理解自然语言。</p>
    <p class="">That is, write a program where I can type something in, some English sentence, asking it, you know, what's the price
        of milk at the local food store today? And you want the computer to then take this sentence that I wrote, and figure
        out what it means, figure out some way to parse it.</p>
    <p class="line_zh">也就是说，写一个我可以打字的程序，一些英文句子，问一下，你知道，今天当地食品店的牛奶价格是多少？然后你希望计算机接受我写的这句话，找出它的含义，找出解析它的方法。</p>
    <p class="">And then do an appropriate lookup and return a useful answer to me.</p>
    <p class="line_zh">然后进行适当的查找并向我返回一个有用的答案。</p>
    <p class="">And the problem with doing this isn't so much that anything involved here is actually difficult to perform, but the problem
        is that fundamentally we don't really understand what it means to interpret an English sentence.</p>
    <p class="line_zh">这样做的问题并不是说这里涉及的任何事情实际上很难执行，但问题是从根本上说我们并不真正理解解释英语句子意味着什么。</p>
    <p class="">Now, I mean we can all speak English, hopefully, if you're listening to this lecture, but we don't sort of really fundamentally
        understand what it means.</p>
    <p class="line_zh">现在，我的意思是，如果你正在听这个讲座，我们都会说英语，但我们并没有真正从根本上理解它的含义。</p>
    <p class="">It's hard to put it into precise enough language that you can actually write a computer program to do that.</p>
    <p class="line_zh">很难把它放到足够精确的语言中，你实际上可以写一个计算机程序来做到这一点。</p>
    <p class="">Now you have similar problems, like if you want to identify objects in a photograph.</p>
    <p class="line_zh">现在你有类似的问题，比如你想要识别照片中的物体。</p>
    <p class="">You've got a picture, with maybe with a dog and tree and a cloud and you want the computer to identify what's what.</p>
    <p class="line_zh">你有一张照片，可能有一只狗，一棵树和一片云，你希望计算机识别出什么是什么。</p>
    <p class="">Then once again, this is a thing that our brains have gotten very good at doing, and we understand what the question
        is.
    </p>
    <p class="line_zh">然后再一次，这是我们的大脑已经做得很好的事情，我们理解问题是什么。</p>
    <p class="">However, it's hard to really put into words how you identify that this thing's a dog and this thing's a tree.</p>
    <p class="line_zh">然而，很难真正说出你是如何确定这个东西是一只狗而且这个东西是一棵树。</p>
    <p class="">And this sort of business makes it very difficult to teach a computer to do the same thing.</p>
    <p class="line_zh">而这种业务使得教电脑做同样的事情变得非常困难。</p>
    <p class="">Another thing that you might want to do is teach a computer to play games well like play chess effectively.</p>
    <p class="line_zh">您可能想要做的另一件事是教电脑玩游戏，就像下棋一样有效。</p>
    <p class="">And, once again, this is a thing where we can sort of identify what it means to do this.</p>
    <p class="line_zh">而且，再一次，我们可以确定这样做的意义。</p>
    <p class="">But, actually how you want to do it, there's a lot of sort of very vague, intuitive things that go on there.</p>
    <p class="line_zh">但是，实际上你想要怎么做，那里有很多非常模糊，直观的东西。</p>
    <p class="">It's not a clearly defined problem that you're trying to solve.</p>
    <p class="line_zh">您尝试解决的问题并不是一个明确定义的问题。</p>
    <p class="">And so, for all of these problems sort of the difficulty is not so much that it's hard to do things quickly.</p>
    <p class="line_zh">因此，对于所有这些问题而言，困难并不是因为很难快速完成任务。</p>
    <p class="">But it's hard to even state what it is that you're trying to do and figure out how to approach it.</p>
    <p class="line_zh">但是，甚至很难说出你正在尝试做什么，并弄清楚如何处理它。</p>
    <p class="">Now, these are problems that we're not going to really cover in this class, we're going to focus on algorithms, how to
        do things quickly and efficiently.</p>
    <p class="line_zh">现在，这些是我们在本课程中不会真正涵盖的问题，我们将专注于算法，如何快速有效地完成工作。</p>
    <p class="">But if you do want to get into AI and want to try and solve these problems, it will be very important that you have a
        solid grounding in algorithms, so that once you have some idea of what does it mean to identify trees in pictures,
        you will have an idea of what sort of algorithms can actually support these ideas, which sort of ideas you can actually
        implement in a reasonable amount of time.</p>
    <p class="line_zh">但是如果你想进入人工智能并希望尝试解决这些问题，那么在算法方面有一个坚实的基础是非常重要的，这样一旦你知道识别图片中的树是什么意思，你会知道什么样的算法可以真正支持这些想法，你可以在合理的时间内实际实现哪种想法。</p>
    <p class="">And so, what we're going to focus on in this course are the algorithms problems.</p>
    <p class="line_zh">因此，我们将在本课程中关注的是算法问题。</p>
    <p class="">So, we want problems that are cleanly formulated, like clear mathematical problems.</p>
    <p class="line_zh">因此，我们想要的是干净利落的问题，比如明显的数学问题。</p>
    <p class="">And some of the things we looked at maybe aren't immediately clear, like if you want to find the shortest route between
        two points on a map, that's not immediately a math problem.</p>
    <p class="line_zh">我们所看到的一些事情可能并不是很清楚，比如你想找到地图上两点之间的最短路线，这不是一个数学问题。</p>
    <p class="">But, pretty quickly you can interpret it as such.</p>
    <p class="line_zh">但是，很快你就可以解释它了。</p>
    <p class="">You can say, well, I want some sequence of intersections, I'm traveling between such that each pair is connected by a
        road, and the sum of the lengths of the roads is as small as possible.</p>
    <p class="line_zh">你可以说，嗯，我想要一些交叉序列，我在两个交叉路口之间旅行，每条路由一条道路连接，道路长度的总和尽可能小。</p>
    <p class="">And so, pretty quickly this just becomes a problem where we can very clearly state what it is that we're trying to do
        but, for which it is still nontrivial to solve it.</p>
    <p class="line_zh">所以，很快这就成了一个问题，我们可以非常清楚地说明我们正在尝试做什么，但是，解决它仍然是非常重要的。</p>
    <p class="">And so, that's the sort of thing we're going to be talking about in this class.</p>
    <p class="line_zh">所以，这就是我们将要在这堂课中谈论的那种事情。</p>
    <p class="">And, hopefully, by the end of it you will have a good idea of how to solve these problems, how to write programs that
        will solve them very quickly and very efficiently.</p>
    <p class="line_zh">而且，希望在最后，您将很好地了解如何解决这些问题，如何编写能够非常快速且高效地解决这些问题的程序。</p>
    <p class="">And that's what we'll be talking about.</p>
    <p class="line_zh">这就是我们要谈的内容。</p>
    <p class="">I hope you enjoy the rest of the class.</p>
    <p class="line_zh">我希望你喜欢上课的其余部分。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 8 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_8">第02章 coming up
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02即将到来</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello everybody, welcome back to the data structure and algorithms specialization.</p>
    <p class="line_zh">各位大家好，欢迎回到数据结构和算法专业化。</p>
    <p class="">Here I just want to give you a brief heads up, about what we're going to be talking about in the next two lectures.</p>
    <p class="line_zh">在这里，我只想简单介绍一下我们将在接下来的两个讲座中讨论的内容。</p>
    <p class="">So, in the next two lectures, we're going to dive right in.</p>
    <p class="line_zh">所以，在接下来的两个讲座中，我们将要进入​​。</p>
    <p class="">We're going to look into a couple of algorithms problems, in particular we're going to talk about algorithms for computing
        Fibonacci numbers And algorithms for computing greatest common divisors.</p>
    <p class="line_zh">我们将研究几个算法问题，特别是我们将讨论用于计算Fibonacci数的算法和用于计算最大公约数的算法。</p>
    <p class="">Now these might be, feel a little bit weird for the very first algorithms that we're going to talk to in a class.</p>
    <p class="line_zh">现在这些可能是，对于我们将在课堂上谈论的第一批算法感觉有点奇怪。</p>
    <p class="">They're kind of number theoretic and numerical, and they won't actually be that similar to what we'll be talking about
        in the rest of the class.</p>
    <p class="line_zh">它们具有数理论和数值，它们实际上并不像我们在课堂上所讨论的那样。</p>
    <p class="">So you might wonder why we're looking at them, and what you should be paying attention to.</p>
    <p class="line_zh">所以你可能想知道我们为什么要看它们，以及你应该注意什么。</p>
    <p class="">And that's really what I want to talk to you today about.</p>
    <p class="line_zh">这就是我今天想和你谈谈的内容。</p>
    <p class="">In particular, these two topics were chosen, because they were the clearest examples we could think of for why algorithms
        are critically important.</p>
    <p class="line_zh">特别是，选择了这两个主题，因为它们是我们可以想到的最清楚的例子，为什么算法至关重要。</p>
    <p class="">Why coming up with a good algorithm is really so important on so many problems.</p>
    <p class="line_zh">为什么提出一个好的算法对于这么多问题非常重要。</p>
    <p class="">And in particular, both of these problems have the following very interesting properties.</p>
    <p class="line_zh">特别是，这两个问题都具有以下非常有趣的特性。</p>
    <p class="">To begin with, both of these problems have a pretty straightforward algorithm.</p>
    <p class="line_zh">首先，这两个问题都有一个非常简单的算法。</p>
    <p class="">One where you sort of take the definition of the problem that you're trying to solve.</p>
    <p class="line_zh">您可以根据自己想要解决的问题来定义问题。</p>
    <p class="">And from that you more or less immediately extract an algorithm.</p>
    <p class="line_zh">从那以后你或多或少立即提取算法。</p>
    <p class="">You sort of take the words that you have, and you sort of interpret them as an algorithm.</p>
    <p class="line_zh">你可以用你所拥有的单词，然后将它们解释为算法。</p>
    <p class="">And more or less immediately you have some code, and it works.</p>
    <p class="line_zh">或多或少立即你有一些代码，它的工作原理。</p>
    <p class="">And it computes the things that you want it to compute.</p>
    <p class="line_zh">它计算你想要它计算的东西。</p>
    <p class="">Unfortunately, in both cases, these very straightforward algorithms are far, far too slow.</p>
    <p class="line_zh">不幸的是，在这两种情况下，这些非常直接的算法都非常慢。</p>
    <p class="">You end up with algorithms that take thousands of years to run, even on very modest inputs.</p>
    <p class="line_zh">您最终会得到运行数千年的算法，即使在非常适度的输入上也是如此。</p>
    <p class="">And this is not acceptable for practical purposes, you don't have millenia to wait for your computation to finish.</p>
    <p class="line_zh">这对于实际目的来说是不可接受的，你没有等待计算完成的千禧年。</p>
    <p class="">And so you need something better, and it turns out in both of this cases there is something better.</p>
    <p class="line_zh">所以你需要更好的东西，而且在这两种情况下都会有更好的东西。</p>
    <p class="">There is going to be a slightly more complicated algorithm, something that maybe requires one or two bright ideas to
        get it to work.</p>
    <p class="line_zh">将会有一个稍微复杂的算法，可能需要一两个明智的想法才能使它工作。</p>
    <p class="">This slightly more complicated algorithm, works fine and is actually incredibly fast.</p>
    <p class="line_zh">这个稍微复杂的算法，工作正常，实际上非常快。</p>
    <p class="">You can handle sort of any reasonable instance of these problems in the blink of an eye.</p>
    <p class="line_zh">您可以在眨眼间处理这些问题的任何合理实例。</p>
    <p class="">And so, the whole point of this is to really show with these very concrete examples, that at least in these instances,
        and in many others that we'll see throughout the course, finding the right algorithm can make all the difference
        in the world.</p>
    <p class="line_zh">因此，这一点的重点是要真实地展示这些非常具体的例子，至少在这些情况下，以及我们将在整个课程中看到的许多其他例子，找到正确的算法可以在世界上发挥重要作用。</p>
    <p class="">It's the difference between having an algorithm that takes more time than you will have in your life to finish, and an
        algorithm that is done before you even knew it started.</p>
    <p class="line_zh">这是一个算法需要花费比生命中更长的时间才能完成的算法，以及在你知道它开始之前完成的算法。</p>
    <p class="">And so really this is what you should be paying attention to.</p>
    <p class="line_zh">所以这真的是你应该注意的。</p>
    <p class="">Why it is so, so important that we find good algorithms.</p>
    <p class="line_zh">为什么它如此重要，以至于我们找到了很好的算法。</p>
    <p class="">So that's what's coming up, I hope you enjoy the next couple of lectures.</p>
    <p class="line_zh">这就是即将发生的事情，我希望你能在接下来的几场讲座中受到欢迎。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 9 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_9">第01章 problem overview
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01问题概述</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello everybody! Welcome back.</p>
    <p class="line_zh">大家好！欢迎回来。</p>
    <p class="">Today we're going to start talk about Fibonacci Numbers and algorithms to compute them.</p>
    <p class="line_zh">今天我们将开始讨论Fibonacci数字和算法来计算它们。</p>
    <p class="">In particular, in this lecture we're just going to introduce the sequence of the Fibonacci numbers and talk a little
        bit about their properties.</p>
    <p class="line_zh">特别是，在本讲座中，我们将介绍斐波纳契数的序列，并谈谈它们的属性。</p>
    <p class="">So to begin with the Fibonacci numbers is a fairly classically studied sequence of natural numbers.</p>
    <p class="line_zh">因此，从Fibonacci数开始是一个相当经典研究的自然数序列。</p>
    <p class="">The 0th element of the sequence is 0.</p>
    <p class="line_zh">序列的第0个元素是0。</p>
    <p class="">The first element is 1.</p>
    <p class="line_zh">第一个元素是1。</p>
    <p class="">And from thereon, each element is the sum of the previous two.</p>
    <p class="line_zh">从那以后，每个元素是前两个元素的总和。</p>
    <p class="">So 0 and 1 is 1.</p>
    <p class="line_zh">所以0和1是1。</p>
    <p class="">1 + 1 is 2.</p>
    <p class="line_zh">1 + 1是2。</p>
    <p class="">1 + 2 is 3.</p>
    <p class="line_zh">1 + 2是3。</p>
    <p class="">2 + 3 is 5.</p>
    <p class="line_zh">2 + 3是5。</p>
    <p class="">And the sequence continues, 8, 13, 21, 34, and so on.</p>
    <p class="line_zh">然后序列继续，8,13,21,34等。</p>
    <p class="">So it's a nice sequence of numbers defined by some pretty simple recursive rule and it's interesting for a number of
        reasons.
    </p>
    <p class="line_zh">因此，它是由一些非常简单的递归规则定义的一个很好的数字序列，并且由于许多原因它很有趣。</p>
    <p class="">It has some interesting number theoretic properties, but originally this sequence was developed by an Italian mathematician
        as a mathematical model.</p>
    <p class="line_zh">它有一些有趣的数论理论性质，但最初这个序列是由意大利数学家作为数学模型开发的。</p>
    <p class="">And it's a little bit weird.</p>
    <p class="line_zh">这有点奇怪。</p>
    <p class="">You might try and wonder what sorts of things this could be a model for.</p>
    <p class="line_zh">你可能会试着想知道这可能是什么样的东西。</p>
    <p class="">Well, it turns out that, originally, this was used as sort of a mathematical model for rabbit populations.</p>
    <p class="line_zh">嗯，事实证明，最初，这被用作兔子种群的数学模型。</p>
    <p class="">There was some idea that if you had a pair of rabbits, it would take them one generation to mature and every generation
        thereafter, they'd produce a pair of offspring.</p>
    <p class="line_zh">有一些想法，如果你有一对兔子，它将需要一代成熟，其后每一代，他们会生产一对后代。</p>
    <p class="">And if you work out what this means, then you find out the Fibonacci numbers, tell you how many pairs of rabbits you
        have after n generations.</p>
    <p class="line_zh">如果你弄清楚这意味着什么，那么你找出斐波那契数字，告诉你在n代之后你有多少只兔子。</p>
    <p class="">Now, because rabbits are known for reproducing rather quickly, you might assume that the sequence therefore grows quickly,
        and in fact it does.</p>
    <p class="line_zh">现在，因为兔子以很快的速度繁殖而闻名，你可能会认为序列因此迅速增长，事实上它确实如此。</p>
    <p class="">It's not hard to show that the nth Fibonacci number is at least 2 to the n over 2 for all n at least 6.</p>
    <p class="line_zh">对于所有n至少为6的n，并不难显示第n个斐波那契数至少为2，n超过2。</p>
    <p class="">And the proof can be made by induction.</p>
    <p class="line_zh">并且可以通过归纳进行证明。</p>
    <p class="">You prove this directly for n 6 or 7 just by computing the numbers and showing that they're big enough.</p>
    <p class="line_zh">你只需计算数字并证明它们足够大就可以直接证明这个数字是6或7。</p>
    <p class="">And after that point, Fn is the sum of Fn-1 and Fn-2.</p>
    <p class="line_zh">在此之后，Fn是Fn-1和Fn-2的总和。</p>
    <p class="">By the inductive hypothesis, you bound that below and do a little bit of arithmetic.</p>
    <p class="line_zh">通过归纳假设，你可以将其限制在下面并进行一些算术运算。</p>
    <p class="">And it's bounded below by 2 to the n/2.</p>
    <p class="line_zh">并且它在n / 2的下方以2为界。</p>
    <p class="">So that completes the proof.</p>
    <p class="line_zh">这样就完成了证明。</p>
    <p class="">In fact, with a little bit more work you can actually get a formula for the nth Fibonacci number as roughly 1 point square
        root of 5 over 2 to the n.</p>
    <p class="line_zh">实际上，通过更多的工作，您实际上可以得到第n个Fibonacci数的公式，大约1个平方根，5个，2个到n。</p>
    <p class="">These things grow exponentially quickly.</p>
    <p class="line_zh">这些事情迅速成倍增长。</p>
    <p class="">And to sort of drive that home a little bit more, we can look at some examples.</p>
    <p class="line_zh">为了更多地推动家庭，我们可以看一些例子。</p>
    <p class="">The 20th Fibonacci number is 6765.</p>
    <p class="line_zh">第20个斐波那契数是6765。</p>
    <p class="">The 50th Fibonacci number is approximately 12 billion.</p>
    <p class="line_zh">第50个斐波纳契数约为120亿。</p>
    <p class="">The 100th Fibonacci number is much, much bigger than that.</p>
    <p class="line_zh">第100个斐波那契数字远大于此数字。</p>
    <p class="">And the 500th Fibonacci number is this monster with something like a 100 digits to it.</p>
    <p class="line_zh">第500个斐波纳契数是这个怪物，有100个数字。</p>
    <p class="">So these numbers do get rather large quite quickly.</p>
    <p class="line_zh">所以这些数字确实相当快。</p>
    <p class="">So the problem that we're going to be looking into for the next couple of lectures is, how do you compute Fibonacci?
        So, if you want to use them to model rabbit populations or because of some number theoretic interest.</p>
    <p class="line_zh">因此，我们将在接下来的几个讲座中考虑的问题是，你如何计算斐波纳契？所以，如果你想用它们来模拟兔子种群或者因为一些理论上的兴趣。</p>
    <p class="">We'd like an algorithm that as input takes a non negative integer n and returns the nth Fibonacci number.</p>
    <p class="line_zh">我们想要一个算法，输入采用非负整数n并返回第n个斐波纳契数。</p>
    <p class="">And we're going to talk about how you go about doing this.</p>
    <p class="line_zh">我们将讨论你如何做到这一点。</p>
    <p class="">So, come back next lecture and we'll talk about that.</p>
    <p class="line_zh">所以，回到下一讲，我们将讨论这个问题。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 10 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_10">第02章 naive algorithm
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02天真的算法</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello everybody.</p>
    <p class="line_zh">大家好。</p>
    <p class="">Welcome back.</p>
    <p class="line_zh">欢迎回来。</p>
    <p class="">Today we'll talk a little bit more about how to compute Fibonacci numbers.</p>
    <p class="line_zh">今天我们将详细讨论如何计算斐波纳契数。</p>
    <p class="">And, in particular, today what we're going to do is we're going to show you how to produce a very simple algorithm that
        computes these things correctly.</p>
    <p class="line_zh">而且，特别是今天我们要做的是，我们将向您展示如何生成一个非常简单的算法来正确计算这些东西。</p>
    <p class="">On the other hand, we're going to show that this algorithm is actually very slow, and talk a little bit about how to
        analyze that.</p>
    <p class="line_zh">另一方面，我们将展示这个算法实际上非常慢，并谈谈如何分析它。</p>
    <p class="">So let's take a look at the definition again.</p>
    <p class="line_zh">那么让我们再看一下这个定义吧。</p>
    <p class="">The zero'th Fibonacci number is 0.</p>
    <p class="line_zh">第零个斐波纳契数是0。</p>
    <p class="">The first Fibonacci number is 1.</p>
    <p class="line_zh">第一个斐波那契数是1。</p>
    <p class="">And from there after each Fibonacci number is the sum of the previous two.</p>
    <p class="line_zh">从那里之后，每个斐波纳契数是前两个的总和。</p>
    <p class="">Now these grow pretty rapidly, and what we would like to do is have an algorithm to compute them.</p>
    <p class="line_zh">现在这些增长得非常快，我们想要做的是有一个算法来计算它们。</p>
    <p class="">So let's take a look at how we might do this.</p>
    <p class="line_zh">那么让我们来看看我们如何做到这一点。</p>
    <p class="">Well, there's a pretty easy way to go about it, given the definition.</p>
    <p class="line_zh">嗯，根据定义，有一个非常简单的方法。</p>
    <p class="">So if n is 0, we're supposed to return 0.</p>
    <p class="line_zh">因此，如果n为0，我们应该返回0。</p>
    <p class="">And if n is 1, we're supposed to return 1.</p>
    <p class="line_zh">如果n为1，我们应该返回1。</p>
    <p class="">So we could just start with a case that says if n is at most 1, we're going to return n.</p>
    <p class="line_zh">所以我们可以从一个案例开始，如果n最多为1，我们将返回n。</p>
    <p class="">Otherwise what are we supposed to do? Otherwise, we're supposed to return the sum of the n- 1, and n- 2 Fibonacci numbers.</p>
    <p class="line_zh">否则我们该怎么办？否则，我们应该返回n-1和n-2斐波那契数的总和。</p>
    <p class="">So we can just compute those two recursively, add them together, and return them.</p>
    <p class="line_zh">所以我们可以递归地计算这两个，将它们加在一起，然后返回它们。</p>
    <p class="">So, this gives us a very simple algorithm four lines long that basically took the definition of our problem and turned
        it into an algorithm that correctly computes the thing it's supposed to.</p>
    <p class="line_zh">所以，这给了我们一个非常简单的四行长算法，它基本上把我们的问题定义为一个算法，正确计算它应该的东西。</p>
    <p class="">Good for us.</p>
    <p class="line_zh">对我们好。</p>
    <p class="">We have an algorithm and it works.</p>
    <p class="line_zh">我们有一个算法，它的工作原理。</p>
    <p class="">However, in this course, we care a lot more than just, does our algorithm work? We also want to know if it's efficient,
        so we'd like to know how long this algorithm takes to run, and there's sort of a rough approximation to this.</p>
    <p class="line_zh">但是，在本课程中，我们关注的不仅仅是，我们的算法是否有效？我们也想知道它是否有效，所以我们想知道这个算法运行多长时间，并且有一个粗略的近似。</p>
    <p class="">We're going to let T(n) denote the number of lines of code that are executed by this algorithm on input n.</p>
    <p class="line_zh">我们将让T（n）表示此算法在输入n上执行的代码行数。</p>
    <p class="">So to count this is actually not very hard.</p>
    <p class="line_zh">所以算这个实际上并不是很难。</p>
    <p class="">So if n is at most one, the algorithm checks the if case, goes to the return statement, and that's two lines of code.</p>
    <p class="line_zh">因此，如果n最多为1，则算法检查if case，转到return语句，这是两行代码。</p>
    <p class="">Not so bad.</p>
    <p class="line_zh">还不错。</p>
    <p class="">If n is at least two, we go to the if case.</p>
    <p class="line_zh">如果n至少为2，我们转到if情况。</p>
    <p class="">We go to the else condition, and then run a return statement.</p>
    <p class="line_zh">我们转到else条件，然后运行return语句。</p>
    <p class="">That's three lines of code.</p>
    <p class="line_zh">这是三行代码。</p>
    <p class="">However ,in this case we also need to recursively compute the n-1, and n-2 Fibonacci numbers.</p>
    <p class="line_zh">但是，在这种情况下，我们还需要递归计算n-1和n-2 Fibonacci数。</p>
    <p class="">So we need to add to that however many lines of code those recursive calls take.</p>
    <p class="line_zh">所以我们需要添加那些递归调用的代码行。</p>
    <p class="">So all in all though, we have a nice recursive formula for T(n).</p>
    <p class="line_zh">总而言之，我们有一个很好的T（n）递归公式。</p>
    <p class="">It's two as long as n is at most one.</p>
    <p class="line_zh">只要n最多只有一个，它就是两个。</p>
    <p class="">And otherwise, it's equal to T(n) minus one plus T(n) minus two plus three.</p>
    <p class="line_zh">否则，它等于T（n）减去1加T（n）减去2加3。</p>
    <p class="">So a nice recursive formula.</p>
    <p class="line_zh">所以一个很好的递归公式。</p>
    <p class="">Now, if you look at this formula for a little bit, you'll notice that it looks very similar to the original formula that
        we used to define the Fibonacci numbers.</p>
    <p class="line_zh">现在，如果你稍微看一下这个公式，你会发现它看起来与我们用来定义Fibonacci数的原始公式非常相似。</p>
    <p class="">Each guy was more or less the sum of the previous two.</p>
    <p class="line_zh">每个人或多或少是前两个人的总和。</p>
    <p class="">And in fact, from this you can show pretty easily that T( n) is at least the n'th Fibonacci number for all n.</p>
    <p class="line_zh">事实上，你可以很容易地证明T（n）至少是所有n的第n个斐波纳契数。</p>
    <p class="">And this should be ringing some warning bells because we know that the Fibonacci numbers get very, very, very large,
        so T(n) must as well.</p>
    <p class="line_zh">这应该是一些警告铃声，因为我们知道斐波那契数字变得非常非常非常大，所以T（n）也必须如此。</p>
    <p class="">In fact, T(100) is already 1.77 times 10 to the 21.</p>
    <p class="line_zh">事实上，T（100）已经是21到10的1.77倍。</p>
    <p class="">1.77 sextillion.</p>
    <p class="line_zh">1.77 sextillion。</p>
    <p class="">This is a huge number.</p>
    <p class="line_zh">这是一个巨大的数字。</p>
    <p class="">Now, suppose we were running this program on a computer that executed a billion lines of code a second.</p>
    <p class="line_zh">现在，假设我们在一台计算机上运行这个程序，该计算机每秒执行十亿行代码。</p>
    <p class="">It ran it at a gigahertz.</p>
    <p class="line_zh">它以千兆赫兹运行。</p>
    <p class="">It would still take us about 56,000 years to complete this computation.</p>
    <p class="line_zh">完成这个计算还需要大约56,000年。</p>
    <p class="">Now, I don't have 56,000 years to wait for my computer to finish.</p>
    <p class="line_zh">现在，我没有56000年等待我的电脑完成。</p>
    <p class="">You probably don't either, so this really is somehow not acceptable, if we want to compute Fibonacci numbers of any reasonable
        size.
    </p>
    <p class="line_zh">你可能也没有，所以如果我们想要计算任何合理大小的Fibonacci数，这实际上是不可接受的。</p>
    <p class="">So what we'd really like is we'd like a better algorithm.</p>
    <p class="line_zh">所以我们真正喜欢的是我们想要一个更好的算法。</p>
    <p class="">And we'll get to that next lecture.</p>
    <p class="line_zh">我们将进入下一个讲座。</p>
    <p class="">But first we should talk a little bit about why this algorithm is so slow.</p>
    <p class="line_zh">但首先我们应该谈谈为什么这个算法如此缓慢。</p>
    <p class="">And to see that, maybe the clearest way to demonstrate it is to look at all of the recursive calls this algorithm needs
        in order to compute its answer.</p>
    <p class="line_zh">要看到这一点，也许最明确的方式是查看此算法为计算答案而需要的所有递归调用。</p>
    <p class="">So, if we want to compute the n'th Fibonacci number, we need to make recursive calls to compute the n-1,and n-2 Fibonacci
        numbers.
    </p>
    <p class="line_zh">因此，如果我们想要计算第n个Fibonacci数，我们需要进行递归调用来计算n-1和n-2 Fibonacci数。</p>
    <p class="">To compute the n-1, we need the n-2 to the n-3.</p>
    <p class="line_zh">为了计算n-1，我们需要n-2到n-3。</p>
    <p class="">To compute the n-2, we need the n-3, and n-4, and it just keeps going on and on.</p>
    <p class="line_zh">为了计算n-2，我们需要n-3和n-4，它只是继续下去。</p>
    <p class="">From there we get this big tree of recursive calls.</p>
    <p class="line_zh">从那里我们得到这个递归调用的大树。</p>
    <p class="">Now if you'll look at this tree a little bit closer, it looks like we're doing something a little bit silly.</p>
    <p class="line_zh">现在，如果你将这棵树看得更近一点，看起来我们做的事情有点傻。</p>
    <p class="">We're computing Fn-3, three separate times in this tree.</p>
    <p class="line_zh">我们正在计算Fn-3，在这棵树上分三次。</p>
    <p class="">And the way with our algorithm works, every time we're asked to compute it, since this is a new recursive call, we compute
        the whole thing from scratch.</p>
    <p class="line_zh">使用我们的算法的方式，每次我们被要求计算它，因为这是一个新的递归调用，我们从头开始计算整个事物。</p>
    <p class="">We recompute Fn-4, and Fn-5, and then, add them together and get our answer.</p>
    <p class="line_zh">我们重新计算Fn-4和Fn-5，然后将它们加在一起得到我们的答案。</p>
    <p class="">And it's this computing the same thing over and over again that's really slowing us down.</p>
    <p class="line_zh">这种计算一次又一次地反复计算，这真的让我们失望。</p>
    <p class="">And to make it even more extreme, let's blow up the tree a little bit more.</p>
    <p class="line_zh">为了让它变得更加极端，让我们把树更多地炸掉。</p>
    <p class="">Fn-4 actually gets computed these five separate times by the algorithm.</p>
    <p class="line_zh">Fn-4实际上由算法计算这五个单独的时间。</p>
    <p class="">And as you keep going down more and more and more times, are you just computing the same thing over and over again? And
        this is really the problem with this particular algorithm, but it's not clear immediately that we can do better.</p>
    <p class="line_zh">随着你越来越多地继续下去，你是不是一遍又一遍地计算同样的事情？这确实是这个特殊算法的问题，但我们不能立即做得更好。</p>
    <p class="">So, come back next lecture and we'll talk about how to get around this difficulty, and actually get a fairly efficient
        algorithm.
    </p>
    <p class="line_zh">所以，回到下一讲，我们将讨论如何解决这个难题，并实际获得一个相当有效的算法。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 11 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_11">第03章 efficient algorithm
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">03高效算法</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello, everybody, welcome back.</p>
    <p class="line_zh">各位大家好，欢迎回来。</p>
    <p class="">We're still talking about algorithms to compute Fibonacci numbers.</p>
    <p class="line_zh">我们还在谈论计算斐波纳契数的算法。</p>
    <p class="">And in this lecture, we're going to see how to actually compute them reasonably efficiently.</p>
    <p class="line_zh">在本讲座中，我们将看到如何合理有效地计算它们。</p>
    <p class="">So, as you'll recall, the Fibonacci numbers was the sequence zero, then one, then a bunch of elements, each of which
        is the sum of the previous two.</p>
    <p class="line_zh">所以，正如你记得的那样，Fibonacci数是序列零，然后是一个，然后是一堆元素，每个元素都是前两个元素的总和。</p>
    <p class="">We had a very nice algorithm for them last time, which unfortunately was very, very slow, even to compute the 100th Fibonacci
        number say.</p>
    <p class="line_zh">我们上次有一个非常好的算法，不幸的是非常非常慢，甚至计算第100个Fibonacci数字。</p>
    <p class="">So we'd like to do better.</p>
    <p class="line_zh">所以我们想做得更好。</p>
    <p class="">And maybe you need some idea for this new algorithm.</p>
    <p class="line_zh">也许你需要一些关于这个新算法的想法。</p>
    <p class="">And one way to think about it is what do you do when you compute them by hand.</p>
    <p class="line_zh">考虑它的一种方法是当你手动计算它们时你会做什么。</p>
    <p class="">And in particular, suppose we want to write down a list of all the Fibonacci numbers.</p>
    <p class="line_zh">特别是，假设我们想要写下所有斐波那契数字的列表。</p>
    <p class="">Well, there's sort of an obvious way to do this.</p>
    <p class="line_zh">嗯，有一种明显的方法可以做到这一点。</p>
    <p class="">You start off by writing zero and one because those are the first two.</p>
    <p class="line_zh">你开始写零和一，因为这是前两个。</p>
    <p class="">The next one going to be zero plus one, which is one.</p>
    <p class="line_zh">下一个将是零加1，这是一个。</p>
    <p class="">The next one is one plus one which is two, and one plus two, which is three, and two plus three, which is five.</p>
    <p class="line_zh">下一个是一加一，两个，一加二，三，二加三，即五。</p>
    <p class="">And at each step, all I need to do is look at the last two elements of the list and add them together.</p>
    <p class="line_zh">在每一步中，我需要做的就是查看列表的最后两个元素并将它们添加到一起。</p>
    <p class="">So, three and five are the last two, I add them together, and I get eight.</p>
    <p class="line_zh">所以，三个和五个是最后两个，我把它们加在一起，我得到八个。</p>
    <p class="">And, this way, since I have all of the previous numbers written down, I don't need to do these recursive calls that I
        was making in the last lecture, that were really slowing us down.</p>
    <p class="line_zh">而且，这样一来，因为我已经写下了之前的所有数字，所以我不需要在上一次讲座中进行这些递归调用，这实际上让我们放慢了速度。</p>
    <p class="">So, let's see how this algorithm works.</p>
    <p class="line_zh">那么，让我们看看这个算法是如何工作的。</p>
    <p class="">What I need to do is I need to create an array in order to store all the numbers in this list that I'm writing down.</p>
    <p class="line_zh">我需要做的是我需要创建一个数组，以便存储我正在写下的列表中的所有数字。</p>
    <p class="">The zeroth element of the array gets set to zero, the first element gets set to one, that's to set our initial conditions.</p>
    <p class="line_zh">数组的第0个元素设置为零，第一个元素设置为1，即设置初始条件。</p>
    <p class="">Then as i runs from two to n, we need to set the ith element to be the sum of the i minus first and i minus second elements.</p>
    <p class="line_zh">然后当我从2运行到n时，我们需要将第i个元素设置为i减去第一个和第i个减去第二个元素的总和。</p>
    <p class="">That correctly computes the ith Fibonacci number.</p>
    <p class="line_zh">这正确地计算了第i个斐波纳契数。</p>
    <p class="">Then, at the end of the day, once I've filled out the entire list, I'm going to return the last element after that.</p>
    <p class="line_zh">然后，在一天结束时，一旦我填写了整个列表，我将在此之后返回最后一个元素。</p>
    <p class="">So, now we can say, this is another algorithm, it should work just as well, but, how fast is it? Well, how many lines
        of code did you use? There are three lines of code at the beginning, and there's a return statement at the end, so
        that's four lines of code.</p>
    <p class="line_zh">那么，现在我们可以说，这是另一种算法，它应该也能正常工作，但是，它有多快？那么，你使用了多少行代码？开头有三行代码，最后有一个return语句，所以这是四行代码。</p>
    <p class="">Next up we have this for statement that we run through n minus one times, and each time we have to execute two lines
        of code.</p>
    <p class="line_zh">接下来我们有这个声明，我们运行n减去一次，每次我们必须执行两行代码。</p>
    <p class="">So adding everything together we find out that t of n is something like 2n plus two.</p>
    <p class="line_zh">所以将所有内容加在一起我们发现n的t是2n加2。</p>
    <p class="">So if we wanted to run this program on input n equals 100, it would take us about 202 lines of code to run it.</p>
    <p class="line_zh">因此，如果我们想在输入n等于100上运行该程序，那么运行它将需要大约202行代码。</p>
    <p class="">And 202 is actually a pretty small number even on a very modest computer these days.</p>
    <p class="line_zh">而且即使在非常适度的计算机上，202实际上也是一个非常小的数字。</p>
    <p class="">So essentially, this thing is going to be trivial to compute the 100th or the 1,000th or the 10,000th Fibonacci number
        on any reasonable computer.</p>
    <p class="line_zh">基本上，在任何合理的计算机上计算第100或第1,000或第10,000个斐波纳契数都是微不足道的。</p>
    <p class="">And this is much better than the results that we were seeing in the last lecture.</p>
    <p class="line_zh">这比我们在上一次演讲中看到的结果要好得多。</p>
    <p class="">So in summary, what we've done in this last few lectures, we've talked about the Fibonacci numbers, we've introduced
        them.
    </p>
    <p class="line_zh">总而言之，我们在最近几次讲座中所做的，我们已经谈到了Fibonacci数字，我们已经介绍了它们。</p>
    <p class="">We've come up with this naive algorithm, this very simple algorithm that goes directly from the definition, that unfortunately
        takes thousands of years, even on very small examples to finish.</p>
    <p class="line_zh">我们已经提出了这种天真的算法，这个非常简单的算法直接来自定义，不幸的是，这需要几千年，即使是非常小的例子也要完成。</p>
    <p class="">On the other hand, the algorithm we just saw is much better, it's incredibly fast even on fairly large inputs and it
        works quite well in practice.</p>
    <p class="line_zh">另一方面，我们刚刚看到的算法要好得多，即使在相当大的输入上它也非常快，并且它在实践中运行良好。</p>
    <p class="">And so, the moral of this story, the thing to really keep in mind is that in this case and in many, many others the right
        algorithm makes all the difference in the world.</p>
    <p class="line_zh">所以，这个故事的寓意，要真正记住的是，在这种情况下，在许多其他许多人中，正确的算法会在世界上产生重大影响。</p>
    <p class="">It's the difference between an algorithm that will never finish in your entire lifetime and one that finishes in the
        blink of an eye.</p>
    <p class="line_zh">这是一个永远不会在你的整个生命周期内完成的算法和一个在眨眼间完成的算法之间的区别。</p>
    <p class="">And so, that's the story with Fibonacci numbers.</p>
    <p class="line_zh">所以，这就是斐波那契数字的故事。</p>
    <p class="">Next lecture we're going to talk about a very similar story that comes with computing greatest common divisors.</p>
    <p class="line_zh">下一讲我们将讨论计算最大公约数的非常相似的故事。</p>
    <p class="">So I hope you come back for that.</p>
    <p class="line_zh">所以我希望你能回来。</p>
    <p class="">Until then, farewell.</p>
    <p class="line_zh">在那之前，告别。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 12 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_12">第01章 problem overview and naive algorithm
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01问题概述和天真算法</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello everybody.</p>
    <p class="line_zh">大家好。</p>
    <p class="">Welcome back.</p>
    <p class="line_zh">欢迎回来。</p>
    <p class="">Today, we're going to be talking about computing greatest common divisors.</p>
    <p class="line_zh">今天，我们将谈论计算最大的常见除数。</p>
    <p class="">So, in particular, what we'd like to do this lecture, is we're going to define the greatest common divisor problem.</p>
    <p class="line_zh">所以，特别是，我们想要做这个讲座的是，我们将要定义最大的常见除数问题。</p>
    <p class="">And, we're going to talk about an inefficient way to compute them.</p>
    <p class="line_zh">而且，我们将讨论一种计算它们的低效方法。</p>
    <p class="">And, next lecture we'll talk about how to do better.</p>
    <p class="line_zh">而且，下一讲我们将讨论如何做得更好。</p>
    <p class="">So, okay.</p>
    <p class="line_zh">所以，好的。</p>
    <p class="">What are GCDs? So, suppose that you have a fraction, a over b.</p>
    <p class="line_zh">什么是GCD？所以，假设你有一个分数，一个超过b。</p>
    <p class="">And, you want to put it in simplest form.</p>
    <p class="line_zh">而且，你想把它放在最简单的形式。</p>
    <p class="">Now, the standard way of doing this, is we want to divide the numerator and denominator both by some d, to get some equivalent
        fraction, a/d / b/d.</p>
    <p class="line_zh">现在，这样做的标准方法是，我们想要将分子和分母两者除以某个d，得到一些等价分数，a / d / b / d。</p>
    <p class="">Fair enough.</p>
    <p class="line_zh">很公平。</p>
    <p class="">Now, what d do we want to use for this? Well, it needs to satisfy two properties.</p>
    <p class="line_zh">现在，我们想要用什么？嗯，它需要满足两个属性。</p>
    <p class="">Firstly, d had better divide both a and b, since the new numerator and denominator are both integers.</p>
    <p class="line_zh">首先，d最好将a和b分开，因为新的分子和分母都是整数。</p>
    <p class="">But, subject to that, we would like this d to be as large as possible.</p>
    <p class="line_zh">但是，在此情况下，我们希望这个d尽可能大。</p>
    <p class="">So, that we can reduce the fraction as much as we possibly can.</p>
    <p class="line_zh">因此，我们可以尽可能地减少分数。</p>
    <p class="">So, turning this into a definition, we say that for two integers, a and b, their greatest common divisor, or GCD, is
        the largest integer d that divides both a and b.</p>
    <p class="line_zh">因此，将其转换为定义，我们说对于两个整数a和b，它们的最大公约数（或GCD）是将a和b分开的最大整数d。</p>
    <p class="">Okay, so this is a thing that you use to reduce fractions.</p>
    <p class="line_zh">好的，所以这是你用来减少分数的东西。</p>
    <p class="">However, it turns out that GCDs are a critically important concept in the field of number theory.</p>
    <p class="line_zh">然而，事实证明，GCD是数论领域中一个至关重要的概念。</p>
    <p class="">The study of prime numbers, and factorization, and things like that.</p>
    <p class="line_zh">素数，分解和类似事物的研究。</p>
    <p class="">And, because it's so important to number theory, it turns out that being able to compute GCDs is actually very important
        in cryptography.</p>
    <p class="line_zh">并且，因为它对数论非常重要，事实证明能够计算GCD实际上在密码学中非常重要。</p>
    <p class="">And, the fact that you can perform secure online banking is, in part, due to the fact that we can efficiently compute
        GCDs of numbers in order for our cryptographic algorithms to work.</p>
    <p class="line_zh">而且，您可以执行安全的在线银行业务的事实部分是由于我们可以有效地计算数字的GCD以使我们的加密算法工作。</p>
    <p class="">So, because of this importance, we're going to want to be able to compute GCDs.</p>
    <p class="line_zh">因此，由于这一重要性，我们希望能够计算GCD。</p>
    <p class="">So, we'd like an algorithm that, given two integers, a and b, at say, at least 0, we can compute the GCD of a and b.</p>
    <p class="line_zh">所以，我们想要一个算法，给定两个整数，a和b，比如说，至少为0，我们可以计算a和b的GCD。</p>
    <p class="">And, just to be clear as to what kinds of inputs we care about, we'd actually like to be able to run this on very large
        numbers.
    </p>
    <p class="line_zh">而且，为了清楚我们关心的输入类型，我们实际上希望能够在非常大的数字上运行它。</p>
    <p class="">We don't just want something that works for GCD of 5 and 12, or 11 and 73.</p>
    <p class="line_zh">我们不仅仅想要适用于GCD 5和12，或11和73的东西。</p>
    <p class="">We'd like to be able to do things like the GCD of 3,918,848 with 1,653,264.</p>
    <p class="line_zh">我们希望能够做到像GCD 3,918,848和1,653,264这样的事情。</p>
    <p class="">In fact, we'd also like to be able to compute much bigger numbers, 20, 50, 100, 1000 digits.</p>
    <p class="line_zh">事实上，我们也希望能够计算更大的数字，20,50,100,1000位数。</p>
    <p class="">We'd still like to be able to get GCDs of numbers of those sizes pretty quickly.</p>
    <p class="line_zh">我们仍然希望能够很快得到那些大小的GCD。</p>
    <p class="">Well, let's get started.</p>
    <p class="line_zh">好吧，让我们开始吧。</p>
    <p class="">Let's start by just finding an algorithm that works.</p>
    <p class="line_zh">让我们从找到一个有效的算法开始吧。</p>
    <p class="">What we'd like is the largest number that divides both a and b.</p>
    <p class="line_zh">我们想要的是将a和b分开的最大数字。</p>
    <p class="">So, one thing we can do, is we can just check all of the numbers that are candidates for this, figure out which ones
        divide a and b, and return the largest one.</p>
    <p class="line_zh">所以，我们可以做的一件事是，我们可以检查所有候选的数字，找出哪一个除以a和b，然后返回最大的一个。</p>
    <p class="">So, there's an easy implementation for this.</p>
    <p class="line_zh">所以，有一个简单的实现。</p>
    <p class="">We create a variable called best, and set it to 0.</p>
    <p class="line_zh">我们创建一个名为best的变量，并将其设置为0。</p>
    <p class="">This just remembers the biggest thing we've seen so far.</p>
    <p class="line_zh">这只是记得我们迄今为止看到的最重要的事情。</p>
    <p class="">We then let d run from 1 to a + b, since this is the range of numbers that are valid.</p>
    <p class="line_zh">然后我们让d从1运行到a + b，因为这是有效的数字范围。</p>
    <p class="">Now, if d divides a, and d divides b, well, since d is increasing, this has to be the new best that we've seen.</p>
    <p class="line_zh">现在，如果d除以a，并且d除以b，那么，因为d正在增加，这必须是我们所见过的最好的。</p>
    <p class="">So, we set best equal to d, and then, at the end the of the day, we return back the best thing we've seen.</p>
    <p class="line_zh">所以，我们设定最佳等于d，然后，在当天结束时，我们返回我们所见过的最好的东西。</p>
    <p class="">So, that's a perfectly good algorithm.</p>
    <p class="line_zh">所以，这是一个非常好的算法。</p>
    <p class="">It works.</p>
    <p class="line_zh">有用。</p>
    <p class="">Unfortunately, it's a little bit slow, because we need to run through this for loop a + b many times.</p>
    <p class="line_zh">不幸的是，它有点慢，因为我们需要多次遍历这个循环a + b。</p>
    <p class="">And, this means that, even once a and b are, say, 20 digit numbers, it's already going to be taking us at least thousands
        of years in order to run this computation.</p>
    <p class="line_zh">并且，这意味着，即使a和b是20位数字，为了运行这个计算，它已经花了我们至少几千年。</p>
    <p class="">And, so that's not sufficient for the sorts of applications that we care about.</p>
    <p class="line_zh">而且，这对我们关心的各种应用程序来说还不够。</p>
    <p class="">We're going to need a better algorithm.</p>
    <p class="line_zh">我们需要一个更好的算法。</p>
    <p class="">So, come back next lecture, and we'll talk about how to find a better algorithm for this problem, and what goes into
        that.
    </p>
    <p class="line_zh">那么，回到下一个讲座，我们将讨论如何为这个问题找到一个更好的算法，以及那个问题。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 13 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_13">第02章 efficient algorithm
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02高效算法</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello everybody, welcome back.</p>
    <p class="line_zh">各位大家好，欢迎回来。</p>
    <p class="">Today we're going to be talking a little bit more about computing greatest common divisors.</p>
    <p class="line_zh">今天我们将讨论更多关于计算最大公约数的问题。</p>
    <p class="">In particular today, we're going to be talking about a much more efficient algorithm than last time.</p>
    <p class="line_zh">特别是今天，我们将讨论比上次更有效的算法。</p>
    <p class="">This is know as the Euclidean Algorithm, we'll talk about that and we'll talk a little bit about how its runtime works.</p>
    <p class="line_zh">这被称为欧几里德算法，我们将讨论这个问题，我们将讨论它的运行时是如何工作的。</p>
    <p class="">Just to recall for integers, a and b, their greatest common divisor is the biggest integer d that divides both of them.</p>
    <p class="line_zh">只记得整数a和b，它们最大的公约数是除以它们之间的最大整数d。</p>
    <p class="">What we'd like to do is we'd like to be able to compute this, given two integers we want to compute their GCD.</p>
    <p class="line_zh">我们想要做的是，我们希望能够计算出这个，给定两个整数，我们想要计算他们的GCD。</p>
    <p class="">We found a bad algorithm for this and we'd like a better one.</p>
    <p class="line_zh">我们发现了一个糟糕的算法，我们想要一个更好的算法。</p>
    <p class="">It turns out that in order to find a better algorithm, you need to know something interesting.</p>
    <p class="line_zh">事实证明，为了找到更好的算法，你需要知道一些有趣的东西。</p>
    <p class="">There's this Key Lemma that we have, where suppose that we let a' be the remainder when a is divided by b, then the gcd(a,b)
        is actually the same as the gcd(a',b), and also the same as the gcd(b, a').</p>
    <p class="line_zh">我们有这个关键引理，假设我们让'当a除以b时为余数，则gcd（a，b）实际上与gcd（a'，b）相同，并且与gcd（b，a'）相同。</p>
    <p class="">The proof of this, once you know what to prove, is actually not very difficult.</p>
    <p class="line_zh">一旦你知道要证明什么，证明这一点实际上并不是很困难。</p>
    <p class="">The idea is that because a' is a remainder, this means a is equal to a' plus some multiple of b plus b times q, for some
        q.
    </p>
    <p class="line_zh">这个想法是因为a'是一个余数，这意味着a等于a'加上b的一些倍数加上b倍q，对于某些q。</p>
    <p class="">From that you can show that if d divides both a and b, that happens if, and only if, it divides both a' and b.</p>
    <p class="line_zh">由此可以证明，如果d除以a和b，则只有当它除以a和b时才会发生。</p>
    <p class="">Because, for example, if d divides a' and b, it divides a' plus bq, which is a.</p>
    <p class="line_zh">因为，例如，如果d除以'和b，它除了'加bq，即a。</p>
    <p class="">From this statement, we know that the common divisors of a and b are exactly the same as the common divisors of a' and
        b.
    </p>
    <p class="line_zh">从这个陈述中，我们知道a和b的公约数与a和b的公约数完全相同。</p>
    <p class="">Therefore, the greatest common divisor of a and b is the greatest common divisor of a' and b.</p>
    <p class="line_zh">因此，a和b的最大公约数是'和b的最大公约数。</p>
    <p class="">This is the idea for the algorithm.</p>
    <p class="line_zh">这是算法的想法。</p>
    <p class="">Basically, we have the gcd(a,b) is the same as the gcd(b,a'), but a' is generally smaller than a.</p>
    <p class="line_zh">基本上，我们有gcd（a，b）与gcd（b，a'）相同，但a'通常小于a。</p>
    <p class="">If we compute that new GCD recursively, hopefully that will be an easier problem.</p>
    <p class="line_zh">如果我们递归计算新的GCD，希望这将是一个更容易的问题。</p>
    <p class="">Now, we do need a base case for this, so we're going to start off by saying if b is equal to zero, everything divides
        zero, so we just need the biggest thing that divides a.</p>
    <p class="line_zh">现在，我们确实需要一个基本情况，所以我们首先要说b如果b等于零，一切都除零，所以我们只需要分割a的最大的东西。</p>
    <p class="">We're going to return a in that case.</p>
    <p class="line_zh">在这种情况下，我们将返回一个。</p>
    <p class="">Otherwise, we're going to let a' be the remainder when a is divided by b, and we're going to return the gcd(b,a'), computed
        recursively.
    </p>
    <p class="line_zh">否则，当a除以b时，我们将让'是余数，并且我们将返回gcd（b，a'），递归计算。</p>
    <p class="">By the Lemma that we just gave, if this ever returns an answer, it will always give the correct answer.</p>
    <p class="line_zh">通过我们刚刚给出的引理，如果这回复了答案，它将始终给出正确的答案。</p>
    <p class="">At the moment, we don't even know that it will necessarily terminate, much less do so in any reasonable amount of time.</p>
    <p class="line_zh">目前，我们甚至不知道它必然会终止，更不用说在任何合理的时间内这样做了。</p>
    <p class="">Let's look at an example.</p>
    <p class="line_zh">我们来看一个例子。</p>
    <p class="">Suppose that we want to compute the gcd(3918848,1653264).</p>
    <p class="line_zh">假设我们想要计算gcd（3918848,1653264）。</p>
    <p class="">So b here is not zero, we divide a by b, we get a remainder that's something like 612000, and now we have a new GCD problem
        to solve.</p>
    <p class="line_zh">所以b这里不是零，我们将a除以b，我们得到一个类似612000的余数，现在我们有一个新的GCD问题需要解决。</p>
    <p class="">Once again, b is not zero, we divide a by b, we get a new remainder of 428,000 some.</p>
    <p class="line_zh">再一次，b不是零，我们将a除以b，我们得到428,000的新余数。</p>
    <p class="">We repeat this process, gives us a remainder of 183,000 some, 61,000 some.</p>
    <p class="line_zh">我们重复这个过程，给我们剩余183,000个，一些61,000个。</p>
    <p class="">Divide again we get a remainder of zero.</p>
    <p class="line_zh">再划分我们得到零余数。</p>
    <p class="">And now b is 0, so we return the answer, 61232, and this is the right answer.</p>
    <p class="line_zh">并且n ow b为0，所以我们返回答案61232，这是正确的答案。</p>
    <p class="">You'll note though, this thing took us six steps to get to the right answer.</p>
    <p class="line_zh">你会注意到，这件事给我们带来了六个步骤来找到正确的答案。</p>
    <p class="">Whereas, if we'd used the algorithm from last time, we would've had to check something like 5 million different possible
        common divisors to find the best one.</p>
    <p class="line_zh">然而，如果我们上次使用该算法，我们将不得不检查500万个不同的可能的公约数，以找到最佳的除数。</p>
    <p class="">This it turns out is a lot better, and to get a feel of how well this thing works, or why it works well, every time we
        take one of these remainders with division, we reduce the size of the number involved by a factor of about 2.</p>
    <p class="line_zh">事实证明这样做要好得多，并且为了了解这个东西的运作情况，或者为什么它运作良好，每当我们将这些剩余部分中的一个分开时，我们会减少所涉及的数量的大小。大约2。</p>
    <p class="">And if every step were reducing things by a factor of two, after about log(ab) many steps, our numbers are now tiny or
        zero, and so, basically after log(ab) many steps, this algorithm is going to terminate.</p>
    <p class="line_zh">如果每一步都减少了两倍的事情，在大约log（ab）许多步骤之后，我们的数字现在很小或为零，因此，基本上在log（ab）许多步骤之后，该算法将终止。</p>
    <p class="">This means that, suppose that we want to compute GCDs of 100-digit numbers, this is only going to take us about 600 steps
        to do it.</p>
    <p class="line_zh">这意味着，假设我们想要计算100位数的GCD，这只需要我们大约600步就可以完成。</p>
    <p class="">Each of the steps that we've used here is a single division with remainder, 600 divisions with remainder is something
        you can do trivially, on any reasonable computer.</p>
    <p class="line_zh">我们在这里使用的每个步骤都是一个单独的除法，剩下的600个除法，余数是你可以在任何合理的计算机上做的事情。</p>
    <p class="">This algorithm will compute quite large GCDs very quickly.</p>
    <p class="line_zh">该算法将非常快速地计算相当大的GCD。</p>
    <p class="">In summary, once again, we had this computational problem.</p>
    <p class="line_zh">总之，我们再次遇到了这个计算问题。</p>
    <p class="">There was a naive algorithm, one that was very simple, came right from the definition, but it was far too slow for practical
        purposes.
    </p>
    <p class="line_zh">有一个天真的算法，一个非常简单，直接来自定义，但它实际上太慢了。</p>
    <p class="">There's a correct algorithm which is much, much better, very usable.</p>
    <p class="line_zh">有一个正确的算法，它非常好，非常好用。</p>
    <p class="">Once again, finding the right algorithm makes all the difference in the world.</p>
    <p class="line_zh">再一次，找到正确的算法会让世界变得与众不同。</p>
    <p class="">But here there was this interesting thing that we found.</p>
    <p class="line_zh">但是我们发现了这件有趣的事情。</p>
    <p class="">In order to get the correct algorithm, it required that we actually know something interesting about the problem.</p>
    <p class="line_zh">为了获得正确的算法，它要求我们真正了解有关该问题的一些有趣内容。</p>
    <p class="">We needed this Key Lemma that we saw today.</p>
    <p class="line_zh">我们需要今天看到的这个关键引理。</p>
    <p class="">This is actually a theme that you'll see throughout this course, and throughout your study of algorithms.</p>
    <p class="line_zh">这实际上是您在整个课程中以及整个算法研究中都会看到的主题。</p>
    <p class="">Very often, in order to find a better algorithm for a problem, you need to understand something interesting about the
        structure of the solution, and that will allow you to simplify things a lot.</p>
    <p class="line_zh">通常，为了找到问题的更好算法，您需要了解有关解决方案结构的一些有趣内容，这将使您能够简化很多事情。</p>
    <p class="">In any case, that's all for today, come back next lecture, we'll start talking about how to actually compute runtimes
        in a little bit more detail.</p>
    <p class="line_zh">无论如何，这就是今天的所有内容，回到下一讲，我们将开始讨论如何更详细地实际计算运行时。</p>
    <p class="">Until then good bye.</p>
    <p class="line_zh">直到那时再见。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 14 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_14">第01章 computing runtimes
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01计算运行时</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello everybody, welcome back to data structures and algorithms specialization.</p>
    <p class="line_zh">各位大家好，欢迎回到数据结构和算法专业化。</p>
    <p class="">Today, we're going to be talking about what really goes into computing runtimes and really understanding how long it
        takes a program to work.</p>
    <p class="line_zh">今天，我们将讨论计算运行时的真正原因，并真正了解程序运行需要多长时间。</p>
    <p class="">So in particular, today we're really going to dive in.</p>
    <p class="line_zh">所以特别是今天我们真的要潜入。</p>
    <p class="">Up to this point we're using this sort of rough number of lines of code executed count.</p>
    <p class="line_zh">到目前为止，我们正在使用这种粗略的代码行执行计数。</p>
    <p class="">And today we're going to talk about how accurate this is and what sorts of complications come in.</p>
    <p class="line_zh">今天我们要谈谈这是多么准确以及出现了什么样的并发症。</p>
    <p class="">And in particular we'll see that if we actually want something that's sort of fundamentally an accurate measure of runtime,
        it's going to be a huge mess.</p>
    <p class="line_zh">特别是我们会看到，如果我们真的想要一些从根本上说是运行时精确测量的东西，那将是一个巨大的混乱。</p>
    <p class="">We're going to have to bring in all sorts of extra data that aren't really convenient for us.</p>
    <p class="line_zh">我们将不得不引入各种对我们来说不太方便的额外数据。</p>
    <p class="">And so, we're really sort of talking about the problem that comes in with computing runtimes in algorithms.</p>
    <p class="line_zh">所以，我们真的在谈论算法中计算运行时所带来的问题。</p>
    <p class="">Something that we're not going to resolve really until the next lecture.</p>
    <p class="line_zh">在下一次演讲之前我们不会解决的问题。</p>
    <p class="">So to start with, let's look at this algorithm that we had for computing Fibonacci numbers.</p>
    <p class="line_zh">首先，让我们看看我们用于计算Fibonacci数的算法。</p>
    <p class="">Remember we created an array.</p>
    <p class="line_zh">记得我们创建了一个数组。</p>
    <p class="">We assigned the 0th element to 0.</p>
    <p class="line_zh">我们将第0个元素分配给0。</p>
    <p class="">The first element to 1.</p>
    <p class="line_zh">第一个元素为1。</p>
    <p class="">Then, we have this big for loop where we set the i'th element to the sum of the i minus first and i minus second elements
        and then at the end of the day we return the nth element.</p>
    <p class="line_zh">然后，我们有这个大的for循环，我们将第i个元素设置为i减去第一个和第i个减去第二个元素的总和，然后在一天结束时返回第n个元素。</p>
    <p class="">So we determined that when we ran this program we executed about 2n + 2 lines of code.</p>
    <p class="line_zh">所以我们确定当我们运行这个程序时，我们执行了大约2n + 2行代码。</p>
    <p class="">But we should really ask ourselves, is this number of lines of code executed really sort of an accurate description of
        the runtime of the algorithm? And, I mean, somehow, implicitly, this measure of lines of code assumes that, sort
        of, any two lines of code are sort of comparable to each other.</p>
    <p class="line_zh">但是我们应该真的扪心自问，这些代码行的执行是否真的能够准确描述算法的运行时间？并且，我的意思是，不知何故，隐含地，这种代码行的度量假定，任何两行代码都是相互比较的。</p>
    <p class="">They're sort of one basic operation.</p>
    <p class="line_zh">它们是一种基本操作。</p>
    <p class="">And so, let's actually look at this program in some detail and see what goes into some of these lines of code and see
        how valid this assumption is.</p>
    <p class="line_zh">所以，让我们实际看一下这个程序的一些细节，看看这些代码行中的内容是什么，看看这个假设是多么有效。</p>
    <p class="">So to start with, we create this array.</p>
    <p class="line_zh">首先，我们创建这个数组。</p>
    <p class="">And what happens when you try to initialize an array? Well, this depends a lot on your memory management system.</p>
    <p class="line_zh">当你尝试初始化一个数组时会发生什么？嗯，这很大程度上取决于你的内存管理系统。</p>
    <p class="">Fundamentally, all you have to do is find some space in memory and then get to pointer to the first location.</p>
    <p class="line_zh">从根本上说，你所要做的就是在内存中找到一些空间，然后指向第一个位置。</p>
    <p class="">On the other hand, how exactly you find this, maybe you need to shuffle some other things around to make room for it,
        maybe after you allocate the array, you then want to zero out all of the entries so that you don't have junk sitting
        in there.</p>
    <p class="line_zh">另一方面，你究竟是如何找到它的，也许你需要改变其他一些东西来为它腾出空间，也许在你分配数组之后，你想要把所有的条目归零，这样你就没有了坐在那里的垃圾。</p>
    <p class="">And so, it's not entirely clear.</p>
    <p class="line_zh">所以，它并不完全清楚。</p>
    <p class="">It depends a little bit on how exactly your program is being interpreted.</p>
    <p class="line_zh">这取决于你的程序是如何被解释的。</p>
    <p class="">But it could be pretty fast.</p>
    <p class="line_zh">但它可能非常快。</p>
    <p class="">It could actually take a while, depending on circumstances.</p>
    <p class="line_zh">实际上可能需要一段时间，具体取决于具体情况。</p>
    <p class="">Let's look at the next line.</p>
    <p class="line_zh">我们来看下一行。</p>
    <p class="">This is just a simple assignment, we set the 0 entry to 0.</p>
    <p class="line_zh">这只是一个简单的赋值，我们将0条目设置为0。</p>
    <p class="">However, if you really look at this, at the machine level, you're doing a bit more work, you need to load up the pointer
        to the 0th element to the array, you maybe then have to do some pointer arithmetic, you then need to store this literal
        0 into that spot in memory.</p>
    <p class="line_zh">但是，如果你真的看一下这个，在机器级别，你正在做更多的工作，你需要加载指向数组的第0个元素的指针，你可能然后必须做一些指针算术，然后你需要将这个文字0存储到内存中的那个位置。</p>
    <p class="">It could actually be not one operation but a few operations.</p>
    <p class="line_zh">它实际上可能不是一个操作，而是一些操作。</p>
    <p class="">Similarly when we set the first element to one, you have to do this very similar set of things.</p>
    <p class="line_zh">类似地，当我们将第一个元素设置为1时，您必须执行此类非常相似的操作。</p>
    <p class="">Next there's this for loop and with the for loop, again every time you you have to do a few things, you need to increment
        the value of i.</p>
    <p class="line_zh">接下来是for循环和for循环，每次你必须做一些事情，你需要增加i的值。</p>
    <p class="">You then need to compare i to n to see if you need to break out of the loop and if it is, you need to branch, you need
        to move to another instruction in your program after the for loop.</p>
    <p class="line_zh">然后，您需要将i与n进行比较以查看是否需要突破循环，如果是，则需要分支，您需要在for循环后移动到程序中的另一条指令。</p>
    <p class="">Next up there's this addition and here we have to do some things, we have to look up two values in the array, we have
        to write to a third value in the array.</p>
    <p class="line_zh">接下来有这个添加，在这里我们必须做一些事情，我们必须在数组中查找两个值，我们必须写入数组中的第三个值。</p>
    <p class="">All of this involves the same sort of pointer arithmetic, and memory lookups, and writes that we were talking about before,
        but we also have to do this addition.</p>
    <p class="line_zh">所有这些都涉及到我们之前讨论的相同类型的指针算法，内存查找和写入，但我们还必须进行此添加。</p>
    <p class="">And if it were just a normal addition, maybe it wouldn't be such a big deal.</p>
    <p class="line_zh">如果它只是一个正常的添加，也许它不会是一个大问题。</p>
    <p class="">However, this is addition of two Fibonacci numbers, and if you'll recall from a couple of lectures ago, we found that
        Fibonacci numbers were pretty big, in fact, so big, they probably don't fit in a single machine word.</p>
    <p class="line_zh">然而，这是两个Fibonacci数字的加法，如果您从几个讲座中回忆起来，我们发现Fibonacci数字相当大，事实上，它们很大，它们可能不适合单个机器字。</p>
    <p class="">So adding two of them together actually takes a non-trivial amount of time.</p>
    <p class="line_zh">因此，将它们中的两个加在一起实际上需要花费大量时间。</p>
    <p class="">So somehow, not only do you have to do all of these, array arithmetic things but, the actual addition of the Fibonacci
        numbers is actually a pretty non-trivial operation.</p>
    <p class="line_zh">所以不知何故，你不仅要做所有这些，数组运算的东西，而且，实际添加Fibonacci数字实际上是一个非常重要的操作。</p>
    <p class="">And then we do this return stuff where we have to do an array lookup which involves all the sorts of things we talked
        about already and then have to do a return which sort of is going to operate with the program stack and pop it up
        a level and return an answer.</p>
    <p class="line_zh">然后我们做这个返回的东西，我们必须做一个数组查找，它涉及我们已经讨论过的所有类型的东西，然后必须做一个返回，哪种类型将与程序堆栈一起运行并弹出一个级别并回答。</p>
    <p class="">So in conclusion, this program has six lines of code to it but the amount of work being done in various lines of code
        is very, very different.</p>
    <p class="line_zh">总而言之，这个程序有六行代码，但是在各行代码中完成的工作量非常非常不同。</p>
    <p class="">Exactly what goes into each line of code is not sort of at all the same thing.</p>
    <p class="line_zh">究竟是什么进入每行代码并不是完全相同的事情。</p>
    <p class="">Maybe we want to reconsider the fact that this count, that the number of lines of code, is sort of our runtime.</p>
    <p class="line_zh">也许我们想重新考虑这样一个事实，即这个计算代码行的数量是我们的运行时。</p>
    <p class="">Maybe we need to measure something else.</p>
    <p class="line_zh">也许我们需要衡量别的东西。</p>
    <p class="">So what else should we do? Well, if you want to be totally correct about what we actually care about, what you need to
        say is, well, we're going to take this program, we're going to run it on some real life computer.</p>
    <p class="line_zh">那么我们还应该做些什么呢？好吧，如果你想对我们真正关心的事情完全正确，你需要说的是，我们将采用这个程序，我们将在一些现实生活中的计算机上运行它。</p>
    <p class="">And we'd like to know how much actual time it will take for this program to finish.</p>
    <p class="line_zh">我们想知道该计划完成所需的实际时间。</p>
    <p class="">That is fundamentally what we want to know.</p>
    <p class="line_zh">这基本上就是我们想知道的。</p>
    <p class="">Unfortunately, in order to figure that out we need to know all kinds of messy details.</p>
    <p class="line_zh">不幸的是，为了弄清楚这一点，我们需要知道各种凌乱的细节。</p>
    <p class="">We need to know things like the speed of the computer that we're running it on.</p>
    <p class="line_zh">我们需要知道我们运行它的计算机的速度。</p>
    <p class="">If you run it on a big supercomputer, it'll take a lot less time than if you run it on your cell phone.</p>
    <p class="line_zh">如果你在一台大型超级计算机上运行它，它将比你在手机上运行它花费的时间少得多。</p>
    <p class="">The system architecture of the computer will matter.</p>
    <p class="line_zh">计算机的系统架构很重要。</p>
    <p class="">Exactly what operations your CPU supports and exactly how long they take relative to one another, those are all going
        to have an effect on your runtime.</p>
    <p class="line_zh">确切地说，您的CPU支持的操作以及它们相对于彼此的确切长度，这些都将对您的运行时产生影响。</p>
    <p class="">The compiler being used is also going to make a difference.</p>
    <p class="line_zh">正在使用的编译器也会产生影响。</p>
    <p class="">In practice, what you'll do is, you'll write this program in some high-level language, in C or Java or Python or something,
        and then you'll run it through a compiler to turn it into machine code.</p>
    <p class="line_zh">在实践中，你要做的是，你将用一些高级语言，用C或Java或Python等编写这个程序，然后你将通过编译器运行它以将其转换为机器代码。</p>
    <p class="">And then the compiler, though, isn't just sort of doing something completely obvious.</p>
    <p class="line_zh">然而，编译器不仅仅是做一些完全明显的事情。</p>
    <p class="">It's performing all kinds of interesting optimizations to your code.</p>
    <p class="line_zh">它正在为您的代码执行各种有趣的优化。</p>
    <p class="">And which optimizations it performs, and how they interact with exactly what you've written.</p>
    <p class="line_zh">它执行哪些优化，以及它们如何与您所编写的内容进行交互。</p>
    <p class="">That's all going to have an impact on the final runtime.</p>
    <p class="line_zh">这些都会对最终的运行时产生影响。</p>
    <p class="">Finally, you're going to care about details of the memory hierarchy.</p>
    <p class="line_zh">最后，您将关心内存层次结构的详细信息。</p>
    <p class="">If your entire computation fits into cache, it will probably run pretty quickly.</p>
    <p class="line_zh">如果您的整个计算适合缓存，它可能会很快运行。</p>
    <p class="">However, if you have to start doing lookups into RAM, things will be a lot slower.</p>
    <p class="line_zh">但是，如果你必须开始在RAM中进行查找，事情会慢得多。</p>
    <p class="">RAM lookups actually take a fair bit of time.</p>
    <p class="line_zh">RAM查找实际上需要相当长的时间。</p>
    <p class="">If, on the other hand, you run out of memory in RAM and having to start writing some of these memory operations to disk,
        things are going to go a lot slower.</p>
    <p class="line_zh">另一方面，如果RAM中的内存不足并且必须开始将一些内存操作写入磁盘，那么事情会变得更慢。</p>
    <p class="">Lookups to hard disk can take milliseconds which are forever in computer time.</p>
    <p class="line_zh">查找硬盘可能需要几毫秒，这在计算机时间是永远的。</p>
    <p class="">And so, exactly how much memory is stored in these various levels of the hierarchy, and exactly how long the lookups
        take, and how good the algorithms about to predict what things you're going to look up in the future are.</p>
    <p class="line_zh">因此，确切地说，在层次结构的各个级别中存储了多少内存，确切地说，查找需要多长时间，以及有关预测将来要查找的内容的算法有多好。</p>
    <p class="">Those are all going to affect your runtime.</p>
    <p class="line_zh">这些都会影响你的运行时。</p>
    <p class="">And so, putting it all together, we found basically a problem.</p>
    <p class="line_zh">所以，把它们放在一起，我们发现基本上是一个问题。</p>
    <p class="">Figuring out accurate runtimes is a huge mess.</p>
    <p class="line_zh">确定准确的运行时间是一个巨大的混乱。</p>
    <p class="">You need to know all of these details and you need to figure out how everything interacts.</p>
    <p class="line_zh">您需要了解所有这些细节，并且需要弄清楚一切如何相互作用。</p>
    <p class="">And we're going to be talking about a lot of algorithms in the class.</p>
    <p class="line_zh">我们将讨论课堂上的许多算法。</p>
    <p class="">And we're going to need to tell you about runtimes for all of them and we don't want to have to do this huge mess every
        single time we have a new algorithm that we want to analyze.</p>
    <p class="line_zh">而且我们需要告诉你所有这些的运行时间，并且我们不希望每次有一个我们想要分析的新算法时都要做这么大的混乱。</p>
    <p class="">And this is an issue.</p>
    <p class="line_zh">这是一个问题。</p>
    <p class="">And another issue it was just that, in practice I mean, this is all assuming that you did know these details.</p>
    <p class="line_zh">另一个问题就是，实际上我的意思是，这都假设你确实知道这些细节。</p>
    <p class="">In practice, you don't know a lot of these details, because you're writing a program, it's going to be run on somebody
        else's computer, and you've got no idea what their system architecture looks like on that computer, because you don't
        know what the computer is.</p>
    <p class="line_zh">在实践中，你不知道很多这些细节，因为你正在编写一个程序，它将在别人的计算机上运行，​​你不知道他们的系统架构在那台计算机上是什么样的，因为你不知道电脑是什么。</p>
    <p class="">You don't know who's running it.</p>
    <p class="line_zh">你不知道是谁在运行它。</p>
    <p class="">In fact, there'll be several people running it on different computers with different architectures and different speeds,
        and it'll be a mess.</p>
    <p class="line_zh">事实上，有几个人在不同的计算机上运行它，具有不同的架构和不同的速度，这将是一团糟。</p>
    <p class="">And you really don't want to compute the runtime separately for every different client.</p>
    <p class="line_zh">而且您真的不想为每个不同的客户端单独计算运行时。</p>
    <p class="">So we've got a big problem here and we're not going to solve it today but next lecture we're going to talk about how
        we get around this.</p>
    <p class="line_zh">所以我们在这里遇到了一个大问题，今天我们不打算解决它，但是接下来的讲座我们将讨论如何解决这个问题。</p>
    <p class="">And what we really want is we want a new way to measure runtime that allows us to get some reasonable answer without
        knowing these sorts of details.</p>
    <p class="line_zh">我们真正想要的是我们想要一种新的方法来测量运行时间，这样我们就可以在不知道这些细节的情况下得到一些合理的答案。</p>
    <p class="">And one of the key tricks that you should be looking at, that we'll be using to solve this problem, is we're going to
        be getting things that really give us results for very large inputs.</p>
    <p class="line_zh">你应该关注的一个关键技巧，我们将用来解决这个问题，我们将会得到真正为我们提供大量输入结果的东西。</p>
    <p class="">They tell us, not necessarily how long it actually takes in terms of real seconds, minutes, and hours, but tell us sort
        of how our runtime scales with input size.</p>
    <p class="line_zh">他们告诉我们，不一定实际需要多长时间的实际秒数，分钟数和小时数，而是告诉我们运行时如何根据输入大小进行扩展。</p>
    <p class="">And in practice this is a very important thing, because oftentimes, we really do care what happens when we have huge
        inputs, millions of data points that we need to analyze, how long does it take? And so, come back next lecture, we'll
        talk about how we resolve some of these issues, and talk about some very useful notation that we will be using throughout
        the rest of this sequence.</p>
    <p class="line_zh">在实践中，这是一件非常重要的事情，因为我们确实关心当我们有大量投入，需要分析的数百万个数据点，需要多长时间时会发生什么？因此，回到下一讲，我们将讨论如何解决其中的一些问题，并讨论一些非常有用的符号，我们将在整个序列的其余部分使用这些符号。</p>
    <p class="">So I hope you come back then, and I'll see you there.</p>
    <p class="line_zh">所以我希望你回来，我会在那里见到你。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 15 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_15">第02章 asymptotic notation
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02渐近符号</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello, everybody.</p>
    <p class="line_zh">大家好。</p>
    <p class="">Welcome back.</p>
    <p class="line_zh">欢迎回来。</p>
    <p class="">Today we're going to start talking about asymptotic notation.</p>
    <p class="line_zh">今天我们将开始谈论渐近符号。</p>
    <p class="">So here we're going to sort of just introduce this whole idea of asymptotic notation and describe some of the advantages
        of using it.</p>
    <p class="line_zh">所以这里我们将简单介绍渐近符号的整个概念，并描述使用它的一些优点。</p>
    <p class="">So last time we ran into this really interesting problem that computing runtimes is hard, in that if you really, really
        want to know how long a particular program will take to run on a particular computer, it's a huge mess.</p>
    <p class="line_zh">所以上次我们遇到这个非常有趣的问题，计算运行时很难，因为如果你真的想知道特定程序在特定计算机上运行需要多长时间，那就太乱了。</p>
    <p class="">It depends on knowing all kinds of fine details about how the program works.</p>
    <p class="line_zh">这取决于了解有关程序如何工作的各种细节。</p>
    <p class="">And all kinds of fine details about how the computer works, how fast it is, what kind of system architecture it is.</p>
    <p class="line_zh">以及有关计算机如何工作的各种精细细节，它有多快，它是什么样的系统架构。</p>
    <p class="">It's a huge mess.</p>
    <p class="line_zh">这是一个巨大的混乱。</p>
    <p class="">And we don't want to go through this huge mess every single time we try to analyze an algorithm.</p>
    <p class="line_zh">我们每次尝试分析算法时都不想经历这个巨大的混乱。</p>
    <p class="">So, we need something that's maybe a little bit less precise but much easier to work with, and we're going to talk about
        the basic idea behind that.</p>
    <p class="line_zh">因此，我们需要的东西可能稍微不那么精确但更容易使用，我们将讨论背后的基本思想。</p>
    <p class="">And the basic idea is the following.</p>
    <p class="line_zh">基本思路如下。</p>
    <p class="">That, there are lots of factors that have an effect on the final runtime but, most of them will only change the runtimes
        by a constant.</p>
    <p class="line_zh">那么，有很多因素对最终运行时有影响，但是，大多数因素只会将运行时间改为常量。</p>
    <p class="">If you're running on a computer that's a hundred times faster, it will take one-one hundreth of the time, a constant
        multiple.
    </p>
    <p class="line_zh">如果你的计算机运行速度要快一百倍，那么它将花费一到一个时间，一个恒定的倍数。</p>
    <p class="">If your system architecture has multiplications that take three times as long as additions, then if your program is heavy
        on multiplications instead of additions, it might take three times as long, but it's only a factor of three.</p>
    <p class="line_zh">如果你的系统架构的乘法是加法的三倍，那么如果你的程序在乘法而不是加法上很重，那么它可能需要三倍的长度，但它只是三倍。</p>
    <p class="">If your memory hierarchy is arranged in a different way, you might have to do disk lookups instead of RAM lookups.</p>
    <p class="line_zh">如果您的内存层次结构以不同的方式排列，则可能必须执行磁盘查找而不是RAM查找。</p>
    <p class="">And those will be a lot slower, but only by a constant multiple.</p>
    <p class="line_zh">那些会慢很多，但只有一个不变的倍数。</p>
    <p class="">So the key idea is if we come up with a measure of runtime complexity that ignores all of these constant multiples, where
        running in time n and in running in time 100 times n are sort of considered to be the same thing, then we don't have
        to worry about all of these little, bitty details that affect runtime.</p>
    <p class="line_zh">因此，关键的想法是，如果我们提出一个运行时复杂度的度量，忽略所有这些常数倍数，其中在时间n运行和在时间上运行100次n被认为是相同的事情，那么我们不要我不得不担心所有这些影响运行时的小细节。</p>
    <p class="">Of course there's a problem with this idea, if you look at it sort of by itself, that if you have runtimes of one second
        or one hour or one year, these only differ by constant multiples.</p>
    <p class="line_zh">当然，这个想法有一个问题，如果你自己看一下，如果你有一秒或一小时或一年的运行时间，这些只是不同的常数倍。</p>
    <p class="">A year is just something like 30 million seconds.</p>
    <p class="line_zh">一年就像3000万秒。</p>
    <p class="">And so, if you don't care about factors of 30 million, you can't tell the difference between a runtime of a second and
        a runtime of a year.</p>
    <p class="line_zh">因此，如果您不关心3000万的因素，您无法区分一秒运行时和一年运行时之间的区别。</p>
    <p class="">How do we get around this problem? Well, there's a sort of weird solution to this.</p>
    <p class="line_zh">我们如何解决这个问题？嗯，有一种奇怪的解决方案。</p>
    <p class="">We're not going to actually consider the runtimes of our programs on any particular input.</p>
    <p class="line_zh">我们不会真正考虑我们的程序在任何特定输入上的运行时间。</p>
    <p class="">We're going to look at what are known as asymptotic runtimes.</p>
    <p class="line_zh">我们将看看所谓的渐近运行时。</p>
    <p class="">These ask, how does the runtime scale with input size? As the input size n gets larger, does the output scale proportional
        to n, maybe proportional to n squared? Is it exponential in n? All these things are different.</p>
    <p class="line_zh">这些问，运行时如何随输入大小而缩放？随着输入尺寸n变大，输出比例是否与n成比例，可能与n平方成正比？它是指数n吗？所有这些都是不同的。</p>
    <p class="">And in fact they're sort of so different that as long as n is sufficiently large, the difference between n runtime and
        n squared runtime is going to be worse than any constant multiple.</p>
    <p class="line_zh">实际上它们有点不同，只要n足够大，n运行时和n平方运行时间之间的差异将比任何常数倍都差。</p>
    <p class="">If you've got a constant multiple of 1000, 1000n might be pretty bad with that big number in front.</p>
    <p class="line_zh">如果你有一个1000的常数倍数，1000n可能是非常糟糕的前面这个大数字。</p>
    <p class="">But, when n becomes big, it's still better than n squared.</p>
    <p class="line_zh">但是，当n变大时，它仍然优于n平方。</p>
    <p class="">And so, by sort of only caring about what happens in this sort of long scale behavior, we will be able to do this without
        seeing these constants, without having to care about these details.</p>
    <p class="line_zh">因此，通过仅关注这种长期行为中发生的事情，我们将能够在不看这些常数的情况下做到这一点，而无需关心这些细节。</p>
    <p class="">And in fact, this sort of asymptotic, large scale behavior is actually what you care about a lot of the time, because
        you really want to know: what happens when I run my program on very large inputs? And these different sorts of scalings
        do make a very large difference on that.</p>
    <p class="line_zh">事实上，这种渐近的，大规模的行为实际上是你在很多时候关心的，因为你真的想知道：当我在非常大的输入上运行程序时会发生什么？而这些不同类型的缩放确实在这方面产生了很大的不同。</p>
    <p class="">So suppose that we have an algorithm whose runtime is roughly proportional to n and we want it to run it on a machine
        that runs at about a gigahertz.</p>
    <p class="line_zh">因此，假设我们有一个算法，其运行时间大致与n成比例，我们希望它在运行大约千兆赫兹的机器上运行它。</p>
    <p class="">How large an input can we handle such that we'll finish the computation in a second? Well if it runs at about size n,
        you can handle about a billion sized inputs, before it takes more than a second.</p>
    <p class="line_zh">我们可以处理多大的输入，以便我们在一秒钟内完成计算？好吧，如果它以大约n的大小运行，你可以在需要超过一秒钟之前处理大约十亿个大小的输入。</p>
    <p class="">If instead of n, it's n log n it's a little bit slower, you can only handle inputs the size about 30 million.</p>
    <p class="line_zh">如果不是n，它是n log n它有点慢，你只能处理大约3000万的输入。</p>
    <p class="">If it runs like n squared, it's a lot worse.</p>
    <p class="line_zh">如果它像n平方一样运行，那就更糟糕了。</p>
    <p class="">You can only handle inputs of size about 30,000 before it starts taking more than a second.</p>
    <p class="line_zh">在开始花费超过一秒钟之前，您只能处理大小约为30,000的输入。</p>
    <p class="">If the inputs are of size 2 to the n, it's incredibly bad, you can only handle inputs of size about 30 in a second.</p>
    <p class="line_zh">如果输入的大小为2到n，则非常糟糕，您只能处理大小约为30秒的输入。</p>
    <p class="">Inputs of size 50 already take two weeks, inputs of size 100 you'll never ever finish.</p>
    <p class="line_zh">大小为50的输入已经需要两周，输入大小为100，你永远不会完成。</p>
    <p class="">And so the difference between n and n squared and 2 to the n is actually really, really significant.</p>
    <p class="line_zh">所以n和n之间的差值以及n与n之间的差异实际上非常非常重要。</p>
    <p class="">It's often more significant than these factors of 5 or 100 that you're seeing from other things.</p>
    <p class="line_zh">它通常比你从其他东西看到的5或100这些因素更重要。</p>
    <p class="">Now just to give you another feel of sort of how these sort of different types of runtimes behave, let's look at some
        sort of common times that you might see.</p>
    <p class="line_zh">现在只是为了让您再次了解这些不同类型的运行时的行为，让我们看一下您可能会看到的某种常见时间。</p>
    <p class="">There's log n, which is much smaller than root n, which is much smaller than n, which is much smaller than n log n, which
        is much smaller than n squared, which is much smaller than 2 to the n.</p>
    <p class="line_zh">log n比根n小得多，它远小于n，它比n log n小得多，n log n比n平方小得多，后者远小于n的n。</p>
    <p class="">So, if we graph all of these, you can see that these graphs sort of separate out from each other.</p>
    <p class="line_zh">因此，如果我们绘制所有这些图表，您可以看到这些图表彼此分开。</p>
    <p class="">If you just look at them at small inputs, it's maybe a little bit hard to tell which ones are bigger, there's a bit of
        jostling around between each other.</p>
    <p class="line_zh">如果你只是在小输入上看它们，可能有点难以分辨出哪些更大，彼此之间有一点争吵。</p>
    <p class="">But if we extend the graph outwards a bit, it becomes much more clear.</p>
    <p class="line_zh">但是如果我们将图表向外扩展一点，它就会变得更加清晰。</p>
    <p class="">2 to the n starts after about 4 really taking off.</p>
    <p class="line_zh">在大约4个真正起飞后，2到n开始。</p>
    <p class="">Really just 2 to the n just shoots up thereafter and becomes 20 or 30, it just leaves everyone else in the dust.</p>
    <p class="line_zh">真的只有2到n之后刚刚开始射击并变成20或30，它只是让其他人都处于灰尘中。</p>
    <p class="">N squared keeps up a pretty sizable advantage though against everyone else.</p>
    <p class="line_zh">N平方保持了相当大的优势，但对其他人而言。</p>
    <p class="">N log n and n also are pretty well separated from the others.</p>
    <p class="line_zh">N log n和n也很好地与其他n分开。</p>
    <p class="">In this graph, root n and log n seem to be roughly equal to each other, but if you kept extending, if you let n get larger
        and larger, they'd very quickly differentiate themselves.</p>
    <p class="line_zh">在这个图中，root n和log n看起来大致相等，但如果你继续扩展，如果你让n越来越大，他们就会很快区分自己。</p>
    <p class="">Square root of 1 million is about 1,000.</p>
    <p class="line_zh">100万的平方根约为1,000。</p>
    <p class="">Log of 1 million is about 20.</p>
    <p class="line_zh">100万的日志大约是20。</p>
    <p class="">And so really as you keep going out, very quickly the further out you go the further separated these things become from
        each other, and that's really the key idea behind sort of asymptotics.</p>
    <p class="line_zh">因此，当你继续走出去的时候，你越往前走得越远，这些东西就会彼此分开，而这正是渐近渐近的关键理念。</p>
    <p class="">We don't care so much about the constants, we care about what happens as your inputs get very large, how do they scale.</p>
    <p class="line_zh">我们不太关心常数，我们关心当您的输入变得非常大时会发生什么，它们如何扩展。</p>
    <p class="">So that's it for today.</p>
    <p class="line_zh">这就是今天的情况。</p>
    <p class="">Come back next lecture.</p>
    <p class="line_zh">回来下一讲。</p>
    <p class="">We'll talk about in sort of detail what this actually means and how to actually get it to work.</p>
    <p class="line_zh">我们将详细讨论这实际意味着什么，以及如何让它真正发挥作用。</p>
    <p class="">So until next time.</p>
    <p class="line_zh">所以直到下一次。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 16 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_16">第03章 big o notation
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">03大写法</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello, everybody.</p>
    <p class="line_zh">大家好。</p>
    <p class="">Welcome back.</p>
    <p class="line_zh">欢迎回来。</p>
    <p class="">Today, we're going to be talking about Big-O notation, which is the specific, sort of asymptotic notation that we will
        be using most frequently here.</p>
    <p class="line_zh">今天，我们将谈论Big-O符号，这是我们将在这里最常使用的特定的渐近符号。</p>
    <p class="">So, the idea here is we're going to introduce the meaning of Big-O notation and describe some of its advantages and disadvantages.</p>
    <p class="line_zh">所以，这里的想法是我们将介绍Big-O表示法的含义并描述它的一些优点和缺点。</p>
    <p class="">So to start with the definition.</p>
    <p class="line_zh">所以从定义开始。</p>
    <p class="">The idea is that we want something that cares about what happens when the inputs get very large and sort of only care
        about things up to constants.</p>
    <p class="line_zh">我们的想法是，我们想要的东西关心当输入变得非常大时会发生什么，而只关心常量的事情。</p>
    <p class="">So we are going to come up with a definition.</p>
    <p class="line_zh">所以我们将提出一个定义。</p>
    <p class="">If you've got two functions, f and g.</p>
    <p class="line_zh">如果你有两个函数，f和g。</p>
    <p class="">g(n) is Big-O of g(n).</p>
    <p class="line_zh">g（n）是g（n）的Big-O。</p>
    <p class="">If there are two constants, capital N and little c, such that for all n, at least N.</p>
    <p class="">如果有两个常数，大写N和小c，那么对于所有n，至少N.</p>
    <p class="">f(n) is at most c*g(n).</p>
    <p class="line_zh">f（n）至多为c * g（n）。</p>
    <p class="">And what this means is that at least for sufficiently large inputs, f is bounded above by some constant multiple of g.</p>
    <p class="line_zh">这意味着至少对于足够大的输入，f在g的某个常数倍上方。</p>
    <p class="">Which is really sort of this idea that we had from before.</p>
    <p class="line_zh">这是我们以前从未有过的这种想法。</p>
    <p class="">Now, for example, 3n squared plus 5n plus 2 is O of n squared, because if we take any n at at least 1, 3n squared plus
        5n plus 2 is at most 3n squared plus 5n squared plus 2n squared, which is 10n squared.</p>
    <p class="line_zh">现在，例如，3n平方加5n加2是n平方的O，因为如果我们取任何n至少为1，则3n平方加上5n加2最多3n平方加上5n平方加2n平方，这是10n平方。</p>
    <p class="">Some multiple of n squared.</p>
    <p class="line_zh">n平方的一些倍数。</p>
    <p class="">So, and in particular if you look at these two functions, they really in some sense do have the same growth rate.</p>
    <p class="line_zh">所以，特别是如果你看看这两个函数，它们在某种意义上确实具有相同的增长率。</p>
    <p class="">If you look at the ratio between them, sure it's large, its 10n equals 1, but as n gets large it actually drops down
        to about 3.</p>
    <p class="line_zh">如果你看一下它们之间的比例，确定它很大，它的10n等于1，但随着n变大，它实际上下降到大约3。</p>
    <p class="">And once you're putting in inputs, at n equals 100, n squared is a million 3n squared + 5n + 2 is a little bit more than
        3 million.</p>
    <p class="line_zh">一旦你投入输入，在n等于100，n平方是一个百万3n平方+ 5n + 2是一点点超过300万。</p>
    <p class="">So, they're not the same function.</p>
    <p class="line_zh">所以，它们不是同一个功能。</p>
    <p class="">One of them is distinctly larger than the other, but it's not larger by much, not by more than a factor of about three.</p>
    <p class="line_zh">其中一个明显大于另一个，但它并不大，而不是大约三倍。</p>
    <p class="">Throughout this course, we're going to be using big-O notation to report, basically, all of our algorithms' runtimes.</p>
    <p class="line_zh">在整个课程中，我们将使用big-O表示法来报告基本上所有算法的运行时间。</p>
    <p class="">And, this has a bunch of advantages for us.</p>
    <p class="line_zh">而且，这对我们来说有很多好处。</p>
    <p class="">The first thing that it does for us is it clarifies growth rate.</p>
    <p class="line_zh">它为我们做的第一件事是澄清增长率。</p>
    <p class="">As I've said before, often what we care about is how does our runtime scale with the input size.</p>
    <p class="line_zh">正如我之前所说，我们经常关心的是我们的运行时如何随输入大小而变化。</p>
    <p class="">And this is sort of an artifact to the fact that we often really care about what happens when we put really, really,
        really big inputs to our algorithm.</p>
    <p class="line_zh">这对于我们经常真正关心当我们为我们的算法输入真正的，非常非常大的输入时会发生什么的事实来说这是一种神器。</p>
    <p class="">How big can we deal with, before it starts breaking down? And, if you gave me some sort of complicated expression in
        terms of the input, with lots of terms, then it might be hard given two algorithms to really compare them.</p>
    <p class="line_zh">在它开始崩溃之前，我们可以处理多大的事情？并且，如果你在输入方面给我一些复杂的表达式，有很多术语，那么给定两种算法来真正比较它们可能会很困难。</p>
    <p class="">I mean, which one's bigger would depend on exactly which inputs I'm using.</p>
    <p class="line_zh">我的意思是，哪一个更大将取决于我正在使用哪些输入。</p>
    <p class="">It requires some sort of annoying computation to determine where exactly one's better than the other.</p>
    <p class="line_zh">它需要某种恼人的计算来确定哪一个比另一个好。</p>
    <p class="">But, if you look at things asymptotically what happens as n gets large? It often becomes much more clear that, once n
        is very, very large, algorithm a is better than algorithm b.</p>
    <p class="line_zh">但是，如果你渐渐看东西会随着n变大而发生什么？经常变得更清楚的是，一旦n非常非常大，算法a优于算法b。</p>
    <p class="">The second thing it does for us is that it cleans up notation.</p>
    <p class="line_zh">它为我们做的第二件事是它清理符号。</p>
    <p class="">We can write O(n²), instead of 3n² + 5n + 2.</p>
    <p class="line_zh">我们可以写O（n²），而不是3n²+ 5n + 2。</p>
    <p class="">And that's a lot cleaner and much easier to work with.</p>
    <p class="line_zh">这样更清洁，更容易使用。</p>
    <p class="">We can write O(n) instead of n + log₂(n) + sin(n).</p>
    <p class="line_zh">我们可以写O（n）而不是n +logâ，（n）+ sin（n）。</p>
    <p class="">We can write O(n log(n)) instead of 4n log₂(n) + 7.</p>
    <p class="line_zh">我们可以写O（n log（n））而不是4nlogâ，（n）+ 7。</p>
    <p class="">And note, that in the big O, we don't actually need to specify the base of the logarithm that we use.</p>
    <p class="line_zh">请注意，在大O中，我们实际上并不需要指定我们使用的对数的基数。</p>
    <p class="">Because log₂(n), and log₃(n), and log₁₀(n), and log₇(n), They only differ by constant multiples.</p>
    <p class="line_zh">因为logâ，（n）和logâ，ƒ（n）和logâ，??â€，（n）和logâ，‡（n），它们只是以常数倍数不同。</p>
    <p class="">And up to the constant multiples, this big O that we have really doesn't care.</p>
    <p class="">而且直到常数倍数，这个我们真正无关心的大O.</p>
    <p class="">Another consequence of this is that because our notation is cleaner, because we have fewer lower order terms to deal
        with, this actually makes the algebra that we have to do easier.</p>
    <p class="line_zh">这样做的另一个后果是因为我们的符号更清晰，因为我们处理的低阶项更少，这实际上使我们必须做的代数变得更容易。</p>
    <p class="">It makes it easier to manipulate big O expressions because they're not as messy.</p>
    <p class="line_zh">它使操作大O表达式变得更容易，因为它们并不那么混乱。</p>
    <p class="">And the final thing this does is that this big O notation really does solve these problems we were talking about a couple
        of lectures ago.</p>
    <p class="line_zh">这样做的最后一点是，这个大O符号确实解决了我们之前谈论过几个讲座的问题。</p>
    <p class="">In order to compute runtimes in terms of big O, we really don't need to know things like how fast the computer is, or
        what the memory hierarchy looks like, or what compiler we used, because, by and large, although these things will
        have a big impact on your final runtime, that impact will generally only be a constant multiple.</p>
    <p class="line_zh">为了用大O来计算运行时，我们真的不需要知道计算机有多快，或者内存层次结构是什么样的，或者我们使用的是什么编译器，因为总的来说，尽管这些东西将对您的最终运行时间产生重大影响，该影响通常只是一个恒定的倍数。</p>
    <p class="">And if two things are only off by a constant multiple, they've got the same big O.</p>
    <p class="">如果两件事只是以一个不变的倍数关闭，他们就会得到同样的大O.</p>
    <p class="">That's all there is.</p>
    <p class="line_zh">这就是全部。</p>
    <p class="">Now, I should say that there's a warning.</p>
    <p class="line_zh">现在，我应该说有一个警告。</p>
    <p class="">Big-O is incredibly useful, we are going to be using it for basically everything in this course, but it does lose a lot
        of information about your runtime.</p>
    <p class="line_zh">Big-O非常有用，我们将在本课程中基本上使用它，但它确实会丢失很多关于运行时的信息。</p>
    <p class="">It forgets about any constant multiples.</p>
    <p class="line_zh">它会忘记任何常数倍数。</p>
    <p class="">So, if you have two algorithms, and one of them's a hundred times faster, they have the same Big-O.</p>
    <p class="line_zh">所以，如果你有两个算法，其中一个算法快一百倍，那么它们就有相同的Big-O。</p>
    <p class="">But, in practice, if you want to make things fast, a factor of 100 is a big deal.</p>
    <p class="line_zh">但是，在实践中，如果你想让事情变得更快，那么100倍是一个大问题。</p>
    <p class="">Even a factor of two is a big deal.</p>
    <p class="line_zh">即便是两倍也是一件大事。</p>
    <p class="">And so, if you really want to make things fast, once you have a good asymptotic runtime, you then want to look into the
        nitty-gritty details.</p>
    <p class="line_zh">所以，如果你真的想让事情变得快速，那么一旦你有了一个很好的渐近运行时，你就会想要研究细节。</p>
    <p class="">Can I save a factor of two here? Can I rearrange things to make things run a little bit smoother? Can I make it interact
        better with the memory hierarchy? Can I do x, y and z to make it faster by these constant factors that we didn't
        see beforehand? The second thing that you should note along these lines is that big O is only asymptotic.</p>
    <p class="line_zh">我可以在这里节省两倍吗？我可以重新排列东西以使事情运行得更顺畅吗？我可以让它与内存层次结构更好地交互吗？我可以通过这些我们事先没有看到的常数因子来使x，y和z更快吗？你应该注意的第二件事就是大O只是渐近的。</p>
    <p class="">In some sense, all it tells you about are what happens when you put really, really, really, really, really big inputs
        into the algorithm.</p>
    <p class="line_zh">从某种意义上说，它告诉你的是当你在算法中输入真正的，真的的，真的的，非常大的输入时会发生什么。</p>
    <p class="">And,well, if you actually want to run your algorithm on a specific input.</p>
    <p class="line_zh">而且，如果您确实想要在特定输入上运行算法。</p>
    <p class="">Big O doesn't tell you anything about how long it takes in some sense.</p>
    <p class="line_zh">Big O并没有告诉你任何关于它在某种意义上需要多长时间的事情。</p>
    <p class="">I mean, usually the constants hidden by the big O are moderately small and therefore you have something useful.</p>
    <p class="line_zh">我的意思是，通常大O隐藏的常数适度小，因此你有一些有用的东西。</p>
    <p class="">But sometimes they're big.</p>
    <p class="line_zh">但有时他们很大。</p>
    <p class="">Sometimes an algorithm with worse big O runtime, that's worse asymptotically on very large inputs, actually, for all
        practical sizes, is actually beaten by some other algorithm.</p>
    <p class="line_zh">有时，对于所有实际大小而言，具有较差的大O运行时的算法，对于非常大的输入而言渐渐变差，实际上实际上被其他算法击败。</p>
    <p class="">And there are cases of this where you find two algorithms where a works better than b on really, really, really big inputs.</p>
    <p class="line_zh">在这种情况下，你会发现两种算法，在真正的，非常非常大的输入上，b比b更好。</p>
    <p class="">But sometimes really, really, really big means more than you could ever store in your computer in the first place.</p>
    <p class="line_zh">但有时真的，真的，非常大意味着比你最初存储在你的计算机中更多。</p>
    <p class="">And so, for any practical input you want to use algorithm b.</p>
    <p class="line_zh">因此，对于任何实际输入，您都希望使用算法b。</p>
    <p class="">In any case, though, despite these warnings, big O is incredibly useful.</p>
    <p class="line_zh">无论如何，尽管有这些警告，但大O非常有用。</p>
    <p class="">We're going to be using it throughout this course.</p>
    <p class="line_zh">我们将在整个课程中使用它。</p>
    <p class="">And so, next lecture, we're going to be talking a little bit about how to deal with big O expressions, how to manipulate
        them, how to use them to compute runtimes, but once you have that we'll really be sort of ready to do some algorithms.</p>
    <p class="line_zh">所以，接下来的讲座，我们将谈论如何处理大O表达式，如何操作它们，如何使用它们来计算运行时，但是一旦你有了它，我们真的会有点像准备做一些算法。</p>
    <p class="">In any case, that's all for this lecture, come back next time and we'll talk about that.</p>
    <p class="line_zh">在任何情况下，这一切都是为了这个讲座，下次回来，我们将讨论这个问题。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 17 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_17">第04章 using big o
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">04使用大o</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello everybody.</p>
    <p class="line_zh">大家好。</p>
    <p class="">Welcome back.</p>
    <p class="line_zh">欢迎回来。</p>
    <p class="">Today we're going to be talking about using Big-O notation.</p>
    <p class="line_zh">今天我们将讨论使用Big-O表示法。</p>
    <p class="">So the basic idea here, we're going to be talking about how to manipulate expressions involving Big-O and other asymptotic
        notations.
    </p>
    <p class="line_zh">所以这里的基本思想，我们将讨论如何操纵涉及Big-O和其他渐近符号的表达式。</p>
    <p class="">And, in particular, we're going to talk about how to use Big-O to compute algorithm runtimes in terms of this notation.</p>
    <p class="line_zh">特别是，我们将讨论如何使用Big-O来计算算法运行时的符号。</p>
    <p class="">So recall, we said that f(n) was Big-O of g(n).</p>
    <p class="line_zh">所以回想一下，我们说f（n）是g（n）的Big-O。</p>
    <p class="">If for all sufficiently large inputs f(n) was bounded above by some fixed constant times g(n).</p>
    <p class="line_zh">如果对于所有足够大的输入，f（n）在某个固定的常数乘以g（n）之上。</p>
    <p class="">Which really says that f is bounded above by some constant times g.</p>
    <p class="line_zh">这真的说f在某个恒定时间g上限。</p>
    <p class="">Now, we'd like to manipulate expressions, we'd like to, given expressions write them in terms of Big O in the simplest
        possible manner.</p>
    <p class="line_zh">现在，我们想操纵表达式，我们希望，表达式以最简单的方式用Big O来表达它们。</p>
    <p class="">So there's some common rules you need to know.</p>
    <p class="line_zh">所以你需要知道一些共同的规则。</p>
    <p class="">The first rule is that multiplicative constants can be omitted.</p>
    <p class="line_zh">第一条规则是可以省略乘法常数。</p>
    <p class="">7n cubed is O of n cubed.</p>
    <p class="">7n立方是n立方的O.</p>
    <p class="">n squared over 3 is O of n squared.</p>
    <p class="">n平方超过3是n平方的O.</p>
    <p class="">The basic premise that we had when building this idea was that we wanted to have something that ignores multiplicative
        constants.
    </p>
    <p class="line_zh">我们在构建这个想法时所拥有的基本前提是我们想要有一些忽略乘法常数的东西。</p>
    <p class="">The second thing to note is that you have two powers of n.</p>
    <p class="line_zh">要注意的第二点是你有两个n的幂。</p>
    <p class="">The one with the larger exponent grows faster, so n grows asymptotically slower than Big-O of n squared.</p>
    <p class="line_zh">具有较大指数的指数增长得更快，因此n渐近渐远地慢于n平方的Big-O。</p>
    <p class="">Root n grows slower than n, so it's O of n.</p>
    <p class="">根n比n慢，所以它是n的O.</p>
    <p class="">Hopefully this isn't too bad.</p>
    <p class="line_zh">希望这不是太糟糕。</p>
    <p class="">What's more surprising is that if you have any polynomial and any exponential, the exponential always grows faster.</p>
    <p class="line_zh">更令人惊讶的是，如果你有任何多项式和任何指数，指数总是增长得更快。</p>
    <p class="">So n to the fifth is O of root two to the n.</p>
    <p class="">所以n到第五个是n的根2的O.</p>
    <p class="">n to the 100 is O of 1.1 to the n.</p>
    <p class="">n到100是n到1.1的O.</p>
    <p class="">And this latter thing is something that should surprise you a little bit.</p>
    <p class="line_zh">而后一种事情应该会让你感到惊讶。</p>
    <p class="">Because n to the 100 is a terrible runtime.</p>
    <p class="line_zh">因为n到100是一个可怕的运行时。</p>
    <p class="">Two to the 100 is already so big that you really can't expect to do it ever.</p>
    <p class="line_zh">两个到100已经是如此之大，你真的不能指望做到这一点。</p>
    <p class="">On the other hand, 1.1 to the n grows pretty modestly.</p>
    <p class="line_zh">另一方面，1.1到n的增长非常适度。</p>
    <p class="">1.1 to the 100 is a pretty reasonable-sized number.</p>
    <p class="line_zh">1.1到100是一个非常合理的数字。</p>
    <p class="">On the other hand, what this really says, is that once n gets large, maybe 100 thousand or so, 1.1 eventually takes over,
        and starts beating n to the 100.</p>
    <p class="line_zh">另一方面，真正说的是，一旦n变大，可能是10万左右，1.1最终接管，并开始击败n到100。</p>
    <p class="">And it does so by, in fact, quite a bit.</p>
    <p class="line_zh">事实上，它确实是这样做的。</p>
    <p class="">But it doesn't really happen until n gets pretty huge.</p>
    <p class="line_zh">但是直到n变得非常巨大才真正发生。</p>
    <p class="">In a similar vein, any power of log n grows slower than any power of n.</p>
    <p class="line_zh">类似地，log n的任何幂都比n的任何幂都慢。</p>
    <p class="">So log n cubed is O of root n.</p>
    <p class="">因此log n cubed是根n的O.</p>
    <p class="">n log n is O of n squared.</p>
    <p class="">n log n是n平方的O.</p>
    <p class="">Finally, if you have some sum of terms smaller terms in the sum can be omitted.</p>
    <p class="line_zh">最后，如果你有一些术语的总和较小的术语可以省略。</p>
    <p class="">So n squared plus n.</p>
    <p class="line_zh">所以n平方加n。</p>
    <p class="">n has a smaller rate of growth.</p>
    <p class="line_zh">n的增长率较小。</p>
    <p class="">So this is O of n squared.</p>
    <p class="">所以这是n平方的O.</p>
    <p class="">2 to the n + n to the 9th.</p>
    <p class="line_zh">2到n + n到9。</p>
    <p class="">n to the 9th has a smaller rate of growth, so this is O(2 to the n).</p>
    <p class="line_zh">n到9日的增长率较小，因此这是O（2到n）。</p>
    <p class="">So, these are common rules for manipulating these expressions.</p>
    <p class="line_zh">因此，这些是操纵这些表达式的常用规则。</p>
    <p class="">Basically these are the only ones that you'll need most of the time to write anything in terms of Big-O that you need.</p>
    <p class="line_zh">基本上这些是你大部分时间都需要根据你需要的Big-O编写任何内容的。</p>
    <p class="">Okay, so let's see how this works in practice.</p>
    <p class="line_zh">好的，让我们看看它在实践中是如何运作的。</p>
    <p class="">If we actually want to compute runtimes using Big-O notation.</p>
    <p class="line_zh">如果我们真的想使用Big-O表示法计算运行时。</p>
    <p class="">So let's look at this one algorithm again.</p>
    <p class="line_zh">那么让我们再看一下这个算法吧。</p>
    <p class="">So we created an array.</p>
    <p class="line_zh">所以我们创建了一个数组。</p>
    <p class="">We set the 0th element to 0 and the first element to 1.</p>
    <p class="line_zh">我们将第0个元素设置为0，将第一个元素设置为1。</p>
    <p class="">We then went through this loop, where we set each element to the sum of the previous two.</p>
    <p class="line_zh">然后我们经历了这个循环，我们将每个元素设置为前两个元素的总和。</p>
    <p class="">And then returned the last element of the array.</p>
    <p class="line_zh">然后返回数组的最后一个元素。</p>
    <p class="">Let's try computing this runtime in terms of Big-O notation.</p>
    <p class="line_zh">让我们尝试用Big-O表示法计算这个运行时。</p>
    <p class="">So, we're just going to run through it operation by operation and ask how long it takes.</p>
    <p class="line_zh">因此，我们只是按操作运行它并询问需要多长时间。</p>
    <p class="">First operation is we created an array, and let's for the moment ignore the memory management issues, assume that it's
        not too hard to allocate the memory.</p>
    <p class="line_zh">第一个操作是我们创建了一个数组，让我们暂时忽略内存管理问题，假设分配内存并不太难。</p>
    <p class="">But let;s suppose that what your compiler does is we actually want to zero out all of these cells in memory and that's
        going to take us a little bit of work.</p>
    <p class="line_zh">但是，让我们假设您的编译器所做的是我们实际上想要将所有这些单元归零，这将会带给我们一些工作。</p>
    <p class="">Because for every cell, basically what we have to do, is we need to zero out that cell, we then need to increment some
        counter to tell us which cell we're working on next and then maybe we need to do a check to make sure that we're
        not at the end.</p>
    <p class="line_zh">因为对于每个单元格，基本上我们必须要做的是，我们需要将该单元格清零，然后我们需要增加一些计数器来告诉我们接下来要处理哪个单元格，然后我们可能需要进行检查确定我们不在最后。</p>
    <p class="">If we are at the end, to go to the next line.</p>
    <p class="line_zh">如果我们在最后，去下一行。</p>
    <p class="">Now for every cell we have to do some amount of work.</p>
    <p class="line_zh">现在，对于每个细胞，我们都要做一些工作。</p>
    <p class="">We have to do something like do a write, and the comparison, and an increment.</p>
    <p class="line_zh">我们必须做一些事情，比如写，比较和增量。</p>
    <p class="">And it's not entirely clear how many machine operations this is.</p>
    <p class="line_zh">并不完全清楚这是多少机器操作。</p>
    <p class="">But it's a constant amount of work per cell in the array.</p>
    <p class="line_zh">但是阵列中每个单元的工作量是恒定的。</p>
    <p class="">If there are n plus 1 cells.</p>
    <p class="line_zh">如果有n加1个单元格。</p>
    <p class="">This is O of n time, some constant times n.</p>
    <p class="line_zh">这是n次的O，一些常数n。</p>
    <p class="">Next we set the zeroth elements of the array of zero.</p>
    <p class="line_zh">接下来，我们将数组的第0个元素设置为零。</p>
    <p class="">And this might just be a simple assignment.</p>
    <p class="line_zh">这可能只是一个简单的任务。</p>
    <p class="">We might have to load a few things into registers or do some pointer arithmetic, but no matter whether this is one machine
        operation or five or seven, that's still going to be a constant number of machine operations, O(1).</p>
    <p class="line_zh">我们可能不得不在寄存器中加载一些东西或做一些指针算术，但不管这是一个机器操作还是五个或七个，那仍然是一个恒定数量的机器操作，O（1）。</p>
    <p class="">Similar is setting the first element to one again, O(1) time.</p>
    <p class="line_zh">类似的是将第一个元素再次设置为一个O（1）时间。</p>
    <p class="">Next we run through this loop, for i running from two to n, we run through it n minus one times, that's O(n) times.</p>
    <p class="line_zh">接下来我们运行这个循环，因为我从2运行到n，我们通过它减去一次，这是O（n）次。</p>
    <p class="">The main thing we do in the loop is we set the ith element of the array to the sum of the i minus first and i minus second.</p>
    <p class="line_zh">我们在循环中做的主要事情是我们将数组的第i个元素设置为i减去第一个和第i个减去第二个的总和。</p>
    <p class="">Now the lookups and the store, those are all of the sorts of things we had looked at, those should be O of 1.</p>
    <p class="line_zh">现在查找和商店，这些是我们所看到的所有类型的东西，那些应该是O的1。</p>
    <p class="">But the addition is a bit worse.</p>
    <p class="line_zh">但增加的情况有点糟糕。</p>
    <p class="">And normally additions are constant time.</p>
    <p class="line_zh">通常添加是恒定时间。</p>
    <p class="">But these are large numbers.</p>
    <p class="line_zh">但这些都很多。</p>
    <p class="">Remember, the nth Fibonacci number has about n over 5 digits to it, they're very big, and they often won't fit in the
        machine word.</p>
    <p class="line_zh">请记住，第n个Fibonacci数字大约有n个超过5位数，它们非常大，而且它们通常不适合机器字。</p>
    <p class="">Now if you think about what happens if you add two very big numbers together, how long does that take? Well, you sort
        of add the tens digit and you carry, and you add the hundreds digit and you carry, and add the thousands digit, you
        carry and so on and so forth.</p>
    <p class="line_zh">现在，如果您考虑如果将两个非常大的数字加在一起会发生什么，那需要多长时间？好吧，你可以添加几十个数字并随身携带，然后添加数百个数字并随身携带，并添加数千个数字，随身携带，等等。</p>
    <p class="">And you sort of have to do work for each digits place.</p>
    <p class="line_zh">而你必须为每个数字位置做工作。</p>
    <p class="">And so the amount of work that you do should be proportional to the number of digits.</p>
    <p class="line_zh">因此，您所做的工作量应与数字位数成比例。</p>
    <p class="">And in this case, the number of digits is proportional to n, so this should take O(n) time to run that line of code.</p>
    <p class="line_zh">在这种情况下，位数与n成比例，因此这需要花费O（n）时间来运行该行代码。</p>
    <p class="">Finally, we have a return step, which is a pointer arithmetic and array lookup and maybe popping up the program stack.</p>
    <p class="line_zh">最后，我们有一个返回步骤，它是一个指针算术和数组查找，可能会弹出程序堆栈。</p>
    <p class="">And it's not quite clear how much work that is, but it's pretty clear that it's a constant amount of work, it doesn't
        become worse as n gets larger.</p>
    <p class="line_zh">而且目前还不是很清楚它的工作量是多少，但很明显它是一个不变的工作量，随着n变大，它不会变得更糟。</p>
    <p class="">So, that's O of one time.</p>
    <p class="">所以，那是一次性的O.</p>
    <p class="">So, now we just have to add this all together.</p>
    <p class="line_zh">所以，现在我们只需要将它们全部加在一起。</p>
    <p class="">O of N plus O of 1 plus O of 1 plus O of N times through the loop times O of N times work per time through the loop plus
        O of 1, add it all together, the dominant term here, which is the only one we need, is the O of n times O of n.</p>
    <p class="">N加O的O加1加O加1次O加O次循环次数N次每次通过循环加O加1，将它们加在一起，这里占主导地位，这是唯一的一个我们需要的是n次n的O.</p>
    <p class="">That's O of n squared.</p>
    <p class="">这是n平方的O.</p>
    <p class="">So this algorithm runs in time O of n squared.</p>
    <p class="line_zh">因此该算法在n平方的时间O内运行。</p>
    <p class="">Now, we don't know exactly what the constants are, but O of n squared means that if we want to finish this in a second,
        you can probably handle inputs of size maybe 30,000.</p>
    <p class="line_zh">现在，我们并不确切知道常量是什么，但是n平方的O意味着如果我们想在一秒内完成这个，你可以处理大小可能为30,000的输入。</p>
    <p class="">Now, depending on the computer that you had and the compiler and all of these messy details, maybe you can only handle
        inputs of size 1,000 in a second.</p>
    <p class="line_zh">现在，根据您拥有的计算机和编译器以及所有这些混乱的细节，您可能只能处理大小为1,000的输入。</p>
    <p class="">Maybe you can handle inputs the size of million in a second.</p>
    <p class="line_zh">也许你可以在一秒钟内处理数百万的输入。</p>
    <p class="">It's probably not going to be as low as ten or as high as a billion but, I mean, 30,000's a good guess and well, it takes
        work to get anything better than that.</p>
    <p class="line_zh">它可能不会低至10或高达10亿，但是，我的意思是，30,000是一个很好的猜测，而且，需要工作才能获得更好的东西。</p>
    <p class="">And so, this doesn't give us an exact answer but it's pretty good.</p>
    <p class="line_zh">所以，这并没有给我们一个确切的答案，但它非常好。</p>
    <p class="">Okay, so that's how you use Big-O notation.</p>
    <p class="line_zh">好的，这就是你如何使用Big-O表示法。</p>
    <p class="">It turns out that occasionally you want to say a few other things.</p>
    <p class="line_zh">事实证明，偶尔你想说一些其他的事情。</p>
    <p class="">Big O really just says that my runtime is sort of bounded above by some multiple of this thing.</p>
    <p class="line_zh">Big O真的只是说我的运行时有点像这个东西的多个。</p>
    <p class="">Sometimes you want to say the reverse.</p>
    <p class="line_zh">有时你想反过来说。</p>
    <p class="">Sometimes you want to say that I'm bounded below.</p>
    <p class="line_zh">有时候你想说我受到了限制。</p>
    <p class="">And so there's different notation for that.</p>
    <p class="line_zh">所以有不同的表示法。</p>
    <p class="">If you want to say that f is bounded below by g, that it grows no slower than g, you say that f(n) is Omega of g(n).</p>
    <p class="line_zh">如果你想说f低于g，它的增长速度不低于g，你说f（n）是g（n）的Omega。</p>
    <p class="">And that says that for some constant c, f(n) is at least c times g(n), for all large n.</p>
    <p class="line_zh">并且这表示对于某些常数c，对于所有大的n，f（n）至少是g乘以g（n）。</p>
    <p class="">Now instead of saying bounded above or bounded below, sometimes that you actually want to say that they grow at the same
        rate.
    </p>
    <p class="line_zh">现在不是说上面或下面有界，有时你真的想说它们以相同的速度增长。</p>
    <p class="">And for that you'd see f is Big-Theta of g(n).</p>
    <p class="line_zh">为此，你会看到f是g（n）的Big-Theta。</p>
    <p class="">Which means, that F is both Big-O of g, and, Big-Omega of G.</p>
    <p class="line_zh">这意味着，F既是G的Big-O，又是G的Big-Omega。</p>
    <p class="">Which says, up to constants, that f and g grow at the same rate.</p>
    <p class="line_zh">根据常数，f和g以相同的速率增长。</p>
    <p class="">Finally, sometimes instead of saying that f grows no faster than g, you actually have to say that it grows strictly slower
        than g, and for that you say f(n) is Little-o of g(n).</p>
    <p class="line_zh">最后，有时不是说f的增长速度不比g快，你实际上不得不说它的生长速度比g慢，为此你说f（n）是g（n）的Little-o。</p>
    <p class="">And that says that, not only is the ratio between f(n) and g(n) bounded above by some constant, but actually this constant
        can be made as small as you like.</p>
    <p class="line_zh">这就是说，f（n）和g（n）之间的比率不仅高于某个常数，而且实际上这个常数可以根据你的喜好制作。</p>
    <p class="">In particular this means that the ratio f(n) over g(n) goes to zero as n goes to infinity.</p>
    <p class="line_zh">特别地，这意味着当n变为无穷大时，比率f（n）相对于g（n）变为零。</p>
    <p class="">So, these are some other notations that you'll see now and then.</p>
    <p class="line_zh">所以，这些是你偶尔会看到的其他一些符号。</p>
    <p class="">You should keep them in mind.</p>
    <p class="line_zh">你应该记住它们。</p>
    <p class="">They're useful.</p>
    <p class="line_zh">它们很有用。</p>
    <p class="">Big-O is the one that usually shows up, because we actually want to bound our runtimes above.</p>
    <p class="line_zh">Big-O通常会出现，因为我们实际上想要将运行时限制在上面。</p>
    <p class="">It's sort of the big, important thing, but these guys are also useful.</p>
    <p class="line_zh">这有点重要，但这些人也很有用。</p>
    <p class="">So, to summarize the stuff on asymptotic notation.</p>
    <p class="line_zh">所以，总结一下渐近符号的东西。</p>
    <p class="">What it lets us do is ignore these messy details in the runtime analysis that we saw before.</p>
    <p class="line_zh">它让我们做的是忽略我们之前看到的运行时分析中的这些混乱细节。</p>
    <p class="">It produces very clean answers that tell us a lot about the asymptotic runtime of things.</p>
    <p class="line_zh">它产生非常干净的答案，告诉我们很多关于事物的渐近运行时间。</p>
    <p class="">And these together make it very useful.</p>
    <p class="line_zh">这些一起使它非常有用。</p>
    <p class="">It means we're going to be using it extensively throughout the course.</p>
    <p class="line_zh">这意味着我们将在整个课程中广泛使用它。</p>
    <p class="">So you really ought to get used to it.</p>
    <p class="line_zh">所以你真的应该习惯它。</p>
    <p class="">But, it does throw away a lot of practical useful information.</p>
    <p class="line_zh">但是，它确实丢掉了许多实用的有用信息。</p>
    <p class="">So if you really want to make your program fast, you need to look at more than just the Big-O runtime.</p>
    <p class="line_zh">因此，如果您真的想让程序更快，那么您需要查看的不仅仅是Big-O运行时。</p>
    <p class="">But, beyond that, we're going to use it.</p>
    <p class="line_zh">但是，除此之外，我们将使用它。</p>
    <p class="">With this lecture, we basically finished the sort of introductory material that we need.</p>
    <p class="line_zh">通过本次讲座，我们基本上完成了所需的介绍性材料。</p>
    <p class="">Next lecture I'll talk to you a little bit about sort of an overview of the rest of the course and some our philosophy
        for it.</p>
    <p class="line_zh">下一讲我将与您讨论一下课程其余部分的概述以及我们的理念。</p>
    <p class="">But after that, we'll really get into the meat of the subject.</p>
    <p class="line_zh">但在那之后，我们将真正深入了解这一主题。</p>
    <p class="">We'll start talking about key important ways to design algorithms.</p>
    <p class="line_zh">我们将开始讨论设计算法的关键重要方法。</p>
    <p class="">So, I hope you enjoy it.</p>
    <p class="line_zh">所以，我希望你喜欢它。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 18 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_18">第01章 course overview
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01课程概述</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello everybody, welcome back to the Data Structures and Algorithm specialization and the Algorithmic Toolbox course
        within it.</p>
    <p class="line_zh">各位大家好，欢迎回到数据结构和算法专业化以及其中的算法工具箱课程。</p>
    <p class="">This is the last lecture in the introductory unit and here we're going to give sort of an overview of the course.</p>
    <p class="line_zh">这是介绍单元的最后一个讲座，在这里我们将对课程进行概述。</p>
    <p class="">And in particular, what we're going to do is we're going to talk about sort of the philosophy of the course, and how
        it fits into the what we're going to be teaching you within the rest of this course.</p>
    <p class="line_zh">特别是，我们要做的是，我们将谈论课程的哲学，以及它如何适应我们将在本课程的其余部分教授你的内容。</p>
    <p class="">So, there's a problem.</p>
    <p class="line_zh">所以，有一个问题。</p>
    <p class="">Algorithm design is hard, and in particular it's hard to teach.</p>
    <p class="line_zh">算法设计很难，尤其难以教授。</p>
    <p class="">And by this I actually mean something pretty specific.</p>
    <p class="line_zh">通过这个，我实际上意味着非常具体的东西。</p>
    <p class="">Now, algorithms solve many, many different problems.</p>
    <p class="line_zh">现在，算法解决了许多不同的问题。</p>
    <p class="">You can use them to find paths between locations on a map, or find good matchings with some property, or identify images
        in a photograph.</p>
    <p class="line_zh">您可以使用它们在地图上查找位置之间的路径，或找到与某些属性的良好匹配，或识别照片中的图像。</p>
    <p class="">Many, many different sort of unrelated sounding problems can all be solved by algorithms.</p>
    <p class="line_zh">许多不同类型的无关声音问题都可以通过算法解决。</p>
    <p class="">And because the sorts of things that an algorithm problem might ask you to do are so varied, there's no unified technique
        that will allow you to solve all of them.</p>
    <p class="line_zh">而且因为算法问题可能要求你做的事情是多种多样的，所以没有统一的技术可以让你解决所有问题。</p>
    <p class="">And this is different from what you see in a lot of classes, when you're learning linear algebra they talk about how
        do you solve systems of linear equations.</p>
    <p class="line_zh">这与你在很多课程中看到的不同，当你学习线性代数时，他们会谈到你如何解决线性方程组。</p>
    <p class="">And they teach you some technique, like row reduction, and then you're sort of done.</p>
    <p class="line_zh">他们教你一些技巧，比如行减少，然后你就完成了。</p>
    <p class="">You just sort of need to practice it, and you can solve any system of linear equations.</p>
    <p class="line_zh">你只需要练习它，你就可以解决任何线性方程组。</p>
    <p class="">They give you a system of linear equations, you turn the crank on this row reduction technology and out pops an answer.</p>
    <p class="line_zh">它们为您提供了一个线性方程组，您可以在此行减速技术上转动曲柄并弹出答案。</p>
    <p class="">For algorithms there isn't that sort of thing.</p>
    <p class="line_zh">对于算法，没有那种东西。</p>
    <p class="">There's no general procedure where I give you an algorithms problem and you sort of plug it into this machine and turn
        a crank and out pops a good algorithm for it.</p>
    <p class="line_zh">没有一般的程序，我给你一个算法问题，你可以把它插入这台机器并转动一个曲柄，然后弹出一个很好的算法。</p>
    <p class="">And this makes it hard to teach.</p>
    <p class="line_zh">这使教学变得困难。</p>
    <p class="">If there was such a thing, we could just teach you, here's this thing that you do.</p>
    <p class="line_zh">如果有这样的事情，我们可以教你，这就是你做的事情。</p>
    <p class="">You do this, and you'll have a good algorithm for any problem you might run into.</p>
    <p class="line_zh">你这样做了，对于你可能遇到的任何问题，你都会有一个很好的算法。</p>
    <p class="">And it's harder than that.</p>
    <p class="line_zh">它比那更难。</p>
    <p class="">I mean, sometimes, in order to find a good algorithm, it requires that you have a unique insight.</p>
    <p class="line_zh">我的意思是，有时候，为了找到一个好的算法，它需要你有一个独特的见解。</p>
    <p class="">You're working on some problem that no one's ever looked at before.</p>
    <p class="line_zh">你正在解决以前没有人看过的一些问题。</p>
    <p class="">In order to find a good algorithm for it, you need to come up with some clever idea that no one else has ever come up
        with before.</p>
    <p class="line_zh">为了找到一个好的算法，你需要想出一些其他人从未想过的聪明的想法。</p>
    <p class="">This is why sort of algorithms are so well studied, why they're such an active field of research.</p>
    <p class="line_zh">这就是为什么有些算法得到了很好的研究，为什么它们是如此活跃的研究领域。</p>
    <p class="">There are still so many different new things yet to be discovered there.</p>
    <p class="line_zh">还有很多不同的新事物尚待发现。</p>
    <p class="">And we certainly can't teach you things that haven't been discovered yet.</p>
    <p class="line_zh">我们当然不能教你尚未发现的东西。</p>
    <p class="">And we also can't teach you things custom tailored to the problems that you are going to run into in your life as a programmer.</p>
    <p class="line_zh">而且我们也无法教你根据你作为程序员生活中遇到的问题而定制的东西。</p>
    <p class="">So since we can't teach you everything you need to know about how to solve all of your algorithm problems, what can we
        teach you? Well, there are sort of two things.</p>
    <p class="line_zh">因为我们无法教你如何解决所有算法问题所需的一切，我们能教你什么？嗯，有两件事。</p>
    <p class="">One thing that we can definitely give you is practice designing algorithms.</p>
    <p class="line_zh">我们可以肯定的一件事就是练习设计算法。</p>
    <p class="">We're going to have lots of homework problems with lots of things for you to work on, and this will give you practice,
        how do you, given a problem you haven't seen before, come up with a good algorithm for it? Once you have the algorithm,
        how do you implement it and make sure everything works and runs reasonably well? That's something you can practice.</p>
    <p class="line_zh">我们会有很多功课需要你做很多事情，这会给你练习，你怎么样，给出你以前没见过的问题，想出一个好的算法呢？一旦你有了算法，你如何实现它并确保一切正常并且运行得相当好？这是你可以练习的东西。</p>
    <p class="">And it turns out that for the type of problems where they're sort of very general and can be many different things, I
        mean, it's possible to solve a lot of them, and one of the ways to be able to solve them is practice.</p>
    <p class="line_zh">事实证明，对于那些非常普遍且可能有很多不同事物的问题类型，我的意思是，它可以解决很多问题，其中一种解决问题的方法就是实践。</p>
    <p class="">But we're also going to do more.</p>
    <p class="line_zh">但我们也会做更多。</p>
    <p class="">We're not just going to throw you in the deep end and say, try to swim, try to program all of these algorithms.</p>
    <p class="line_zh">我们不仅会让你陷入困境，还要试着游泳，尝试编程所有这些算法。</p>
    <p class="">There is something useful.</p>
    <p class="line_zh">有一些有用的东西。</p>
    <p class="">We can't teach you a generic procedure that will solve any algorithms problem for you.</p>
    <p class="line_zh">我们无法教你一个能解决任何算法问题的通用程序。</p>
    <p class="">But what we can do is we can give you some common tools.</p>
    <p class="line_zh">但我们能做的就是为您提供一些常用工具。</p>
    <p class="">Some very useful tools for algorithm design.</p>
    <p class="line_zh">一些非常有用的算法设计工具。</p>
    <p class="">And especially in this first course in our specialization we're really going to focus on helping to build up your algorithmic
        toolbox.
    </p>
    <p class="line_zh">特别是在我们专业化的第一个课程中，我们将专注于帮助构建您的算法工具箱。</p>
    <p class="">And in particular, this course is going to focus on three of the most common and most generally applicable algorithmic
        design techniques.</p>
    <p class="line_zh">特别是，本课程将重点介绍三种最常见，最普遍适用的算法设计技巧。</p>
    <p class="">The first of these is greedy algorithms.</p>
    <p class="line_zh">第一个是贪心算法。</p>
    <p class="">This is something where you're trying to construct some big object, and the way you do it is you sort of make one decision
        in the most greedy, locally optimal way you can.</p>
    <p class="line_zh">这是你正在尝试构建一些大对象的东西，而你这样做的方式就是你可以用最贪婪的，局部最优的方式做出一个决定。</p>
    <p class="">And once you've made that decision you make another decision in the most greedy, locally optimal way you can.</p>
    <p class="line_zh">一旦你做出了这个决定，你就可以用最贪婪，最优化的方式做出另一个决定。</p>
    <p class="">And you just keep making these decisions one at a time until you have an answer.</p>
    <p class="line_zh">你只需要一次做出这些决定，直到得到答案。</p>
    <p class="">And surprisingly somehow making these locally optimal decisions gives you a globally optimal solution.</p>
    <p class="">令人惊讶的是，以某种方式做出这些局部最优决策为您提供全局最优解决方案</p>
    <p class="">And when this happens it gives you very clean algorithms and it's great.</p>
    <p class="line_zh">当发生这种情况时，它会为您提供非常干净的算法，而且非常棒。</p>
    <p class="">That's the first thing we'll talk about.</p>
    <p class="line_zh">这是我们要谈的第一件事。</p>
    <p class="">Next, we'll talk about divide and conquer, which is a technique where you've got some big problem you're trying to solve.</p>
    <p class="line_zh">接下来，我们将谈论分而治之，这是一种你正试图解决的一个大问题。</p>
    <p class="">What you do is you break it into a bunch of little pieces, you solve all the pieces, and then you put their answers together
        to solve the original thing.</p>
    <p class="line_zh">你做的是把它分成一堆小块，你解决所有的碎片，然后你把它们的答案放在一起解决原始的问题。</p>
    <p class="">Finally we'll talk about dynamic programming.</p>
    <p class="line_zh">最后，我们将讨论动态编程。</p>
    <p class="">This is a little bit more subtle of a technique.</p>
    <p class="line_zh">这是一种技术的一点点微妙。</p>
    <p class="">This is what you get when you've got some sort of large problem, that has sort of a lot of, not sub-problems, but sort
        of related problems to it.</p>
    <p class="line_zh">这就是当你遇到某种大问题时所得到的问题，它有很多问题，而不是子问题，而是一些相关的问题。</p>
    <p class="">And this sort of whole family of related problems, their solutions sort of depend on one another in a particular type
        of way.</p>
    <p class="line_zh">而这种相关问题的整个家族，他们的解决方案在某种特定类型的方式上彼此依赖。</p>
    <p class="">And when you have it there's this great trick that you have, where you sort of start at the small problems at the bottom
        of the pile.</p>
    <p class="line_zh">当你拥有它时，你就拥有了这个伟大的技巧，你可以从那里开始解决桩底问题。</p>
    <p class="">And you solve all of them.</p>
    <p class="line_zh">你解决了所有这些问题。</p>
    <p class="">And you sort of keep track of all of your answers.</p>
    <p class="line_zh">你可以跟踪所有的答案。</p>
    <p class="">And you use the answers to the small problems, to build up to obtain answers to the larger and larger problems.</p>
    <p class="line_zh">并且您使用小问题的答案，建立以获得更大和更大问题的答案。</p>
    <p class="">So these are what we're going to talk about.</p>
    <p class="line_zh">所以这些就是我们要讨论的内容。</p>
    <p class="">Each of the techniques we're going to talk about, how you recognize when it applies, how do you analyze it when it applies,
        and some practical techniques about how to implement, how to use them.</p>
    <p class="line_zh">我们将讨论的每种技术，如何识别它何时应用，如何应用它时如何进行分析，以及一些关于如何实施，如何使用它们的实用技术。</p>
    <p class="">All that good stuff.</p>
    <p class="line_zh">所有那些好东西。</p>
    <p class="">So there's one other thing before we let you go into the fun world of greedy algorithms that you should keep in mind
        throughout this course, and that's that there are these, maybe, different levels of algorithm design.</p>
    <p class="line_zh">所以在我们让你进入贪婪算法的有趣世界之前还有另外一件事，你应该在整个课程中牢记这一点，那就是有这些，也许是不同级别的算法设计。</p>
    <p class="">There's sort of different levels of sophistication that go into it.</p>
    <p class="line_zh">其中有各种不同的复杂程度。</p>
    <p class="">At sort of the very lowest level, or top of this slide, I guess, there is the naive algorithm.</p>
    <p class="line_zh">在这个幻灯片的最低级别或顶部，我猜，有一个天真的算法。</p>
    <p class="">This is sort of a thing where you take the definition of a problem and you turn it into an algorithm, and we saw this
        for Fibonacci numbers and greatest common divisors.</p>
    <p class="line_zh">这是一个你接受问题定义并将其转化为算法的东西，我们看到了斐波纳契数和最大公约数。</p>
    <p class="">You sort of interpreted the definition of the thing you wanted to compute as an algorithm, and you were done.</p>
    <p class="line_zh">您可以将您想要计算的事物的定义解释为算法，并且您已经完成了。</p>
    <p class="">Now, these things are often very slow, as we saw.</p>
    <p class="line_zh">现在，正如我们所看到的，这些事情往往非常缓慢。</p>
    <p class="">Often they look like in order to find the best way of doing something, we enumerate all ways to do it, and then figure
        out which one's the best.</p>
    <p class="line_zh">通常他们看起来是为了找到最好的做事方式，我们列举所有方法来做，然后找出哪一个是最好的。</p>
    <p class="">On the other hand, these are slow, but it's often a good idea to first come up with a naive algorithm, just make sure
        you have some algorithm that works.</p>
    <p class="line_zh">另一方面，这些都很慢，但首先想出一个天真的算法通常是一个好主意，只要确保你有一些有效的算法。</p>
    <p class="">Sometimes this works well and often you can just be done with it.</p>
    <p class="line_zh">有时候这种方法很有效，通常你可以用它完成。</p>
    <p class="">Other times, it's too slow, but at least you made sure that you understood what problem you were working on and have
        something that runs.</p>
    <p class="line_zh">其他时候，它太慢了，但至少你确定你明白你正在做什么问题并且有一些运行的东西。</p>
    <p class="">But after that, the next thing that you want to do, if this naive algorithm is too slow, is you try and look at your
        tool box.</p>
    <p class="line_zh">但在那之后，你要做的下一件事，如果这个天真的算法太慢，你试着看看你的工具箱。</p>
    <p class="">You say, are there any standard techniques that I know that apply here? Maybe there's a greedy algorithm that solves
        this problem, or maybe I have to use a dynamic program.</p>
    <p class="line_zh">你说，有没有我知道适用的标准技术？也许有一个贪婪的算法可以解决这个问题，或者我可能需要使用动态程序。</p>
    <p class="">But if you can find one of these standard techniques that work, often that doesn't involve too much effort on your part,
        and gives you something that works pretty well.</p>
    <p class="line_zh">但是如果你能找到其中一种有效的标准技术，通常不需要你付出太多努力，并且能给你一些非常好的东西。</p>
    <p class="">Now once you have something that works, you often want to optimize it.</p>
    <p class="line_zh">现在，一旦你有一些有用的东西，你经常想要优化它。</p>
    <p class="">And there are lots of ways to improve an existing algorithm.</p>
    <p class="line_zh">并且有很多方法可以改进现有的算法。</p>
    <p class="">Reduce the runtime from n-cubed to n-squared or n-squared to n.</p>
    <p class="line_zh">将运行时间从n-cubed减少到n-squared或n-squared到n。</p>
    <p class="">And to do this, there are just a whole bunch of things.</p>
    <p class="line_zh">要做到这一点，只有很多东西。</p>
    <p class="">Maybe sometimes you could just sort of rearrange the order in which you do the operations to cut out some of the work
        that you do.</p>
    <p class="line_zh">也许有时你可能只是重新排列你执行操作的顺序，以削减你做的一些工作。</p>
    <p class="">Sometimes you have to introduce a data structure to speed things up.</p>
    <p class="line_zh">有时您必须引入数据结构以加快速度。</p>
    <p class="">There are a bunch of ways to do this.</p>
    <p class="line_zh">有很多方法可以做到这一点。</p>
    <p class="">We'll talk a little bit about how this works.</p>
    <p class="line_zh">我们将谈谈它是如何工作的。</p>
    <p class="">And these three levels are things that you should be comfortable with and able to apply pretty well by the end of this
        course.
    </p>
    <p class="line_zh">这三个级别是你应该感到舒服的，并且能够在本课程结束时很好地应用。</p>
    <p class="">However, sometimes these three are not enough.</p>
    <p class="line_zh">但是，有时这三个还不够。</p>
    <p class="">Sometimes a naive algorithm is just too slow, the standard tools don't apply, there's nothing that you can really optimize
        to improve things.</p>
    <p class="line_zh">有时一个天真的算法太慢，标准工具不适用，没有什么可以真正优化来改进。</p>
    <p class="">Sometimes in order to get a workable algorithm, what you need is magic.</p>
    <p class="line_zh">有时为了获得可行的算法，你需要的是神奇的。</p>
    <p class="">You need some unique insight that no one else has ever had before.</p>
    <p class="line_zh">你需要一些以前从未有过的独特洞察力。</p>
    <p class="">You need some sort of clever new idea and these, there's only so much we can do to teach you how to produce magic.</p>
    <p class="line_zh">你需要一些聪明的新想法，这些，我们可以做的就是教你如何制作魔法。</p>
    <p class="">We will show you some examples of things that really did have clever ideas that maybe you can't reproduce the thought
        process like, how do you come up with this crazy idea, that just happens to make this work? You should at least be
        able to appreciate the sort of thought that goes into this sort of thing.</p>
    <p class="line_zh">我们将向您展示一些事实，其中确实有一些聪明的想法，也许您无法重现思考过程，例如，您如何想出这个疯狂的想法，这恰好使这项工作成功？你至少应该能够理解这种事情的那种思想。</p>
    <p class="">In any case it's something to keep in mind when looking on that, when thinking about our problems, and what sort of things
        are expected of you.</p>
    <p class="line_zh">在任何情况下，在考虑问题时，要考虑到我们的问题，以及对您的期望是什么样的事情，请记住这一点。</p>
    <p class="">In any case, that is basically it for the introductory segment.</p>
    <p class="line_zh">在任何情况下，这基本上都是介绍性部分。</p>
    <p class="">We've talked a lot about sort of why algorithms are important and given you some examples.</p>
    <p class="line_zh">我们已经谈了很多关于为什么算法很重要并给你一些例子的原因。</p>
    <p class="">We've talked about asymptotic notation, but now it's time to let you go to the rest of the course.</p>
    <p class="line_zh">我们已经谈到了渐近符号，但是现在是时候让你去学习其他课程了。</p>
    <p class="">The rest of the course will keep giving you exercises to hone your skills, and each unit of this course will cover one
        of these major techniques.</p>
    <p class="line_zh">本课程的其余部分将继续为您提供练习以磨练您的技能，本课程的每个单元都将涵盖其中一项主要技巧。</p>
    <p class="">After I leave you with the end of the introduction, Michael will pick up and talk to you about greedy algorithms.</p>
    <p class="line_zh">在我离开你的介绍结束后，迈克尔将接听并与你谈论贪婪的算法。</p>
    <p class="">Next off, Neil will talk to you about divide and conquer.</p>
    <p class="line_zh">接下来，尼尔将与你谈论分而治之。</p>
    <p class="">Finally, Pavel will have a unit on dynamic programming.</p>
    <p class="line_zh">最后，Pavel将有一个关于动态编程的单元。</p>
    <p class="">Each of these, they will talk to you about where the technique applies, how to analyze it, how to implement it, all that
        good stuff.</p>
    <p class="line_zh">其中每一个，他们都会与您讨论技术应用的位置，如何分析，如何实施，以及所有好的东西。</p>
    <p class="">But this is where I leave you, I hope you enjoyed the introduction, and I will put you in Michael's very capable hands
        to start learning about greedy algorithms starting in the next lecture.</p>
    <p class="line_zh">但这就是我离开你的地方，我希望你喜欢这个介绍，我会让你在迈克尔的能力很强的手中开始学习贪婪的算法，从下一讲开始。</p>
    <p class="">So, until then, farewell.</p>
    <p class="line_zh">所以，在那之前，告别。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 19 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_19">第01章 largest number
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01号码最大</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hi, I'm Michael Levin and together we will study Greedy Algorithms.</p>
    <p class="line_zh">嗨，我是迈克尔莱文，我们将一起研究贪婪算法。</p>
    <p class="">They are some of the simplest algorithms that exist and they usually seem a pretty natural way to try solving a problem.</p>
    <p class="line_zh">它们是存在的一些最简单的算法，它们通常似乎是尝试解决问题的一种非常自然的方式。</p>
    <p class="">We will start with a few examples of problems that can be solved by greedy algorithms, just to illustrate how they work.</p>
    <p class="line_zh">我们将从贪婪算法可以解决的一些问题示例开始，只是为了说明它们是如何工作的。</p>
    <p class="">And our very first problem is a problem about largest number.</p>
    <p class="line_zh">我们的第一个问题是关于最大数量的问题。</p>
    <p class="">And for this problem, you will probably be able to come up with a greedy algorithm yourself, because that is really a
        very natural thing to do.</p>
    <p class="line_zh">对于这个问题，你可能会自己想出一个贪婪的算法，因为这真的是很自然的事情。</p>
    <p class="">So imagine this situation.</p>
    <p class="line_zh">想象一下这种情况。</p>
    <p class="">You are trying to get a job at a company and you already had a few interviews, and everything went well.</p>
    <p class="line_zh">你正试图在一家公司找到一份工作而且你已经接受过一些采访，一切都很顺利。</p>
    <p class="">Now you have your final interview with the boss, and he tells you that he will give you an offer.</p>
    <p class="line_zh">现在你对老板进行了最后的采访，他告诉你他会给你一个报价。</p>
    <p class="">But instead of negotiating your salary with you, he will give you a few pieces of paper with digits written on them.</p>
    <p class="line_zh">但是，他不会和你谈判你的工资，而是会给你一些纸上写着数字的纸。</p>
    <p class="">And your task will be to arrange those digits in a row, so that when you read the number from left to right, that will
        be your salary.</p>
    <p class="line_zh">你的任务是将这些数字排成一排，这样当你从左到右阅读这个数字时，这就是你的工资。</p>
    <p class="">So basically, you have a problem.</p>
    <p class="line_zh">所以基本上，你有一个问题。</p>
    <p class="">Given a few digits, to arrange them in the largest possible number.</p>
    <p class="line_zh">给出几位数，以尽可能多的数量排列它们。</p>
    <p class="">And there are a few examples of such numbers on the slide.</p>
    <p class="line_zh">幻灯片上有一些这样的数字示例。</p>
    <p class="">So what do you think will be the correct answer to this problem? And of course, the correct answer is 997531.</p>
    <p class="line_zh">那么您认为这个问题的正确答案是什么？当然，正确答案是997531。</p>
    <p class="">And it's pretty obvious that you should arrange numbers from the largest to the smallest, from left to right.</p>
    <p class="line_zh">而且很明显，你应该从左到右排列从最大到最小的数字。</p>
    <p class="">But let's look at how the greedy algorithm does that.</p>
    <p class="line_zh">但让我们来看看贪心算法是如何做到的。</p>
    <p class="">So, the Greedy Strategy is start with a list of digits then find the maximum digit in the list.</p>
    <p class="line_zh">因此，贪婪策略从一个数字列表开始，然后找到列表中的最大数字。</p>
    <p class="">Append it to the number and remove it from the list.</p>
    <p class="line_zh">将其附加到号码并将其从列表中删除。</p>
    <p class="">And then repeat this process until there are no digits left in the list.</p>
    <p class="line_zh">然后重复此过程，直到列表中没有剩余数字。</p>
    <p class="">So on the next step we will find the largest digit, which is again 9.</p>
    <p class="line_zh">因此，在下一步，我们将找到最大的数字，即9。</p>
    <p class="">We'll append it to the number to the right and remove it from the list.</p>
    <p class="line_zh">我们会将其附加到右侧的数字并将其从列表中删除。</p>
    <p class="">Then we will find 7 as the largest digit appended to the right and remove it from the list.</p>
    <p class="line_zh">然后我们将找到7作为右侧附加的最大数字并将其从列表中删除。</p>
    <p class="">And then we'll continue with 5, 3, and 1.</p>
    <p class="line_zh">然后我们将继续5,3和1。</p>
    <p class="">And then we get the correct answer, 997531.</p>
    <p class="line_zh">然后我们得到正确答案，997531。</p>
    <p class="">And in the next video, we will design an algorithm to find the minimum number of refuels during a long journey by car.</p>
    <p class="line_zh">在下一个视频中，我们将设计一种算法，以便在长途旅行中找到最少的加油次数。</p>
    <p class="">We will see similarities between these two problems, largest number problem and car refueling problem.</p>
    <p class="line_zh">我们将看到这两个问题，最大数量问题和汽车加油问题之间的相似之处。</p>
    <p class="">And we will define how greedy algorithms work in general.</p>
    <p class="line_zh">我们将定义贪婪算法的一般工作方式。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 20 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_20">第02章 car fueling
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02汽车加油</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hi.</p>
    <p class="line_zh">你好。</p>
    <p class="">In this video, we will consider the problem to find the minimum number of refills during a long journey by a car.</p>
    <p class="line_zh">在这段视频中，我们将考虑在汽车长途旅行中找到最小补充次数的问题。</p>
    <p class="">You will see the similarities between this problem and the largest number problem from the previous video.</p>
    <p class="line_zh">您将看到此问题与上一个视频中最大数量问题之间的相似之处。</p>
    <p class="">By the end, you will be able to describe how greedy algorithms work in general and define what is a safe move and a subproblem.</p>
    <p class="line_zh">最后，您将能够描述贪婪算法的一般工作方式，并定义什么是安全移动和子问题。</p>
    <p class="">Consider the following problem.</p>
    <p class="line_zh">考虑以下问题。</p>
    <p class="">You have a car such that if you fill it up to full tank, you can travel with it up to 400 kilometers without refilling
        it.
    </p>
    <p class="line_zh">你有一辆汽车，如果你把它装满满罐，你可以带它行驶400公里而不需要重新加油。</p>
    <p class="">And you need to get from point A to point B, and the distance between them is 950 kilometers.</p>
    <p class="line_zh">你需要从A点到B点，它们之间的距离是950公里。</p>
    <p class="">Of course, you need to refill on your way, and luckily, there are a few gas stations on your way from A to B.</p>
    <p class="line_zh">当然，你需要在路上补充，幸运的是，从A到B的路上有几个加油站。</p>
    <p class="">These are denoted by blue circles, and the numbers above them mean the distance from A to the corresponding gas station
        along the way from A to B.</p>
    <p class="line_zh">这些用蓝色圆圈表示，它们上面的数字表示从A到B的路径上从A到相应加油站的距离。</p>
    <p class="">And you need to find the minimum number of refills to get from A to B.</p>
    <p class="line_zh">而且你需要找到从A到B的最小重新填充次数。</p>
    <p class="">One example of such route is to get from point A to the first gas station, 200 kilometers, then to get from first station
        to the third gas station, 350 kilometers distance.</p>
    <p class="line_zh">这种路线的一个例子是从A点到达第一个加油站，200公里，然后从第一个站到达第三个加油站，距离为350公里。</p>
    <p class="">Then from third gas station to the fourth gas station, 200 km, and then from the fourth gas station to B, 200 kilometers.</p>
    <p class="line_zh">然后从第三加油站到第四加油站，200公里，然后从第四加油站到B，200公里。</p>
    <p class="">But that's not optimal.</p>
    <p class="line_zh">但那不是最佳选择。</p>
    <p class="">We can do better.</p>
    <p class="line_zh">我们可以做得更好。</p>
    <p class="">Here is another route, which only uses two refills.</p>
    <p class="line_zh">这是另一条路线，只使用两次续航。</p>
    <p class="">We get from A to the second gas station, less than 400 kilometers, then we get from the second gas station to the fourth
        gas station, again less than 400 kilometers.</p>
    <p class="line_zh">我们从A到第二个加油站，不到400公里，然后我们从第二个加油站到达第四个加油站，再次不到400公里。</p>
    <p class="">And then, from the fourth gas station to B, only 200 kilometers.</p>
    <p class="line_zh">然后，从第四个加油站到B，只有200公里。</p>
    <p class="">And this route uses only 2 refills, and it turns out that in this problem, the minimum number of refills is exactly 2.</p>
    <p class="line_zh">而这条路线只使用了2次补充，结果发现在这个问题中，最小补充次数正好是2次。</p>
    <p class="">More formally, we have the following problem.</p>
    <p class="line_zh">更正式地说，我们有以下问题。</p>
    <p class="">As the input, we have a car which can travel at most L kilometers, where L is a parameter if it's filled up to full tank.</p>
    <p class="line_zh">作为输入，我们有一辆车可以行驶最多L公里，其中L是一个参数，如果它填满了满罐。</p>
    <p class="">We have a source and destination, A and B, and we have n gas station at distances from x1 to xn in kilometers, from A
        along the path from A to B.</p>
    <p class="line_zh">我们有一个源和目的地，A和B，我们有一个加油站，距离从x1到xn，以千米为单位，从A沿着从A到B的路径。</p>
    <p class="">And we need to output the minimum number of refills to get from A to B, not counting the initial refill at A.</p>
    <p class="line_zh">我们需要输出从A到B的最小重新填充次数，不计算A处的初始重新填充。</p>
    <p class="">We want to solve this problem using a greedy strategy, and greedy strategy in general is very easy.</p>
    <p class="line_zh">我们想用贪婪的策略解决这个问题，一般来说贪婪策略很容易。</p>
    <p class="">You first make some greedy choice, then you reduce your problem to a smaller subproblem, and then you iterate until there
        are no problems left.</p>
    <p class="line_zh">你首先做出一些贪婪的选择，然后你将问题减少到一个较小的子问题，然后你迭代直到没有任何问题。</p>
    <p class="">There are a few different ways to make a greedy choice in this particular problem.</p>
    <p class="line_zh">在这个特定问题中，有几种不同的方法可以做出贪婪的选择。</p>
    <p class="">For example, you can always refill at the closest gas station to you.</p>
    <p class="line_zh">例如，您可以随时在最近的加油站重新加油。</p>
    <p class="">Another way is to refill at the farthest reachable gas station, and by reachable, I mean that you can get from your current
        position to this gas station without refills.</p>
    <p class="line_zh">另一种方法是在最远的可到达的加油站重新加油，并且可以到达，我的意思是你可以从你当前的位置到达这个加油站，而无需重新加油。</p>
    <p class="">Another way is, for example, to go until there is no fuel and then just hope that there will be a gas station in there.</p>
    <p class="line_zh">另一种方法是，例如，直到没有燃料，然后只希望那里会有一个加油站。</p>
    <p class="">So what do you think is the correct strategy in this problem? And of course, the third option is obviously wrong.</p>
    <p class="line_zh">那么您认为这个问题的正确策略是什么？当然，第三种选择显然是错误的。</p>
    <p class="">The first option is also wrong, if you think about it, but the second option is actually correct.</p>
    <p class="line_zh">第一个选项也是错误的，如果你考虑一下，但第二个选项实际上是正确的。</p>
    <p class="">It will give you the optimal number of refills.</p>
    <p class="line_zh">它会为您提供最佳的笔芯数量。</p>
    <p class="">We will prove it later.</p>
    <p class="line_zh">我们稍后会证明。</p>
    <p class="">For now, let's define our greedy algorithm as the whole algorithm.</p>
    <p class="line_zh">现在，让我们将贪婪算法定义为整个算法。</p>
    <p class="">So we start at A and we need to get to B with the minimum number of refills.</p>
    <p class="">所以我们从A开始，我们需要以最少的笔芯数到达B.</p>
    <p class="">We go from A to the farthest reachable gas station G so that we can get from A to G with full tank without any refills
        in the middle.</p>
    <p class="line_zh">我们从A到最远的可到达加油站G，这样我们可以从A到G从满油箱到达，中间没有任何加油。</p>
    <p class="">And now, we try to reduce this problem to a similar problem.</p>
    <p class="line_zh">现在，我们尝试将此问题减少到类似的问题。</p>
    <p class="">We make G the new A, and now our problem is to get from the new A to B, again with the minimum number of refills.</p>
    <p class="line_zh">我们将G作为新的A，现在我们的问题是从新的A到B，再次使用最少的笔芯。</p>
    <p class="">And by definition, a subproblem is a similar problem of smaller size.</p>
    <p class="line_zh">根据定义，子问题是较小尺寸的类似问题。</p>
    <p class="">One example of subproblem is from the previous video.</p>
    <p class="line_zh">子问题的一个例子来自前一个视频。</p>
    <p class="">When we need to construct the largest number out of a list of digits, we first put the largest digits in front, and then
        we reduce our problem to the problem of building the largest number out of the digits which are left.</p>
    <p class="line_zh">当我们需要从数字列表中构造最大数字时，我们首先将最大数字放在前面，然后我们将问题减少到构建剩余数字中最大数字的问题。</p>
    <p class="">In this problem, to find the minimum number of refills on the way from A to B, the first refill at the farthest reachable
        gas station G.</p>
    <p class="line_zh">在这个问题上，要找到从A到B的最小补充次数，在最远的可到达的加油站G进行第一次补充。</p>
    <p class="">And then solve a similar problem which is a subproblem to get from G to B with the minimum number of refills.</p>
    <p class="line_zh">然后解决一个类似的问题，这是一个子问题，从G到B以最少的重新填充。</p>
    <p class="">Another important term is safe move.</p>
    <p class="line_zh">另一个重要的术语是安全行动。</p>
    <p class="">We call a greedy choice a safe move if it is consistent with some optimal solution.</p>
    <p class="line_zh">如果它与一些最佳解决方案一致，我们称贪婪的选择是安全的举动。</p>
    <p class="">In other words, if there exists some optimal solution in which first move is this greedy choice, then this greedy choice
        is called a safe move.</p>
    <p class="line_zh">换句话说，如果存在一些最优解决方案，其中第一步是这种贪婪的选择，那么这种贪婪的选择被称为安全移动。</p>
    <p class="">And we will prove a lemma that to refill at the farthest reachable gas station is a safe move.</p>
    <p class="line_zh">我们将证明在最远的可到达的加油站重新填充是一个安全的举动。</p>
    <p class="">Let us first prove it visually.</p>
    <p class="line_zh">让我们首先在视觉上证明它。</p>
    <p class="">Let's consider some optimal route from A to B, and let the first stop on this route to refill B at point G1.</p>
    <p class="line_zh">让我们考虑从A到B的一些最佳路线，让第一站在这条路线上重新填充B点G1。</p>
    <p class="">And let G be the farthest gas station reachable from A.</p>
    <p class="line_zh">让G成为从A到达的最远的加油站。</p>
    <p class="">If G1 and G coincide, then our lemma is proved already.</p>
    <p class="line_zh">如果G1和G重合，那么我们的引理就已经证明了。</p>
    <p class="">Otherwise, G1 has to be closer to A than G, because G is the farthest reachable from A, and G1 is reachable from A.</p>
    <p class="line_zh">否则，G1必须比A更接近A，因为G是从A到达最远的，并且G1可以从A到达。</p>
    <p class="">Now, let's consider the next stop on the optimal route, and that would be G2.</p>
    <p class="line_zh">现在，让我们考虑最佳路线的下一站，那就是G2。</p>
    <p class="">And the first case is that G is closer to A than G2, then the route can look like this.</p>
    <p class="line_zh">第一种情况是G比G2更接近A，然后路线看起来像这样。</p>
    <p class="">In this case, we can actually refill at G instead of G1, and then we will have another optimal route because it has the
        same number of refills and G is reachable from A.</p>
    <p class="line_zh">在这种情况下，我们实际上可以在G而不是G1处重新填充，然后我们将有另一条最佳路线，因为它具有相同数量的重新填充且G可从A到达。</p>
    <p class="">And G2 is actually reachable from G, because it was reachable from G1, but G is closer to G2 than G1.</p>
    <p class="line_zh">并且G2实际上可以从G到达，因为它可以从G1到达，但是G比G1更接近G2。</p>
    <p class="">So this is a correct route, and in this case, our lemma is proved.</p>
    <p class="line_zh">所以这是一条正确的路线，在这种情况下，证明了我们的引理。</p>
    <p class="">And the second case is when G2 is actually closer to A than G, and then the route can look like this.</p>
    <p class="line_zh">第二种情况是当G2实际上比A更接近A时，然后路线看起来像这样。</p>
    <p class="">But in this case we can avoid refilling at G1 at all and refill at G2 or even refill at G in the first place.</p>
    <p class="line_zh">但是在这种情况下，我们可以完全避免在G1处重新填充并在G2处重新填充，或者甚至在G处重新填充。</p>
    <p class="">And then we will reduce the number of refills of our optimal route, which is impossible.</p>
    <p class="line_zh">然后我们将减少最佳路线的重新填充次数，这是不可能的。</p>
    <p class="">So the second case actually contradicts our statement that we are looking at an optimal route, and we've proved our lemma.</p>
    <p class="line_zh">因此，第二种情况实际上与我们的观点相矛盾，即我们正在寻找最佳路线，并且我们已经证明了我们的引理。</p>
    <p class="">To recap, we consider the optimal route R with a minimum number of refills.</p>
    <p class="line_zh">总结一下，我们考虑最佳路线R，最小补充次数。</p>
    <p class="">We denote by G1 the position of the first refill in R, and by G2, the next stop was R, which is either a refill or the
        destination B.</p>
    <p class="">我们用G1表示第一个替换物在R中的位置，而在G2，下一站是R，它是一个替换物或目的地B.</p>
    <p class="">And by G we denote the farthest refill reachable from A, and we considered two cases.</p>
    <p class="line_zh">由G我们表示从A可以到达的最远的填充物，我们考虑了两种情况。</p>
    <p class="">In the first case, if G is closer than G2 to A, we can refill at G instead of G1, and it means that refill at G is a
        safe move.</p>
    <p class="line_zh">在第一种情况下，如果G比G2更靠近A，我们可以在G而不是G1处重新填充，这意味着在G处重新填充是一个安全的举动。</p>
    <p class="">Otherwise, we can avoid refill at G1.</p>
    <p class="line_zh">否则，我们可以避免在G1重新填充。</p>
    <p class="">So this case contradicts that the route R is the route with the minimum number of refills.</p>
    <p class="line_zh">因此，这种情况与路线R是具有最小重新填充次数的路线相矛盾。</p>
    <p class="">So there is no such case, and we proved our lemma.</p>
    <p class="line_zh">所以没有这样的情况，我们证明了我们的引理。</p>
    <p class="">And in the next lecture, we will implement this algorithm in pseudocode and analyze its running time.</p>
    <p class="line_zh">在下一讲中，我们将以伪代码的形式实现该算法并分析其运行时间。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 21 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_21">第03章 car fueling implementation and analysis
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">03汽车加油实施和分析</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hi, in this video you will learn to implement the greedy algorithm from the previous video, and analyze its running time.</p>
    <p class="line_zh">嗨，在本视频中，您将学习如何实现上一个视频中的贪婪算法，并分析其运行时间。</p>
    <p class="">Here we have the pseudocode for this algorithm, and the procedure is called MinRefills.</p>
    <p class="line_zh">这里我们有这个算法的伪代码，程序叫做MinRefills。</p>
    <p class="">And the main input to this procedure is array x.</p>
    <p class="line_zh">此过程的主要输入是数组x。</p>
    <p class="">From the problems statement, we know that the positions of the gas stations are given by numbers from x1 to xn.</p>
    <p class="line_zh">从问题陈述中，我们知道加油站的位置由x1到xn的数字给出。</p>
    <p class="">And those are measured in kilometers in terms of distance from A to the corresponding gas station along the path from
        A to B.</p>
    <p class="line_zh">这些是以公里为单位测量的，从A到相应的加油站沿着从A到B的路径的距离。</p>
    <p class="">For convenience, we actually add to array x positions of point A which is x0 and is the smallest value in the array.</p>
    <p class="line_zh">为方便起见，我们实际上添加了点A的数组x位置，它是x0并且是数组中的最小值。</p>
    <p class="">And point B, which is Xn plus 1, and it is the largest value in the array x.</p>
    <p class="line_zh">并且B点是Xn加1，它是数组x中的最大值。</p>
    <p class="">Along our route from A to B, we will visit some points.</p>
    <p class="line_zh">沿着从A到B的路线，我们将访问一些点。</p>
    <p class="">Of course we will start from point A.</p>
    <p class="line_zh">当然我们将从A点开始。</p>
    <p class="">And then we'll probably go to some gas station, refilll there.</p>
    <p class="line_zh">然后我们可能去一些加油站，在那里重新装满。</p>
    <p class="">And then go to another gas station and to another gas station and then to another and then at some point we will get
        to the point B or point x n plus 1.</p>
    <p class="line_zh">然后去另一个加油站和另一个加油站再到另一个加油站，然后在某个时刻我们将到达B点或点xn加1。</p>
    <p class="">So we see that we only need to store the positions in the array x.</p>
    <p class="line_zh">所以我们看到我们只需要在数组x中存储位置。</p>
    <p class="">We don't need to consider any positions between the elements of array x.</p>
    <p class="line_zh">我们不需要考虑数组x的元素之间的任何位置。</p>
    <p class="">And so, we will store in the variable currentRefill, the position in the array x where we're currently standing.</p>
    <p class="line_zh">因此，我们将存储在变量currentRefill中，即我们当前所在的数组x中的位置。</p>
    <p class="">And we will initialize it with 0.</p>
    <p class="line_zh">我们将用0初始化它。</p>
    <p class="">Because we start from point A, which is the same as x0, and has index 0 in the array x.</p>
    <p class="line_zh">因为我们从点A开始，它与x0相同，并且在数组x中具有索引0。</p>
    <p class="">And later currentRefill will store the index in the array x, where we're currently standing.</p>
    <p class="line_zh">之后currentRefill会将索引存储在我们目前所在的数组x中。</p>
    <p class="">We'll also store the answer to our problem in the variable numRefills.</p>
    <p class="line_zh">我们还将在变量numRefills中存储我们问题的答案。</p>
    <p class="">At each point in the execution of the algorithm, it will contain the number of refills we have already made.</p>
    <p class="line_zh">在执行算法的每个点，它将包含我们已经完成的重新填充的数量。</p>
    <p class="">And we initialize it with zero because the problem statement asks us to count the minimum number of refills we need to
        do.
    </p>
    <p class="line_zh">我们用零初始化它，因为问题陈述要求我们计算我们需要做的最小重新填充次数。</p>
    <p class="">Not counting the initial refill at point A.</p>
    <p class="line_zh">不计算A点的初始补充。</p>
    <p class="">So when we are standing at point A, we consider that we haven't made any refills yet.</p>
    <p class="line_zh">因此，当我们站在A点时，我们认为我们尚未进行任何补充。</p>
    <p class="">Then the main external while loop goes.</p>
    <p class="line_zh">然后主外部while循环进行。</p>
    <p class="">And it goes on while we're still to the left from point B, because then we need to go right to reach our destination
        B.
    </p>
    <p class="">它继续从B点开始向左移动，因为那时我们需要向右走到目的地B.</p>
    <p class="">And we check this condition with this inequality, that currentRefill is at most n.</p>
    <p class="line_zh">我们用这个不等式检查这个条件，currentRefill最多是n。</p>
    <p class="">This means that the position or index in the array x is at most n, and so we're to the left from point B currently.</p>
    <p class="line_zh">这意味着数组x中的位置或索引最多为n，因此我们当前位于B点的左侧。</p>
    <p class="">In this case we still need to go to the right.</p>
    <p class="line_zh">在这种情况下，我们仍然需要向右走。</p>
    <p class="">And first we save our current position in the array x in the variable lastRefill.</p>
    <p class="line_zh">首先，我们在变量lastRefill中保存数组x中的当前位置。</p>
    <p class="">This means that we made our lastRefill in the position currentRefill.</p>
    <p class="line_zh">这意味着我们将lastRefill设置为currentRefill。</p>
    <p class="">And now we need to go to the right from there, and either get to destination B or get to the rightmost reachable gas
        station and refill there.</p>
    <p class="line_zh">现在我们需要从那里向右走，然后到达目的地B或者到达最右边的可到达加油站并在那里重新加油。</p>
    <p class="">And the next internal while loop does exactly that.</p>
    <p class="line_zh">而下一个内部while循环正是如此。</p>
    <p class="">It gradually increases our currentRefill position in the array x until it reaches the rightmost point in the array x
        which is reachable from the lastRefill position.</p>
    <p class="line_zh">它逐渐增加数组x中的currentRefill位置，直到它到达数组x中可从lastRefill位置到达的最右边的点。</p>
    <p class="">So first we check that currentRefill position is at most n because if it is n plus 1 already it means that we reached
        our destination B.</p>
    <p class="">所以首先我们检查currentRefill位置最多是n，因为如果它已经是n加1，那就意味着我们到达了目的地B.</p>
    <p class="">And there is no point increasing it further.</p>
    <p class="line_zh">没有必要进一步增加它。</p>
    <p class="">If it's still to the left from B, then we'll look at the next position to the right, x currentRefill plus 1.</p>
    <p class="line_zh">如果它仍然在B的左边，那么我们将查看右边的下一个位置，x currentRefill加1。</p>
    <p class="">We need to check whether it's reachable from lastRefill position or not.</p>
    <p class="line_zh">我们需要检查它是否可以从lastRefill位置到达。</p>
    <p class="">And first we can build the distance from the lastRefill position to the currentRefill plus one position by subtracting
        the values of the array x.</p>
    <p class="line_zh">首先，我们可以通过减去数组x的值来建立从lastRefill位置到currentRefill加上一个位置的距离。</p>
    <p class="">And if this distance is at most L, then it means that we can travel this distance with full tank, without any refills.</p>
    <p class="line_zh">如果这个距离最多为L，那么这意味着我们可以在满载坦克的情况下行驶这段距离，而无需任何补充。</p>
    <p class="">And of course, at the lastRefill position, we could fill our tank up to the full capacity.</p>
    <p class="line_zh">当然，在最后的补给位置，我们可以将我们的坦克装满。</p>
    <p class="">And then we'll be able to travel for L kilometers.</p>
    <p class="line_zh">然后我们将能够行驶L公里。</p>
    <p class="">So, this inequality checks if actually position currentRefill plus 1 is reachable from the lastRefill position.</p>
    <p class="line_zh">因此，这个不等式检查实际位置currentRefill加1是否可以从lastRefill位置到达。</p>
    <p class="">If it is, we increase the value of currentRefill and go on with our internal while loop.</p>
    <p class="line_zh">如果是，我们增加currentRefill的值并继续我们的内部while循环。</p>
    <p class="">When we exit this internal while loop we're already maybe in the point B, or we may be in some point which is the farthest
        reachable gas station.</p>
    <p class="line_zh">当我们退出这个内部的循环时，我们已经可能在B点，或者我们可能在某个点上，这是最远的可达加油站。</p>
    <p class="">Now we compare it with our lastRefill position.</p>
    <p class="line_zh">现在我们将它与lastRefill位置进行比较。</p>
    <p class="">And if it turns out that it is the same, it means that we couldn't go to the right.</p>
    <p class="line_zh">如果事实证明它是相同的，那就意味着我们无法走向正确。</p>
    <p class="">We don't have enough fuel even to get to the next gas station.</p>
    <p class="line_zh">我们甚至没有足够的燃料到达下一个加油站。</p>
    <p class="">And then, we cannot return the minimum number of refills that we need to do on the way from A to B, because it is impossible
        to get from A to B at all.</p>
    <p class="line_zh">然后，我们无法返回从A到B的路上我们需要做的最小重新填充次数，因为根本不可能从A到B。</p>
    <p class="">And so we return this result IMPOSSIBLE.</p>
    <p class="line_zh">所以我们返回这个结果是不可能的。</p>
    <p class="">Otherwise, we moved at least a bit to the right, and then we need to see.</p>
    <p class="line_zh">否则，我们至少向右移动一点，然后我们需要看到。</p>
    <p class="">If we are already in the point B, we don't need to do anything else.</p>
    <p class="line_zh">如果我们已经在B点，我们不需要做任何其他事情。</p>
    <p class="">Otherwise, we need to refill there.</p>
    <p class="line_zh">否则，我们需要在那里补充。</p>
    <p class="">So, we check that we're to the left from point B with this inequality.</p>
    <p class="line_zh">所以，我们检查我们是否在B点左边有这个不等式。</p>
    <p class="">And if it's true then we're at some gas station and we need to refuel.</p>
    <p class="line_zh">如果这是真的那么我们就在加油站，我们需要加油。</p>
    <p class="">So we increase the numRefills variable by one.</p>
    <p class="line_zh">所以我们将numRefills变量增加1。</p>
    <p class="">And then we return to the start of our external while loop.</p>
    <p class="line_zh">然后我们回到外部while循环的开始。</p>
    <p class="">And there we again check if we're to the left from point B we need another iteration.</p>
    <p class="line_zh">然后我们再次检查我们是否从B点向左，我们需要另一次迭代。</p>
    <p class="">And if currentRefill is already n plus 1, then we've reached point B and we need to exit the external while loop.</p>
    <p class="line_zh">如果currentRefill已经是n加1，那么我们已经到达了B点，我们需要退出外部while循环。</p>
    <p class="">And in that case, we just return the answer which is number of refills we've made so far.</p>
    <p class="line_zh">在这种情况下，我们只返回答案，这是我们迄今为止所做的补充数量。</p>
    <p class="">We've implemented the greedy algorithm from the previous lecture.</p>
    <p class="line_zh">我们已经实现了上一讲的贪婪算法。</p>
    <p class="">Now let's analyze its running time.</p>
    <p class="line_zh">现在让我们分析一下它的运行时间。</p>
    <p class="">From the first look it can seem that it works in n squared time because we have the external while loop which can make
        n iterations and internal loop which can make n iterations.</p>
    <p class="line_zh">从第一次看起来它似乎可以在n平方时间内工作，因为我们有外部while循环可以进行n次迭代，内部循环可以进行n次迭代。</p>
    <p class="">So, n by n is n squared, but actually we will show that it only makes O of n actions for the whole algorithm.</p>
    <p class="line_zh">所以，n乘n是n平方，但实际上我们将证明它只对整个算法产生了n个n个动作。</p>
    <p class="">To prove that let's first look at the currentRefill variable.</p>
    <p class="line_zh">为了证明我们首先看一下currentRefill变量。</p>
    <p class="">We see that it only changes one by one here.</p>
    <p class="line_zh">我们看到它只是在这里逐一改变。</p>
    <p class="">And it starts from zero.</p>
    <p class="line_zh">它从零开始。</p>
    <p class="">And what is the largest value that it can attain? Of course, the largest value is n plus 1 because this is the largest
        index in the array x, and currentRefil is index in the array x.</p>
    <p class="line_zh">它能达到的最大价值是多少？当然，最大值是n加1，因为这是数组x中的最大索引，而currentRefil是数组x中的索引。</p>
    <p class="">So, variable currentRefil starts from zero, changes one by one.</p>
    <p class="line_zh">因此，变量currentRefil从零开始，逐个变化。</p>
    <p class="">And the largest value it can have is n plus 1.</p>
    <p class="line_zh">它可以拥有的最大值是n加1。</p>
    <p class="">It means that it is increased at most n plus 1 times which is Big-O of n.</p>
    <p class="line_zh">这意味着它最多增加n加1倍，即n的Big-O。</p>
    <p class="">But that's not all we do.</p>
    <p class="line_zh">但这不是我们所做的全部。</p>
    <p class="">Also, we increase variable numRefills here.</p>
    <p class="line_zh">此外，我们在这里增加变量numRefills。</p>
    <p class="">But we also increase it always one by one.</p>
    <p class="line_zh">但我们也一个接一个地增加它。</p>
    <p class="">It also starts from zero.</p>
    <p class="line_zh">它也从零开始。</p>
    <p class="">And what is the largest number that this variable can attain? Well, of course, it is n because when we have n gas stations.</p>
    <p class="line_zh">这个变量可以达到的最大数字是多少？嗯，当然，这是因为我们有n个加油站。</p>
    <p class="">There is no point to refuel twice at the same gas station.</p>
    <p class="line_zh">没有必要在同一个加油站加油两次。</p>
    <p class="">So we can refuel at most n times.</p>
    <p class="line_zh">所以我们最多可以加油n次。</p>
    <p class="">So variable numRefills goes from 0 to n and changes one by one.</p>
    <p class="line_zh">因此，变量numRefills从0变为n并逐个变化。</p>
    <p class="">So it is only changed at most n times.</p>
    <p class="line_zh">所以它最多只改变了n次。</p>
    <p class="">And so, it is also linear in terms of n.</p>
    <p class="line_zh">因此，就n而言，它也是线性的。</p>
    <p class="">And so, we have at most n plus 1 iterations of the external while loop.</p>
    <p class="line_zh">因此，我们在外部while循环中最多有n加1次迭代。</p>
    <p class="">Everything but the internal while loop takes there constant time.</p>
    <p class="line_zh">除了内部while循环之外的所有东西都需要恒定的时间。</p>
    <p class="">This assignment, this if, and this if with assignment.</p>
    <p class="line_zh">这个赋值，这个if，如果有赋值的话。</p>
    <p class="">And the external loop and internal loop combined also spend at most linear time of iterations.</p>
    <p class="line_zh">并且外部循环和内部循环组合也花费在最多线性迭代时间。</p>
    <p class="">Because they change variable currentRefill and it changes at most linear number of times.</p>
    <p class="line_zh">因为它们改变了变量currentRefill并且它最多改变了线性次数。</p>
    <p class="">So all in all our algorithm works in Big-O n time.</p>
    <p class="line_zh">因此，总而言之，我们的算法在Big-O n时间工作。</p>
    <p class="">Let's go through this proof once again.</p>
    <p class="line_zh">让我们再次通过这个证明。</p>
    <p class="">The Lemma says that the running time of the whole algorithm is big O of n.</p>
    <p class="">引理说整个算法的运行时间是n的大O.</p>
    <p class="">And we prove this by first noticing that the currentRefill variable changes only from zero to at most n plus 1.</p>
    <p class="line_zh">我们通过首先注意到currentRefill变量仅从零变化到最多n加1来证明这一点。</p>
    <p class="">And the change is always one by one.</p>
    <p class="line_zh">而变化总是一个接一个。</p>
    <p class="">That the numRefills variable changes from zero to at most n.</p>
    <p class="line_zh">numRefills变量从零变为最多n。</p>
    <p class="">And it also changes one by one.</p>
    <p class="line_zh">它也一个接一个地改变。</p>
    <p class="">So, both these variables are changed Big-O of n times.</p>
    <p class="line_zh">因此，这两个变量都改变了n次的Big-O。</p>
    <p class="">And everything else that happens is constant time.</p>
    <p class="line_zh">其他一切都是不变的时间。</p>
    <p class="">Each iteration of the external loop, and there are at most n plus 1 iterations of the external loop.</p>
    <p class="line_zh">外部循环的每次迭代，外部循环最多有n加1次迭代。</p>
    <p class="">Thus, our algorithm works in linear time.</p>
    <p class="line_zh">因此，我们的算法在线性时间内工作。</p>
    <p class="">In the next video, we will review what we've learned about greedy algorithms in general.</p>
    <p class="line_zh">在下一个视频中，我们将回顾一下我们对贪婪算法的了解。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 22 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_22">第04章 main ingredients of greedy algorithms
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">04贪心算法的主要成分</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hi.</p>
    <p class="line_zh">你好。</p>
    <p class="">In this video, we will briefly review the main ingredients of greedy algorithms and the first of them is reduction to
        a subproblem.</p>
    <p class="line_zh">在本视频中，我们将简要回顾贪婪算法的主要成分，其中第一个是简化为子问题。</p>
    <p class="">Basically, when you have some problem, you make some first move and thus reduce your problem to a similar problem, but
        which is smaller.</p>
    <p class="line_zh">基本上，当你遇到一些问题时，你先做一些动作，从而将你的问题减少到类似的问题，但这个问题要小一些。</p>
    <p class="">For example, you have fewer digits left or fewer gas stations left in front of you and this similar problem, which is
        smaller is called a subproblem.</p>
    <p class="line_zh">例如，您剩下的数字较少或者前面留下的加油站较少，这个类似的问题较小，称为子问题。</p>
    <p class="">Another key ingredient is a safe move and the move is called safe if it is consistent with some optimal solution.</p>
    <p class="line_zh">另一个关键因素是安全移动，如果它与某些最佳解决方案一致，则称其为安全移动。</p>
    <p class="">In other words, if there exists some optimal solution in which the first move is the same as your move, then your move
        is called a safe move and not all first moves are actually safe.</p>
    <p class="line_zh">换句话说，如果存在一些最佳解决方案，其中第一个移动与您的移动相同，那么您的移动被称为安全移动，并非所有第一步移动实际上都是安全的。</p>
    <p class="">For example, to go until there's no fuel is not a safe move in the problem about car fueling.</p>
    <p class="line_zh">例如，直到没有燃料在汽车加油问题上不安全。</p>
    <p class="">And often, greedy moves are also not safe, for example, to get to the closest gas station and refuel at it is not a safe
        move while to get to the farthest gas station and refuel there is a safe move.</p>
    <p class="line_zh">通常情况下，贪婪的举动也是不安全的，例如，到达最近的加油站加油并不是一个安全的举动，而到达最远的加油站加油有一个安全的举动。</p>
    <p class="">Now the general strategy of solving a problem goes like this.</p>
    <p class="line_zh">现在解决问题的一般策略是这样的。</p>
    <p class="">First, you analyze the problem and you come up with some greedy choice and then the key thing is to prove that this greedy
        choice is a safe move and you really have to prove it.</p>
    <p class="line_zh">首先，你分析问题并提出一些贪婪的选择，然后关键是要证明这个贪婪的选择是一个安全的举动，你真的必须证明它。</p>
    <p class="">Because, otherwise, you can come up with some greedy choice and then come up with a greedy algorithm and then even implement
        it and test it and try to submit it in the system.</p>
    <p class="line_zh">因为，否则，你可以提出一些贪婪的选择，然后提出一个贪婪的算法，然后甚至实现它并测试它并尝试在系统中提交它。</p>
    <p class="">Only to learn that the algorithm is incorrect, because the first move is actually not a safe move and there are cases
        in which this first move is not consistent with any optimal solution.</p>
    <p class="line_zh">只是了解算法是不正确的，因为第一步实际上不是一个安全的举动，并且有些情况下，这第一步与任何最佳解决方案都不一致。</p>
    <p class="">And in that case, we will have to invent a new solution and implement it from scratch.</p>
    <p class="line_zh">在这种情况下，我们将不得不发明一种新的解决方案并从头开始实施。</p>
    <p class="">All the work you've done before will be useless.</p>
    <p class="line_zh">你之前完成的所有工作都是无用的。</p>
    <p class="">So please prove your algorithms and prove that the first move is a safe move.</p>
    <p class="line_zh">因此，请证明您的算法，并证明第一步是安全的举动。</p>
    <p class="">When you prove that, you reduce a problem to a subproblem.</p>
    <p class="line_zh">当您证明这一点时，您可以将问题减少到子问题。</p>
    <p class="">And hopefully, that is a similar problem, problem of a same kind and then you start solving this subproblem the same
        way.
    </p>
    <p class="line_zh">并且希望，这是一个类似的问题，同一类问题然后你开始以同样的方式解决这个子问题。</p>
    <p class="">You make your greedy choice and you reduce it to subproblem, and you iterate until there are no problems left or until
        your problem is so simple that you can just solve it right away.</p>
    <p class="line_zh">你做出贪婪的选择并将其减少到子问题，然后迭代直到没有任何问题或者直到你的问题如此简单以至于你可以马上解决它。</p>
    <p class="">And in the next lessons, we will apply greedy algorithms to solve more difficult problems.</p>
    <p class="line_zh">在接下来的课程中，我们将应用贪心算法来解决更多难题。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 23 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_23">第01章 celebration party problem
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01庆祝派对问题</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hi, in this lesson we will discuss the problem of organizing children into groups.</p>
    <p class="line_zh">嗨，在本课中，我们将讨论将儿童组织成小组的问题。</p>
    <p class="">And you will learn that if you use a naive algorithm to solve this problem, it will work very, very slowly, because the
        running time of this algorithm is exponential.</p>
    <p class="line_zh">并且您将了解到，如果您使用朴素算法来解决此问题，它将非常非常缓慢地工作，因为此算法的运行时间是指数级的。</p>
    <p class="">But later in the next lesson, we will be able to improve the training time significantly by coming up with a polynomial
        time algorithm.</p>
    <p class="line_zh">但是在下一课的后面，我们将通过提出多项式时间算法来显着改善训练时间。</p>
    <p class="">Let's consider the following situation.</p>
    <p class="line_zh">让我们考虑以下情况。</p>
    <p class="">You've invited a lot of children to a celebration party, and you want to entertain them and also teach them something
        in the process.</p>
    <p class="line_zh">你邀请了很多孩子参加庆祝派对，你想要招待他们，并在这个过程中教他们一些东西。</p>
    <p class="">You are going to hire a few teachers and divide the children into groups and assign a teacher to each of the groups this
        teacher will work with this group through the whole party.</p>
    <p class="line_zh">您将雇用一些教师并将孩子分成小组，并为每个小组分配一名教师，该老师将通过整个小组与该小组一起工作。</p>
    <p class="">But you know that for a teacher to work with a group of children efficiently children of that group should be of relatively
        the same age.</p>
    <p class="line_zh">但是你知道，对于一个老师与一群孩子一起工作，这个群体的孩子应该是相对年龄相同的。</p>
    <p class="">More specifically age of any two children in the same group should differ by at most one year.</p>
    <p class="line_zh">更具体地说，同一组中任何两个孩子的年龄应至少相差一年。</p>
    <p class="">Also, you want to minimize the number of groups.</p>
    <p class="line_zh">此外，您希望最小化组的数量。</p>
    <p class="">Because you want to hire fewer teachers, and spend the money on presents and other kinds of entertainment for the children.</p>
    <p class="line_zh">因为你想雇用更少的老师，并为孩子们花钱买礼物和其他类型的娱乐。</p>
    <p class="">So, you need to divide children into the minimum possible number of groups.</p>
    <p class="line_zh">因此，您需要将子项划分为尽可能少的组。</p>
    <p class="">Such that the age of any two children in any group differs by at most one year.</p>
    <p class="line_zh">这样任何一组中任何两个孩子的年龄最多相差一年。</p>
    <p class="">Now, let's look at the pseudo code for the naive algorithm that solves this problem.</p>
    <p class="line_zh">现在，让我们看一下解决这个问题的朴素算法的伪代码。</p>
    <p class="">Basically, this algorithm will consider every possible partition of the children into groups and find the partition which
        both satisfies the property that the ages of the children in any group should differ by at most one and contains
        the minimum number of groups.</p>
    <p class="line_zh">基本上，该算法将孩子的每个可能的分区考虑成组，并找到满足任何组中的孩子的年龄应该最多相差一个并且包含最小组数的属性的分区。</p>
    <p class="">We start with assigning the initial value of the number of groups to the answer m and this initial value is just the
        number of children.</p>
    <p class="line_zh">我们首先将组数的初始值分配给答案m，这个初始值只是孩子的数量。</p>
    <p class="">Because we can always divide all the children into groups of one, and then of course each group has only one child so
        the condition is satisfied.</p>
    <p class="line_zh">因为我们总能将所有孩子分成一组，然后每组只有一个孩子，所以条件得到满足。</p>
    <p class="">Then we consider every possible partition of all children into groups.</p>
    <p class="line_zh">然后我们将所有孩子的每个可能的分区都考虑成组。</p>
    <p class="">The number of groups can be variable, so this is denoted by a number k, and we have groups G1, G2 and up to Gk.</p>
    <p class="line_zh">组的数量可以是变量，因此用数字k表示，我们有G1，G2组和Gk组。</p>
    <p class="">And then we have a partition, we first need to check whether it's a good partition or not.</p>
    <p class="line_zh">然后我们有一个分区，我们首先需要检查它是否是一个好的分区。</p>
    <p class="">So, we have a variable good which we assigned to true initially, because we think that maybe this partition will be good.</p>
    <p class="line_zh">所以，我们有一个变量商品，我们最初分配给true，因为我们认为这个分区可能会很好。</p>
    <p class="">But then we need to check for each group whether it satisfies our condition or not.</p>
    <p class="line_zh">但是我们需要检查每个组是否满足我们的条件。</p>
    <p class="">So, we go in a for group with index i of the group from 1 to k, and then we consider the particular group GI, and we
        need to determine whether all the children in this group differ by at most 1 year, or there are two children that
        differ more.</p>
    <p class="line_zh">所以，我们进入一个组中索引为i的组，从1到k，然后我们考虑特定的组GI，我们需要确定这组中的所有孩子是否相差最多1年，或者有两个孩子有所不同。</p>
    <p class="">To check that, it is sufficient to compare the youngest child with the oldest child.</p>
    <p class="line_zh">要检查这一点，将最小的孩子与最大的孩子进行比较就足够了。</p>
    <p class="">If their ages differ more than by one, then the group is bad.</p>
    <p class="line_zh">如果他们的年龄差异超过1，那么这个群体就很糟糕。</p>
    <p class="">Otherwise, every two children differ by at most one year, so the group is good.</p>
    <p class="line_zh">否则，每两个孩子最多相差一年，所以小组很好。</p>
    <p class="">And so we go through all the groups in a for loop.</p>
    <p class="line_zh">所以我们在for循环中遍历所有组。</p>
    <p class="">If at least one of the groups is bad, then our variable good will contain value false by the end.</p>
    <p class="line_zh">如果至少有一个组是ba d，那么我们的变量good将在结尾处包含false值。</p>
    <p class="">Otherwise, all the groups are good, and the variable good will contain value true.</p>
    <p class="line_zh">否则，所有组都是好的，变量good将包含值true。</p>
    <p class="">So, after this for loop, we check the value of the variable good, and if it's true, then we improve our answer.</p>
    <p class="line_zh">因此，在这个for循环之后，我们检查变量good的值，如果它是真的，那么我们改进我们的答案。</p>
    <p class="">At least try to improve it.</p>
    <p class="line_zh">至少尝试改进它。</p>
    <p class="">With a minimum of its current value and the number of the groups in the current partition.</p>
    <p class="line_zh">使用当前分区的最小值和当前分区中的组数。</p>
    <p class="">And so, by the end of the outer for loop which goes through all the partitions, our variable m will contain the minimum
        possible number of groups in a partition that satisfies all the conditions.</p>
    <p class="line_zh">因此，在遍历所有分区的外部for循环结束时，我们的变量m将包含满足所有条件的分区中的最小可能组数。</p>
    <p class="">It is obvious that this algorithm works correctly because it basically considers all the possible variants and selects
        the best one from all the variants which satisfy our condition on the groups.</p>
    <p class="line_zh">很明显，这种算法可以正常工作，因为它基本上考虑了所有可能的变体，并从满足我们条件的所有变量中选择最佳变量。</p>
    <p class="">Now, let us estimate the running time of this algorithm.</p>
    <p class="line_zh">现在，让我们估算一下这个算法的运行时间。</p>
    <p class="">And I state that the number of operations that this algorithm makes is at least 2 to the power of n, where n is the number
        of children in C.</p>
    <p class="line_zh">我说这个算法所做的操作次数至少是n的幂，其中n是C中的子节点数。</p>
    <p class="">Actually, this algorithm works much slower and makes much more operations than 2 to the power of n, but we will just
        prove this lower bound to show that this algorithm is very slow.</p>
    <p class="line_zh">实际上，这个算法运行速度要慢得多，并且比n的幂要多运行2次，但我们只是证明这个下限表明这个算法非常慢。</p>
    <p class="">To prove it, let's consider just partitions of the children in two groups.</p>
    <p class="line_zh">为了证明这一点，让我们考虑两组儿童的分区。</p>
    <p class="">Of course there are much more partitions than that.</p>
    <p class="line_zh">当然，有更多的分区。</p>
    <p class="">We can divide them in two, three, four, and so on.</p>
    <p class="line_zh">我们可以将它们分成两个，三个，四个等等。</p>
    <p class="">Much more groups.</p>
    <p class="line_zh">更多的团体。</p>
    <p class="">But, let's just consider partitions in two groups and prove that even the number of such partitions is already at least
        two to the power of n.</p>
    <p class="line_zh">但是，让我们只考虑两组中的分区，并证明即使这样的分区数量已经至少是n的幂的两倍。</p>
    <p class="">Really, if C is a union of two groups, G1 and G2, then basically we can make such partition for any G1 which is a subset
        of such C of all children.</p>
    <p class="line_zh">实际上，如果C是两个组G1和G2的联合，那么基本上我们可以对任何G1进行这样的分区，这是所有孩子的这种C的子集。</p>
    <p class="">For any G1, just make group G2 containing all the children which are not in the first group.</p>
    <p class="line_zh">对于任何G1，只需使组G2包含不在第一组中的所有子项。</p>
    <p class="">And then all the children will be divided into these two groups.</p>
    <p class="line_zh">然后所有的孩子将分为这两组。</p>
    <p class="">So, now the size of the set of all children is n.</p>
    <p class="line_zh">所以，现在所有孩子的大小都是n。</p>
    <p class="">And if you want to compute the number of possible groups G1 then we should note that each item of the set, or each child,
        can be either included or excluded from the group G1.</p>
    <p class="line_zh">如果你想计算可能的组G1的数量，那么我们应该注意，该组或每个孩子的每个项目可以包括在G1组中或从组G1中排除。</p>
    <p class="">So, there can be 2 to the power of n different groups G1.</p>
    <p class="line_zh">因此，n个不同组G1的功率可以为2。</p>
    <p class="">And so there are at least 2 to the power of n partitions of the set of all children in two groups.</p>
    <p class="line_zh">因此，两组中所有孩子的n个分区的权力至少为2。</p>
    <p class="">and it means that our algorithm will do at least 2 to the power of n operations because this considers every partition.</p>
    <p class="line_zh">这意味着我们的算法将至少执行2次n次操作的功能，因为这会考虑每个分区。</p>
    <p class="">Among all the partitions, there are all the partitions into two groups.</p>
    <p class="line_zh">在所有分区中，将所有分区分为两组。</p>
    <p class="">So, how long will it actually work? We see that the Naive algorithm works in time Omega (2n), so it makes at least 2
        to the power of n operations.</p>
    <p class="line_zh">那么，它实际工作多长时间？我们看到Naive算法在时间Omega（2n）中工作，因此它使n次操作的功率至少为2。</p>
    <p class="">And for example for just 50 children this is at least 2 to the power of 50 or the larges number which is on the slide.</p>
    <p class="line_zh">例如，对于仅50个孩子，这至少是2的50的幂或幻灯片上的大数。</p>
    <p class="">This is the number of operations that we will need to make and I estimate that on a regular computer, this will take
        at least two weeks for you to compute this if this was exactly the number of operations that you would need.</p>
    <p class="line_zh">这是我们需要进行的操作次数，我估计在普通计算机上，如果这正是您需要的操作数，则至少需要两周的时间才能计算出来。</p>
    <p class="">So, it works really, really slow.</p>
    <p class="line_zh">所以，它真的非常慢。</p>
    <p class="">But in the next lesson we will improve this significantly.</p>
    <p class="line_zh">但在下一课中，我们将大大改善这一点。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 24 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_24">第02章 efficient algorithm for grouping children
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02分组儿童的有效算法</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hi, in this lesson you will learn how to solve the problem of organizing children into groups more efficiently.</p>
    <p class="line_zh">嗨，在本课中，您将学习如何更有效地解决将儿童组织成团体的问题。</p>
    <p class="">Most specifically, we will come up with a polynomial time algorithm for this problem as opposed to the exponential type
        algorithm from the previous lesson.</p>
    <p class="line_zh">最具体地说，我们将针对此问题提出一种多项式时间算法，而不是上一课中的指数型算法。</p>
    <p class="">But in order to do this, we first need to do a very important thing that you should probably do every time before solving
        an algorithmic problem.</p>
    <p class="line_zh">但是为了做到这一点，我们首先需要做一个非常重要的事情，你应该在解决算法问题之前每次都做。</p>
    <p class="">You should reformulate it in mathematical terms.</p>
    <p class="line_zh">你应该用数学术语重新表述它。</p>
    <p class="">For example, in this problem we will consider points on the line instead of children.</p>
    <p class="line_zh">例如，在这个问题中，我们将考虑线上的点而不是孩子。</p>
    <p class="">For example, if we have a child of age three and a half years we will instead consider a point on the line with coordinate
        3.5 and if we have another child of age 6, we will instead consider a point with coordinate 6 on the line.</p>
    <p class="line_zh">例如，如果我们有一个三岁半的孩子，我们将考虑坐标3.5上的一个点，如果我们有另一个6岁的孩子，我们将考虑一个坐标为6的点。</p>
    <p class="">Now, what do groups of children correspond to? If we have a group of children, it consists of several children and several
        points on the line correspond to this group and the fact that the age of any two children in the group differs by
        at most one, means that there exists a segment of length one on this line that contains all those points.</p>
    <p class="line_zh">现在，孩子群体对应的是什么？如果我们有一组孩子，它由几个孩子组成，并且该行上的几个点对应于该组，并且该组中任何两个孩子的年龄最多相差一个这一事实意味着存在一段长度这一行包含所有这些点。</p>
    <p class="">Now the goal becomes to select the minimum possible number of segments of length one, such that those segments cover
        all the points.</p>
    <p class="line_zh">现在，目标是选择长度为1的最小可能段数，使得这些段覆盖所有点。</p>
    <p class="">Then, if we have such segments, we can just take all the points from that segment in the same group, and any two children
        in the group who differ by, at most, one year.</p>
    <p class="line_zh">然后，如果我们有这样的片段，我们可以从同一组中的该片段获取所有点，并且该组中的任何两个孩子最多相差一年。</p>
    <p class="">Now let's look at an example.</p>
    <p class="line_zh">现在让我们看一个例子。</p>
    <p class="">We have a line with a few points on it and we want to cover all the points with segments of length one.</p>
    <p class="line_zh">我们有一条线上有几个点，我们希望用长度为1的段覆盖所有点。</p>
    <p class="">Here is one example of such covering.</p>
    <p class="line_zh">这是这种覆盖的一个例子。</p>
    <p class="">All the segments on the picture are of the same length and we consider that this is length one of this line.</p>
    <p class="line_zh">图片上的所有段都具有相同的长度，我们认为这是该行的长度之一。</p>
    <p class="">This is not the optimal solution because below there is another example of covering and we have only three segments and
        they still cover all the points.</p>
    <p class="line_zh">这不是最佳解决方案，因为下面还有另一个覆盖示例，我们只有三个段，它们仍然覆盖所有点。</p>
    <p class="">Now we want to find a way to find the minimum possible number of segments to cover all the points in any configuration.</p>
    <p class="line_zh">现在，我们想要找到一种方法来查找最小可能的段数，以涵盖任何配置中的所有点。</p>
    <p class="">We want to do that using greedy algorithm and you probably remember from the previous lessons that to come up with a
        greedy algorithm, you need to do a greedy choice and to prove that this greedy choice is a safe move.</p>
    <p class="line_zh">我们希望使用贪婪算法来做到这一点，你可能记得从以前的教训中得出一个贪婪的算法，你需要做一个贪婪的选择，并证明这个贪婪的选择是一个安全的举动。</p>
    <p class="">I state that in this problem, safe move is to cover the leftmost point with a segment of length one which starts or has
        left end in this point.</p>
    <p class="line_zh">我声明在这个问题中，安全移动是用一个长度为1的段来覆盖最左边的点，该段在此点开始或已经结束。</p>
    <p class="">To prove that this is really a safe move, we need to prove that there exists an optimal solution with the minimum possible
        number of unit length segments such that one of the segments has its left end in the leftmost point.</p>
    <p class="line_zh">为了证明这确实是一个安全的举动，我们需要证明存在一个最佳解决方案，其中单位长度段的最小可能数量使得其中一个段的左端位于最左边的点。</p>
    <p class="">Let's prove that.</p>
    <p class="line_zh">让我们证明一下。</p>
    <p class="">To do that, let's consider any optimal solution of a given problem with a given point.</p>
    <p class="line_zh">为此，让我们考虑给定点的给定问题的任何最优解。</p>
    <p class="">Let's consider the leftmost point colored in green.</p>
    <p class="line_zh">让我们考虑最左边的点是绿色的。</p>
    <p class="">It is covered by some segment.</p>
    <p class="line_zh">它被某些部分覆盖。</p>
    <p class="">Colored in red.</p>
    <p class="line_zh">红色。</p>
    <p class="">Now, let's move this red segment to the right until it's left end is in this leftmost point.</p>
    <p class="line_zh">现在，让我们将这个红色部分向右移动，直到它的左端位于这个最左边的点。</p>
    <p class="">I say that we didn't miss any of the points in the process, because this green point is the leftmost point so there are
        no points to the left from it and while we are moving the segment to the right, we didn't miss any of the points.</p>
    <p class="line_zh">我说我们没有错过这个过程中的任何一点，因为这个绿点是最左边的点，所以左边没有点，当我们向右移动段时，我们没有错过任何一点。</p>
    <p class="">It means that what we have now is still a correct covering because all of the points are still covered and the number
        of segments in this covering is the same as in some optimal solution from which we started and that means that it
        is also an optimal covering.</p>
    <p class="line_zh">这意味着我们现在所拥有的仍然是一个正确的覆盖，因为所有的点仍然被覆盖，并且这个覆盖中的段的数量与我们开始的一些最佳解决方案中的段数相同，这意味着它也是最佳覆盖。</p>
    <p class="">So we have just found an optimal solution in which there is a segment which starts in the leftmost point.</p>
    <p class="line_zh">所以我们刚刚找到了一个最优解，其中有一个段从最左边开始。</p>
    <p class="">So, we proved that covering the leftmost point with a segment which starts in it is a safe move.</p>
    <p class="line_zh">因此，我们证明用一个从其开始的片段覆盖最左边的点是一个安全的举动。</p>
    <p class="">Now that we have a safe move, let's consider what happens after it.</p>
    <p class="line_zh">现在我们已经安全行动，让我们考虑一下之后会发生什么。</p>
    <p class="">We have the leftmost point covered, and also maybe some other points covered.</p>
    <p class="line_zh">我们覆盖了最左边的点，也可能包含其他一些要点。</p>
    <p class="">So we don't need to consider these points anymore.</p>
    <p class="line_zh">所以我们不再需要考虑这些点了。</p>
    <p class="">We are not interested in them and we need to cover all the other points with the minimum possible number of unit length
        segments.
    </p>
    <p class="line_zh">我们对它们不感兴趣，我们需要用尽可能少的单位长度段来覆盖所有其他点。</p>
    <p class="">So this is the same kind of problem which we started with, so this is a subproblem.</p>
    <p class="line_zh">所以这是我们开始的同类问题，所以这是一个子问题。</p>
    <p class="">Basically it means that we have a greedy algorithm.</p>
    <p class="line_zh">基本上它意味着我们有一个贪婪的算法。</p>
    <p class="">First, make a safe move.</p>
    <p class="line_zh">首先，采取安全行动。</p>
    <p class="">Add a segment to the solution with the left hand starting in the leftmost point.</p>
    <p class="line_zh">将一个段添加到解决方案中，左手从最左边的点开始。</p>
    <p class="">Then remove all the points which are already covered by the segment from the set and if there are still points left,
        repeat the process and repeat this process until there are no points left in the set.</p>
    <p class="line_zh">然后从集合中删除段已经覆盖的所有点，如果还有剩余点，则重复该过程并重复此过程，直到集合中没有剩余点。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 25 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_25">第03章 analysis and implementation of the efficient algorithm
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">03分析和实现高效算法</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Now let us consider the pseudocode that implements this algorithm.</p>
    <p class="line_zh">现在让我们考虑实现此算法的伪代码。</p>
    <p class="">For the sake of simplicity we assume that the points in the input are given in sorted order from smallest to largest.</p>
    <p class="line_zh">为简单起见，我们假设输入中的点以从最小到最大的排序顺序给出。</p>
    <p class="">We'll start with an empty set of segments denoted by R and we start with index i pointing at the first point which is
        the leftmost because the points are sorted.</p>
    <p class="line_zh">我们将从一个由R表示的空段开始，我们从索引i开始，指向最左边的第一个点，因为这些点是排序的。</p>
    <p class="">Now we go through the points, and we find the leftmost point.</p>
    <p class="line_zh">现在我们通过这些点，找到最左边的点。</p>
    <p class="">Currently i is pointing to the leftmost point in the set.</p>
    <p class="line_zh">目前我指向集合中最左边的点。</p>
    <p class="">And at the start of the while loop i will always point to the leftmost point which is still in the set.</p>
    <p class="line_zh">在while循环开始时，我将始终指向仍在集合中的最左边的点。</p>
    <p class="">Now we cover it with the segment from l to r which has unit length, and the left end in the point xi, so this is a segment
        from xi to xi+1.</p>
    <p class="line_zh">现在我们用从l到r的段来覆盖它，它具有单位长度，而左端在点xi中，所以这是从xi到xi + 1的段。</p>
    <p class="">We add this segment to the solution set, and then we need to remove all the points from the set which already covered.</p>
    <p class="line_zh">我们将此段添加到解决方案集中，然后我们需要从已经涵盖的集合中删除所有点。</p>
    <p class="">Instead of removing the points, we will just move the pointer to the right and forget about the points, which are to
        the left from the pointer.</p>
    <p class="line_zh">我们只是将指针向右移动而忘记指针左侧的点，而不是删除点。</p>
    <p class="">So the next while loop, does exactly that.</p>
    <p class="line_zh">所以下一个while循环就是这样做的。</p>
    <p class="">We know that for any i that is larger than the current i, xi is to the right from the left end of the segment, because
        the points are sorted.</p>
    <p class="line_zh">我们知道，对于任何大于当前i的i，xi是从段的左端开始的右边，因为这些点是排序的。</p>
    <p class="">So if xi is also to the left from R, then it is covered by the segment.</p>
    <p class="line_zh">因此，如果xi也位于R的左侧，那么它将被段覆盖。</p>
    <p class="">So we just go to the right, and to the right with pointer i.</p>
    <p class="line_zh">所以我们只用指针i向右移动到右边。</p>
    <p class="">And while xi is less than or equal to r, we know that the point is covered.</p>
    <p class="line_zh">虽然xi小于或等于r，但我们知道这一点已被涵盖。</p>
    <p class="">And as soon as we find some xi which is bigger than r, it means that this point is not covered and all the points further
        in the array are also not covered.</p>
    <p class="line_zh">一旦我们发现一些大于r的xi，就意味着这个点没有被覆盖，并且数组中的所有点也没有被覆盖。</p>
    <p class="">So we stop.</p>
    <p class="line_zh">所以我们停下来。</p>
    <p class="">And then we repeat again the iteration of the outer while loop.</p>
    <p class="line_zh">然后我们再次重复外部while循环的迭代。</p>
    <p class="">Or maybe our pointer i is already out of the array of the input points.</p>
    <p class="line_zh">或许我们的指针i已经超出了输入点的数组。</p>
    <p class="">And then we stop and return R, which is the set of segments that we've built in the process.</p>
    <p class="line_zh">然后我们停止并返回R，这是我们在流程中构建的一组段。</p>
    <p class="">Now let's prove that this algorithm works in linear time.</p>
    <p class="line_zh">现在让我们证明这个算法在线性时间内工作。</p>
    <p class="">Indeed, index i changes just from 1 to n.</p>
    <p class="line_zh">实际上，索引i从1变为n。</p>
    <p class="">And we always increase it by one.</p>
    <p class="line_zh">我们总是把它增加一个。</p>
    <p class="">For each value of i, we add at most one segment to the solution.</p>
    <p class="line_zh">对于i的每个值，我们最多将一个段添加到解决方案中。</p>
    <p class="">So overall, we increase i at most n times and add at most n segments to the solution.</p>
    <p class="line_zh">总的来说，我们最多增加i次n次，并且最多将n个段添加到解决方案中。</p>
    <p class="">And this leads to a solution which works in Big-O of n time.</p>
    <p class="line_zh">这导致了一个解决方案，它可以在大时间内运行。</p>
    <p class="">Now, we had an assumption that the points in the input are already sorted.</p>
    <p class="line_zh">现在，我们假设输入中的点已经排序。</p>
    <p class="">What if we drop this assumption? Then we will have to sort the points first, and then apply our algorithm PointsCoverSorted.</p>
    <p class="line_zh">如果我们放弃这个假设怎么办？然后我们将首先对点进行排序，然后应用我们的算法PointsCoverSorted。</p>
    <p class="">Later in this module, you will learn how to sort points in time n log n.</p>
    <p class="line_zh">稍后在本单元中，您将学习如何对时间n log n中的点进行排序。</p>
    <p class="">Combining that with our procedure PointsCoverSorted will give you total running time of n log n.</p>
    <p class="line_zh">将它与我们的程序PointsCoverSorted结合使用，可以得到n log n的总运行时间。</p>
    <p class="">Now let's look at our improvement.</p>
    <p class="line_zh">现在让我们来看看我们的改进。</p>
    <p class="">We first implemented a straightforward solution, which worked in time at least 2 to the power of n.</p>
    <p class="line_zh">我们首先实现了一个简单的解决方案，它在时间上至少能达到2的幂。</p>
    <p class="">And it worked very, very slowly.</p>
    <p class="line_zh">它的工作非常非常缓慢。</p>
    <p class="">So that even for 50 children, we would have to spend at least 2 weeks of computation to group them.</p>
    <p class="line_zh">因此，即使对于50个孩子，我们也必须花费至少2周的时间来对它们进行分组。</p>
    <p class="">Our new algorithm, however, works in n log n time.</p>
    <p class="line_zh">然而，我们的新算法在n log n时间内工作。</p>
    <p class="">And that means that even if we had 10 million children coming to a party, it would spend only a few seconds grouping
        them optimally into several groups.</p>
    <p class="line_zh">这意味着，即使我们有1000万儿童参加聚会，也只需要几秒钟就可以将他们最佳地分组到几个小组中。</p>
    <p class="">So that's a huge improvement.</p>
    <p class="line_zh">这是一个巨大的进步。</p>
    <p class="">Now let's see how we went to this end.</p>
    <p class="line_zh">现在让我们看看我们是如何实现这一目标的。</p>
    <p class="">First, we've invented a naive solution which worked in exponential time.</p>
    <p class="line_zh">首先，我们发明了一种在指数时间内起作用的天真解决方案。</p>
    <p class="">It was too slow for us so we wanted to improve it.</p>
    <p class="line_zh">这对我们来说太慢了，所以我们想改进它。</p>
    <p class="">But to improve it, the very first important step was to reformulate it in mathematical terms.</p>
    <p class="line_zh">但要改进它，第一个重要的步骤是用数学术语重新表述它。</p>
    <p class="">And then we had an idea to solve it with a greedy algorithm.</p>
    <p class="line_zh">然后我们有了一个用贪心算法解决它的想法。</p>
    <p class="">So, we had to find some greedy choice and prove that it will be a safe move.</p>
    <p class="line_zh">因此，我们必须找到一些贪婪的选择，并证明这将是一个安全的举措。</p>
    <p class="">In this case, the safe move turns out to be to add to the solution a segment with left and in the leftmost point.</p>
    <p class="line_zh">在这种情况下，安全移动结果是向解决方案添加左侧和最左侧点的段。</p>
    <p class="">And then we prove that this is really a safe move.</p>
    <p class="line_zh">然后我们证明这确实是一个安全的举措。</p>
    <p class="">It is very important to prove your solutions before even trying to implement them.</p>
    <p class="line_zh">在尝试实施它们之前证明您的解决方案非常重要。</p>
    <p class="">Because otherwise, it could turn out that you implemented the solution, tried to submit it, got wrong answer or some
        other result, different from accepted.</p>
    <p class="line_zh">因为否则，可能会导致您实施解决方案，尝试提交，得到错误答案或其他一些与接受不同的结果。</p>
    <p class="">And then, you've made a few more changes, but it still didn't work.</p>
    <p class="line_zh">然后，你做了一些更改，但它仍然没有用。</p>
    <p class="">And then, you understand that your solution was wrong, completely from the start.</p>
    <p class="line_zh">然后，您从一开始就明白您的解决方案是错误的。</p>
    <p class="">And then you need a new solution, and you will have to implement it from scratch.</p>
    <p class="line_zh">然后你需要一个新的解决方案，你必须从头开始实现它。</p>
    <p class="">And that means that you've wasted all the time on implementation on the first wrong solution.</p>
    <p class="line_zh">这意味着你在第一个错误的解决方案上一直浪费在实施上。</p>
    <p class="">To avoid that, you should always prove your solution first.</p>
    <p class="line_zh">为避免这种情况，您应该首先证明您的解决方案。</p>
    <p class="">So after we've proved the safe move, we basically got our greedy solution.</p>
    <p class="line_zh">因此，在我们证明安全行动之后，我们基本上得到了贪婪的解决方案。</p>
    <p class="">Which works in combination with a certain algorithm in time n log n.</p>
    <p class="line_zh">它与时间n log n中的某个算法结合使用。</p>
    <p class="">Which is not only polynomial, but is very close to linear time, and works really fast in practice.</p>
    <p class="line_zh">这不仅是多项式，而且非常接近线性时间，并且在实践中工作得非常快。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 26 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_26">第01章 long hike
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01长途徒步旅行</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello.</p>
    <p class="line_zh">你好。</p>
    <p class="">In this lesson, you will learn an algorithm to determine which food items and in which amounts should you take with yourself
        on a really long hike so that to maximize their total energy value.</p>
    <p class="line_zh">在本课程中，您将学习一种算法，以确定您应该在非常长的徒步旅行中自己采取哪些食物和量，以便最大化其总能量值。</p>
    <p class="">So, you're planning a long hike.</p>
    <p class="line_zh">所以，你计划长途跋涉。</p>
    <p class="">It will take a few days or maybe a few weeks, but you don't know exactly how long will it take.</p>
    <p class="line_zh">这将需要几天或几周，但你不知道它需要多长时间。</p>
    <p class="">So, to be safe, you need to get enough food with you.</p>
    <p class="line_zh">所以，为了安全起见，你需要随身携带足够的食物。</p>
    <p class="">And you have a knapsack which can fit up to 15 kilograms of food in it.</p>
    <p class="line_zh">你有一个背包，可以容纳15公斤的食物。</p>
    <p class="">And you've already bought some cheese, some ham, some nuts, and maybe some other food items.</p>
    <p class="line_zh">你已经买了一些奶酪，一些火腿，一些坚果，还有一些其他食品。</p>
    <p class="">You want to fit them all in the knapsack, so as to maximize the amount of calories that you can get from them.</p>
    <p class="line_zh">你想把它们全部放在背包中，以便最大化你可以从它们获得的卡路里量。</p>
    <p class="">Of course you can cut the cheese.</p>
    <p class="line_zh">当然你可以切奶酪。</p>
    <p class="">You can cut the ham.</p>
    <p class="line_zh">你可以切火腿。</p>
    <p class="">You can select only some of the nuts.</p>
    <p class="line_zh">您只能选择一些坚果。</p>
    <p class="">And then fit all of that into your knapsack.</p>
    <p class="line_zh">然后将所有这些都装进你的背包里。</p>
    <p class="">To solve this maximization problem, we again need to first reformulate it in mathematical terms.</p>
    <p class="line_zh">为了解决这个最大化问题，我们再次需要首先用数学术语重新表述它。</p>
    <p class="">And then it becomes an instance of a classical fractional knapsack problem, which goes like this.</p>
    <p class="line_zh">然后它成为经典的分数背包问题的一个例子，就像这样。</p>
    <p class="">We have n items with weights w1 through wn and values v1 though vn.</p>
    <p class="line_zh">我们有n个项目的权重为w1到wn，值为v1到vn。</p>
    <p class="">And a bag of capacity big W.</p>
    <p class="">还有一袋大容量的W.</p>
    <p class="">And we want to maximize the total value of fractions of items that fit into this bag.</p>
    <p class="line_zh">我们希望最大化适合此包的物品分数的总价值。</p>
    <p class="">In this case, weights are also weights in the real life and values are the energy values of the food items that you've
        bought.
    </p>
    <p class="line_zh">在这种情况下，权重也是现实生活中的权重，价值是您购买的食品的能量值。</p>
    <p class="">So, here's an example, and we will denote by dollars the value of the item, and the weight just by numbers.</p>
    <p class="line_zh">所以，这是一个例子，我们将用美元表示项目的价值，而权重仅用数字表示。</p>
    <p class="">So, for example, the first item has value $20 and has weight 4, the second item has value $18 and weight 3, and the third
        item has value $14 and weight 2.</p>
    <p class="line_zh">因此，例如，第一项的价值为20美元，重量为4，第二项的价值为18美元，重量为3，第三项的价值为14美元，重量为2。</p>
    <p class="">And we have a knapsack of capacity 7.</p>
    <p class="line_zh">我们有一个容量7的背包。</p>
    <p class="">There are a few ways with which we can fill this knapsack.</p>
    <p class="line_zh">我们有几种方法可以填充这个背包。</p>
    <p class="">For example, of them is put the whole first item and the whole second item in the knapsack.</p>
    <p class="line_zh">例如，他们将整个第一项和整个第二项放在背包中。</p>
    <p class="">Then the total value is the sum of the values of the first item and the second, which is $38.</p>
    <p class="line_zh">然后总值是第一项和第二项的值之和，即$ 38。</p>
    <p class="">We can improve on that.</p>
    <p class="line_zh">我们可以改进。</p>
    <p class="">For example, take the whole first item, the whole third item, and only one third of the second item for a total value
        of $40.</p>
    <p class="line_zh">例如，取整个第一个项目，整个第三个项目，以及第二个项目的三分之一，总价值为40美元。</p>
    <p class="">We can do even better by taking the whole third item, the whole second item, and only half of the first item, and that
        will give us $42.</p>
    <p class="line_zh">我们可以通过整个第三项，第二项，只有第一项的一半来做得更好，这将给我们42美元。</p>
    <p class="">And actually it turns out that this is the optimal thing to do.</p>
    <p class="line_zh">事实证明，这是最佳选择。</p>
    <p class="">So now we want to create a greedy algorithm that will solve this maximization problem, and we need to get some greedy
        choice and make a safe move.</p>
    <p class="line_zh">所以现在我们想要创建一个贪婪算法来解决这个最大化问题，我们需要得到一些贪婪的选择并做出安全的行动。</p>
    <p class="">And to do that, we have to look at the value per unit of weight.</p>
    <p class="line_zh">要做到这一点，我们必须考虑每单位重量的价值。</p>
    <p class="">So, for example for the first item, value per unit of weight is $5, for the second item, it's $6 per unit, and for the
        third one it's $7 per unit.</p>
    <p class="line_zh">因此，例如对于第一项，每单位重量的价值是5美元，对于第二项，每单位6美元，而对于第三项，每单位7美元。</p>
    <p class="">So although the first item is most valuable, the third item has the maximum value per unit.</p>
    <p class="line_zh">因此，虽然第一项是最有价值的，但第三项具有每单位的最大值。</p>
    <p class="">And of course there is an intuition that we should probably fit first the items with the maximum value per unit.</p>
    <p class="line_zh">当然，有一种直觉，我们应该首先适合每单位最大值的项目。</p>
    <p class="">And really, the safe move is to first try to fit the item with the maximum value per unit.</p>
    <p class="line_zh">实际上，安全的举措是首先尝试使每单位的最大值适合项目。</p>
    <p class="">And there's a lemma that says that there always exists some optimal solution to our problem that uses as much as possible
        of an item with the maximum value per unit of weight.</p>
    <p class="line_zh">并且有一个引理说，我们的问题始终存在一些最佳解决方案，它尽可能地使用具有每单位重量最大值的项目。</p>
    <p class="">And what do we mean by as much as possible? Well, either use the whole item, if it fits into the knapsack, or, if the
        capacity of the knapsack is less than how much we have of this item, then just fill the whole knapsack only with
        this item.</p>
    <p class="line_zh">我们的意思是什么？好吧，要么使用整个项目，如果它适合背包，或者，如果背包的容量小于我们对这个项目的容量，那么只需用这个项目填充整个背包。</p>
    <p class="">Let's prove that this is really a safe move.</p>
    <p class="line_zh">让我们证明这确实是一个安全的举措。</p>
    <p class="">We will prove looking at this example.</p>
    <p class="line_zh">我们将证明这个例子。</p>
    <p class="">So, first let's suppose we have some optimal solution, and let's suppose that in this optimal solution, we don't use
        as much as possible of the best item with the highest value per unit of weight.</p>
    <p class="line_zh">所以，首先让我们假设我们有一些最优的解决方案，让我们假设在这个最优解决方案中，我们不会尽可能多地使用每单位重量最高值的最佳项目。</p>
    <p class="">Then take some item which we used in this solution and separate its usage into two parts, one part of the same size of
        how much we have of the best item, and the second part is everything else.</p>
    <p class="line_zh">然后拿一些我们在这个解决方案中使用的项目，并将它的用法分成两部分，一部分是我们拥有最多项目的相同大小，第二部分是其他所有部分。</p>
    <p class="">Then we can substitute the first part with the best item.</p>
    <p class="line_zh">然后我们可以用最好的项目替换第一部分。</p>
    <p class="">So, for example, in this case, we substitute half of the first item with second item.</p>
    <p class="line_zh">因此，例如，在这种情况下，我们用第二项替换第一项的一半。</p>
    <p class="">Of course, in this part, the total value will increase, because the value per unit of weight is better for the best item
        than for the item currently used.</p>
    <p class="line_zh">当然，在这部分中，总价值会增加，因为每单位重量的价值对于最佳商品而言比对于当前使用的商品更好。</p>
    <p class="">And in the general case, this will also work.</p>
    <p class="line_zh">在一般情况下，这也将起作用。</p>
    <p class="">So, either we will be able to replace some part of the item already used by the whole best item, or we can replace the
        whole item that is already used by some part of the best item.</p>
    <p class="line_zh">因此，要么我们将能够替换整个最佳项目已经使用的项目的某些部分，要么我们可以替换最佳项目的某些部分已经使用的整个项目。</p>
    <p class="">And in any case, if we can make such a substitution, of course the total value will increase, because the best item just
        has better value per unit of weight, so for each unit of weight, we will have more value.</p>
    <p class="line_zh">在任何情况下，如果我们可以进行这样的替换，当然总价值会增加，因为最好的项目每单位重量只有更好的价值，所以对于每个重量单位，我们将有更多的价值。</p>
    <p class="">So this gives us a greedy algorithm to solve our problem.</p>
    <p class="line_zh">所以这给了我们一个贪婪的算法来解决我们的问题。</p>
    <p class="">What we'll do is while knapsack is still not full, we will do a greedy choice.</p>
    <p class="line_zh">我们要做的是背包仍未满，我们将做一个贪婪的选择。</p>
    <p class="">We will choose the item number i which has the maximum value of vi over wi, which is the value per unit of weight.</p>
    <p class="line_zh">我们将选择项目编号i，其最大值为vi而不是wi，即每单位重量的值。</p>
    <p class="">And then if this item fits into knapsack fully, then take of all this item.</p>
    <p class="line_zh">然后，如果这个项目完全适合背包，那么拿走所有这个项目。</p>
    <p class="">Otherwise, if there is only few space left in the knapsack, take so much of this item as to fill the knapsack to the
        end.
    </p>
    <p class="line_zh">否则，如果背包中只剩下很少的空间，那么就把这个项目当作填充背包到底。</p>
    <p class="">And then in the end, we'll return the total value of the items that we took and how much did we take of each item.</p>
    <p class="line_zh">然后最后，我们将返回我们拍摄的项目的总价值以及我们对每个项目的评价。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 27 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_27">第02章 fractional knapsack implementation analysis and optimization
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02分数背包实施分析和优化</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hi.</p>
    <p class="line_zh">你好。</p>
    <p class="">In this lesson you will learn how to implement the Greedy Algorithm for the Fractional Knapsack.</p>
    <p class="line_zh">在本课中，您将学习如何实现分数背包的贪婪算法。</p>
    <p class="">How to estimate its running time and how to improve its asymptotics.</p>
    <p class="line_zh">如何估计其运行时间以及如何改进其渐近性。</p>
    <p class="">Here is the description of the greedy algorithm from the previous lesson.</p>
    <p class="line_zh">以下是上一课中贪婪算法的描述。</p>
    <p class="">While knapsack is still not full, we select the best item left.</p>
    <p class="line_zh">虽然背包仍然没有装满，但我们选择了最好的项目。</p>
    <p class="">The one with the highest value per unit of weight.</p>
    <p class="line_zh">每单位重量值最高的那个。</p>
    <p class="">And either fit all of this item in the knapsack or if there is only few space left in the knapsack, cut this item and
        fit as much as you can in what's left in the knapsack, and then repeat this process until the knapsack is full.</p>
    <p class="line_zh">并且要么在背包中放置所有这个项目，要么背包中只留下很少的空间，切割这个项目并尽可能多地放在背包里留下的东西，然后重复这个过程直到背包充满。</p>
    <p class="">In the end return the total value of the items taken and the amounts taken.</p>
    <p class="line_zh">最后返回所采用物品的总价值和所采取的金额。</p>
    <p class="">We've proven that the selection of best item is a safe move.</p>
    <p class="line_zh">我们已经证明，选择最佳项目是一个安全的举措。</p>
    <p class="">Then after we've selected the best item what we've got left is a knapsack with a capacity which is less, but the problem
        is the same: you have some items and you have a knapsack of some capacity and you should fill it optimally so as
        to maximize the total value of the items that fit.</p>
    <p class="line_zh">然后，在我们选择了最好的项目后，我们剩下的是一个容量较小的背包，但问题是相同的：你有一些物品，你有一些容量的背包，你应该最好地填充它以便最大化适合的项目的总价值。</p>
    <p class="">So this greedy algorithm really works.</p>
    <p class="line_zh">所以这个贪婪的算法确实有效。</p>
    <p class="">Now let's implement it.</p>
    <p class="line_zh">现在让我们来实现它。</p>
    <p class="">Here we have a procedure called Knapsack.</p>
    <p class="line_zh">这里我们有一个名为Knapsack的程序。</p>
    <p class="">It starts with filling the array A with amounts of items taken with 0 and the total value we also initialize to 0 and
        then, as we said on the slide, we repeat for n times the following iterations.</p>
    <p class="line_zh">它首先填充数组A，其中项目的数量为0，总值也初始化为0，然后，正如我们在幻灯片中所说，我们重复n次以下迭代。</p>
    <p class="">If the knapsack is already full than in the variable W, we will have 0 because in the start we have in the variable W
        the total capacity of the knapsack, but each time we will put something in the knapsack, we will update W will decrease
        it by the amount of weight that we put already in.</p>
    <p class="line_zh">如果背包已经满了比变量W，我们将有0因为在开始时我们在变量W中有背包的总容量，但每次我们将把东西放在背包里，我们会更新W会减少它是我们已经投入的重量。</p>
    <p class="">And so in the end, when the knapsack is full, W will be 0.</p>
    <p class="line_zh">最后，当背包已满时，W将为0。</p>
    <p class="">If W became 0, it means that we should just return the total value and the amounts of the items that we took.</p>
    <p class="line_zh">如果W变为0，则意味着我们应该返回总价值和我们采取的项目数量。</p>
    <p class="">Otherwise we should select the best item.</p>
    <p class="line_zh">否则我们应该选择最好的项目。</p>
    <p class="">The best item is the item which is still left so, wi is more than 0 and out of such items, it's the item with the maximum
        value per weight, so the one which maximizes vi over wi.</p>
    <p class="line_zh">最好的项目是仍然保留的项目，wi大于0且超出这些项目，它是具有每个权重的最大值的项目，因此是最大化vi而不是wi的项目。</p>
    <p class="">When we've selected the i, we determine the amount which will it take, it is either the whole wi, the whole of this item
        if it fits in the knapsack.</p>
    <p class="line_zh">当我们选择了i时，我们确定它将采取的数量，它是整个wi，如果它适合背包，则整个这个项目。</p>
    <p class="">Otherwise, if the capacity of the knapsack is already less, then we just fill it up to the end.</p>
    <p class="line_zh">否则，如果背包的容量已经减少了，那么我们就把它填满到最后。</p>
    <p class="">So A is minimum of wi and big W.</p>
    <p class="">所以A是最小的wi和大W.</p>
    <p class="">After we select the amount, we just update all the variables.</p>
    <p class="line_zh">选择金额后，我们只更新所有变量。</p>
    <p class="">So we update wi by decreasing it by a, because we took already a of this item.</p>
    <p class="line_zh">所以我们通过减少a来更新wi，因为我们已经使用了这个项目。</p>
    <p class="">We're also increased the amount A of i corresponding to the item number i by the value A.</p>
    <p class="">我们还通过值A增加了对应于项目编号i的i的量A.</p>
    <p class="">And we'll also decrease the capacity left, because we just decrease it by A.</p>
    <p class="">而且我们还会减少剩余的容量，因为我们只是将它减少了A.</p>
    <p class="">By putting it A of item i.</p>
    <p class="line_zh">把它作为项目i的A。</p>
    <p class="">Also we increase value V by this formula: a multiplied by vi and divided by wi.</p>
    <p class="line_zh">我们也通过这个公式增加值V：乘以vi并除以wi。</p>
    <p class="">Why is that? Because we took A of item number i, we took A units and one unit brings us amount of value equal to vi over
        wi.
    </p>
    <p class="line_zh">这是为什么？因为我们拿了项目编号i的A，我们拿了A个单位，一个单位给我们带来的价值等于vi而不是wi。</p>
    <p class="">So if you take A units, the total value by these items, a multiplied by vi and divided by wi.</p>
    <p class="line_zh">因此，如果你取A单位，这些项的总价值，乘以vi除以wi。</p>
    <p class="">After we do n iterations, or maybe less, if the knapsack is full before we do all n iterations, we'll return the total
        value and the amounts in the array.</p>
    <p class="line_zh">在我们进行n次迭代之后，或者更少，如果在我们进行所有n次迭代之前背包已满，我们将返回总值和数组中的数量。</p>
    <p class="">Now the running time of this algorithm is Big-O of n squared.</p>
    <p class="line_zh">现在这个算法的运行时间是n平方的Big-O。</p>
    <p class="">Why is that? Well, first we have the inner selection of best item, which works in linear time.</p>
    <p class="line_zh">这是为什么？好吧，首先我们有最佳项目的内部选择，它在线性时间内工作。</p>
    <p class="">Because basically, we have to go through all the items to select the best one.</p>
    <p class="line_zh">因为基本上，我们必须通过所有项目来选择最好的项目。</p>
    <p class="">And we have the main loop, for loop, which is executed n times at most, maybe less.</p>
    <p class="line_zh">我们有主循环，for循环，最多执行n次，可能更少。</p>
    <p class="">So in each iteration we do some linear time computation and we do this at most n times.</p>
    <p class="line_zh">所以在每次迭代中我们做一些线性时间计算，我们最多n次。</p>
    <p class="">That means that the total running time is Big-O of n squared.</p>
    <p class="line_zh">这意味着总运行时间是n平方的Big-O。</p>
    <p class="">Now we can't improve on that because if we sort the items by decreasing value of vi over wi, then it will be easier to
        select the best item which is still left.</p>
    <p class="line_zh">现在我们无法改进，因为如果我们通过减去vi的值来对项目进行排序，那么选择仍然剩下的最佳项目会更容易。</p>
    <p class="">Let's look at this pseudo code.</p>
    <p class="line_zh">我们来看看这个伪代码。</p>
    <p class="">Let's assume that we've already sorted the input items, size that v1 over w1 is, more than or equal to v2 over w2 and
        that is greater, or equal to the fraction for the next item and up to vn over wn.</p>
    <p class="line_zh">让我们假设我们已经对输入项进行了排序，v1超过w1的大小，大于或等于v2大于或等于w2，并且更大，或等于下一项的分数，直到vn大于wn。</p>
    <p class="">And we can start with the same array of amounts and the same total value filled with zeroes.</p>
    <p class="line_zh">我们可以从相同的数量数组开始，并使用零填充相同的总值。</p>
    <p class="">But then we make a for loop for i going from 1 to n.</p>
    <p class="line_zh">但是接着我们从1到n进行for循环。</p>
    <p class="">And on each iteration i will be the best unit which is still left.</p>
    <p class="line_zh">在每次迭代中，我将是仍然离开的最佳单位。</p>
    <p class="">So on the start of the iteration we check whether we still have some capacity in the knapsack.</p>
    <p class="line_zh">因此，在迭代开始时，我们检查我们是否仍然在背包中有一些容量。</p>
    <p class="">If it is already filled we just return the answer.</p>
    <p class="line_zh">如果它已经填满，我们只返回答案。</p>
    <p class="">Otherwise we know that i is the best item because we didn't consider it previously and it is the item with the maximum
        value per unit out of those which we didn't consider before.</p>
    <p class="line_zh">否则我们知道我是最好的项目，因为我们以前没有考虑过这个项目，而且它是我们之前没有考虑过的每单位最大价值的项目。</p>
    <p class="">So we determine the amount of this item with the same formula and we update the weights, the amounts, the capacity, and
        the total value in the same way as we did in the previous pseudocode.</p>
    <p class="line_zh">因此，我们使用相同的公式确定此项目的数量，并以与上一个伪代码相同的方式更新权重，数量，容量和总值。</p>
    <p class="">The only change is that we change the order in which we consider the items.</p>
    <p class="line_zh">唯一的变化是我们改变了我们考虑项目的顺序。</p>
    <p class="">And this allows us to make each iteration in constant time instead of linear time.</p>
    <p class="line_zh">这使我们能够以恒定时间而不是线性时间进行每次迭代。</p>
    <p class="">So, this new algorithm now works in linear time, because it has at most n iterations, and each iteration works at most
        in constant time.</p>
    <p class="line_zh">因此，这种新算法现在可以在线性时间内工作，因为它最多只有n次迭代，并且每次迭代最多可以在恒定时间内工作。</p>
    <p class="">So, if we apply first some sorting algorithm to sort items by decreasing value of vi over wi.</p>
    <p class="line_zh">因此，如果我们首先应用一些排序算法来通过减少vi的值来对项目进行排序。</p>
    <p class="">And then apply this new knapsack procedure.</p>
    <p class="line_zh">然后应用这个新的背包程序。</p>
    <p class="">Total run time will be n log n, because sorting will work in n log n.</p>
    <p class="line_zh">总运行时间将为n log n，因为排序将在n log n中起作用。</p>
    <p class="">And the knapsack itself will work in linear time.</p>
    <p class="line_zh">背包本身将在线性时间内工作。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 28 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_28">第03章 review of greedy algorithms
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">03评论贪心算法</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hi, in this lesson, we will review what we saw in this module about greedy algorithms and specify what is common and
        important to all greedy algorithms.</p>
    <p class="line_zh">嗨，在本课中，我们将回顾一下我们在本单元中看到的关于贪婪算法的内容，并指出所有贪婪算法的常见和重要之处。</p>
    <p class="">The main ingredients of any greedy algorithm are greedy choice and reduction to a subproblem.</p>
    <p class="line_zh">任何贪婪算法的主要成分是贪婪的选择和减少到子问题。</p>
    <p class="">You have to prove that your greedy choice is a safe move.</p>
    <p class="line_zh">你必须证明你贪婪的选择是一个安全的举动。</p>
    <p class="">And also, you have to check that the problem that is left after your safe move is really a subproblem.</p>
    <p class="line_zh">而且，你必须检查安全移动后留下的问题是否真的是一个子问题。</p>
    <p class="">That is, a problem of the same kind but with fewer parameters.</p>
    <p class="line_zh">也就是说，同一种问题但参数较少的问题。</p>
    <p class="">After you have both, you have a greedy algorithm.</p>
    <p class="line_zh">拥有两者后，你有一个贪心的算法。</p>
    <p class="">Then, you need to estimate its running time and check that it's good enough for you.</p>
    <p class="line_zh">然后，您需要估计其运行时间并检查它是否足够好。</p>
    <p class="">Safe moves in different problems are different.</p>
    <p class="line_zh">不同问题的安全行动是不同的。</p>
    <p class="">Basically, you have to invent something each time you have a new problem.</p>
    <p class="line_zh">基本上，每次遇到新问题时都必须发明一些东西。</p>
    <p class="">In the first problem it was, select the maximum digit and put it first.</p>
    <p class="line_zh">在第一个问题中，选择最大数字并将其放在第一位。</p>
    <p class="">In the last problem it was select the item with the maximum total value per weight.</p>
    <p class="line_zh">在最后一个问题中，选择具有每重量最大总值的项目。</p>
    <p class="">And you see that in every safe move, there's something like maximum, or minimum, or first, or leftmost, or rightmost.</p>
    <p class="line_zh">而且你会发现，在每一个安全行动中，都会有最大值或最小值，或者首先，最左边或最右边的东西。</p>
    <p class="">So, always safe move is greedy, but not all greedy moves are safe.</p>
    <p class="line_zh">所以，总是安全的举动是贪婪的，但不是所有的贪婪举动都是安全的。</p>
    <p class="">So, you really have to prove every time that the move that you invented is really safe.</p>
    <p class="line_zh">所以，你必须每次证明你发明的这一举动是非常安全的。</p>
    <p class="">Also, you can notice that sometimes we can optimize our initial greedy algorithm if we sort our object somehow.</p>
    <p class="line_zh">此外，您可以注意到，如果我们以某种方式对对象进行排序，有时我们可以优化我们的初始贪心算法。</p>
    <p class="">So, you can maybe try to solve problem, assuming that everything is sorted in some convenient order.</p>
    <p class="line_zh">因此，您可以尝试解决问题，假设所有内容都按照一些方便的顺序排序。</p>
    <p class="">And if you see that, because of that, your greedy algorithm can be implemented asymptotically faster, then you can just
        apply sorting first and then your greedy algorithm.</p>
    <p class="line_zh">如果你看到这一点，那么，你的贪婪算法可以渐进地实现，然后你可以先应用排序然后再应用你的贪心算法。</p>
    <p class="">The general strategy is when I have a problem, you can try to come up with some greedy choices, and then for some of
        them, you'll be able to prove that they're really safe moves.</p>
    <p class="line_zh">一般策略是当我遇到问题时，你可以尝试提出一些贪婪的选择，然后对于其中一些，你将能够证明它们是非常安全的动作。</p>
    <p class="">And if you've proven that this is a safe move, then you've reduced your problem to something.</p>
    <p class="line_zh">如果你已经证明这是一个安全的举动，那么你已经将问题减少了。</p>
    <p class="">And then you have to check that this something is a subproblem.</p>
    <p class="line_zh">然后你必须检查这个东西是一个子问题。</p>
    <p class="">That is, the problem about the same thing, optimizing the same thing with the same restrictions.</p>
    <p class="line_zh">也就是说，关于同样的事情的问题，用相同的限制优化同样的事情。</p>
    <p class="">And then, this is a subproblem.</p>
    <p class="line_zh">然后，这是一个子问题。</p>
    <p class="">And then you can solve it in the same way that you solved your initial problem.</p>
    <p class="line_zh">然后你可以用解决初始问题的方式来解决它。</p>
    <p class="">And you have this loop from problem to subproblem and back to the problem, always reducing it by the number of parameters.</p>
    <p class="line_zh">你有从问题到子问题的循环，然后回到问题，总是通过参数的数量减少它。</p>
    <p class="">And in the end of this loop, you will have a problem so simple that you can solve it right away for one object or zero
        objects.
    </p>
    <p class="line_zh">在这个循环的最后，你会遇到一个简单的问题，你可以立即解决一个对象或零对象。</p>
    <p class="">And then you have your greedy algorithm.</p>
    <p class="line_zh">然后你有你的贪心算法。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 29 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_29">第01章 intro
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01介绍</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hi, I'm Neil Rhodes.</p>
    <p class="line_zh">嗨，我是Neil Rhodes。</p>
    <p class="">Welcome to the divide and conquer module.</p>
    <p class="line_zh">欢迎来到分而治之的模块。</p>
    <p class="">In the last module, you learned about how to use greedy algorithms to solve particular classes of problems.</p>
    <p class="line_zh">在最后一个模块中，您学习了如何使用贪婪算法来解决特定类型的问题。</p>
    <p class="">In this module you'll learn about ways of solving problems using divide and conquer algorithms.</p>
    <p class="line_zh">在本单元中，您将学习使用分而治之算法解决问题的方法。</p>
    <p class="">The term divide and conquer is quite old, and when applied to war, suggests that it's easier to defeat several smaller
        groups of opponents than trying to defeat one large group.</p>
    <p class="line_zh">“分而治之”这个术语相当古老，当应用于战争时，它表明，与试图击败一个大集团相比，击败几个较小的对手组更容易。</p>
    <p class="">In a similar fashion, divide and conquer algorithms take advantage of breaking a problem down into one or more subproblems
        that can then be solved independently.</p>
    <p class="line_zh">以类似的方式，分而治之的算法利用将问题分解为一个或多个子问题，然后可以独立解决。</p>
    <p class="">Just as not all problems can be solved with a greedy algorithm, not all problems can be solved using divide and conquer.</p>
    <p class="line_zh">正如并非所有问题都可以通过贪婪算法解决，并非所有问题都可以通过分而治之来解决。</p>
    <p class="">Instead, these are both techniques that are part of a toolbox of strategies to solve problems.</p>
    <p class="line_zh">相反，这些都是技术，是解决问题的策略工具箱的一部分。</p>
    <p class="">As you're designing an algorithm, you'll need to consider whether or not a greedy algorithm might work.</p>
    <p class="line_zh">在设计算法时，您需要考虑贪婪算法是否可行。</p>
    <p class="">If not, would a divide and conquer algorithm work? Let's look at the general structure of a divide and conquer algorithm.</p>
    <p class="line_zh">如果没有，分而治之的算法会起作用吗？让我们看一下分而治之算法的一般结构。</p>
    <p class="">Here, we have a problem to be solved represented abstractly as a blue rectangle.</p>
    <p class="line_zh">在这里，我们有一个要解决的问题，抽象地表示为蓝色矩形。</p>
    <p class="">We break the problem down into a set of non-overlapping subproblems.</p>
    <p class="line_zh">我们将问题分解为一组非重叠的子问题。</p>
    <p class="">Represented here, by colored rectangles.</p>
    <p class="line_zh">这里用彩色矩形表示。</p>
    <p class="">It's important that the subproblems be of the same type as the original.</p>
    <p class="line_zh">子问题与原始问题的类型非常重要。</p>
    <p class="">For example, here's a way to break down the original rectangle problem into a set of subproblems that are not of the
        same type.</p>
    <p class="line_zh">例如，这是一种将原始矩形问题分解为一组不同类型的子问题的方法。</p>
    <p class="">These subproblems are triangles.</p>
    <p class="line_zh">这些子问题是三角形。</p>
    <p class="">Thus this does not represent the divide and conquer algorithm.</p>
    <p class="line_zh">因此，这并不代表分而治之的算法。</p>
    <p class="">In this case, we've broken down the original rectangle problem into a set of subproblems that are themselves rectangles.</p>
    <p class="line_zh">在这种情况下，我们将原始矩形问题分解为一组本身为矩形的子问题。</p>
    <p class="">The difficulty is that these subproblems overlap with one another.</p>
    <p class="line_zh">困难在于这些子问题彼此重叠。</p>
    <p class="">Thus it too does not represent the divide and conquer algorithm.</p>
    <p class="line_zh">因此它也不代表分而治之的算法。</p>
    <p class="">We return now to breaking down our problem into a set of non-overlapping subproblems of the same original type.</p>
    <p class="line_zh">我们现在返回将我们的问题分解为一组相同原始类型的非重叠子问题。</p>
    <p class="">We break it apart, then we go ahead and solve each subproblem independently.</p>
    <p class="line_zh">我们将它分开，然后我们继续独立解决每个子问题。</p>
    <p class="">We solve the first problem, represented by a check mark.</p>
    <p class="line_zh">我们解决了第一个问题，用复选标记表示。</p>
    <p class="">We then continue solving each problem, in turn.</p>
    <p class="line_zh">然后我们继续解决每个问题。</p>
    <p class="">Once we've successfully solved each of the subproblems, we combine the results into a solution to the original problem.</p>
    <p class="line_zh">一旦我们成功解决了每个子问题，我们将结果组合成原始问题的解决方案。</p>
    <p class="">One question that comes up, how do we solve each subproblem? Since each subproblem is of the same type as the original,
        we can recursively solve the subproblem using the same divide and conquer strategy.</p>
    <p class="line_zh">提出一个问题，我们如何解决每个子问题？由于每个子问题与原始子问题的类型相同，我们可以使用相同的分而治之策略递归地解决子问题。</p>
    <p class="">Thus, divide and conquer algorithms naturally lead to a recursive solution.</p>
    <p class="line_zh">因此，分而治之的算法自然会导致递归解决方案。</p>
    <p class="">In practice, while you can program a divide and conquer algorithm recursively, it's not uncommon to rewrite the recursive
        program into an iterative one.</p>
    <p class="line_zh">实际上，虽然您可以递归地编写分治算法，但将递归程序重写为迭代程序并不罕见。</p>
    <p class="">This is often done both because some programmers aren't as comfortable with recursion as they are with iteration, as
        well as because of the additional space that a recursive implementation may take in terms of additional stack space.</p>
    <p class="line_zh">这通常都是因为一些程序员不像迭代那样对递归感到满意，也因为递归实现可能在额外的堆栈空间方面占用额外的空间。</p>
    <p class="">This can be language and implementation dependent.</p>
    <p class="line_zh">这可能取决于语言和实现。</p>
    <p class="">In summary, the divide and conquer algorithm consists of one: breaking the problem into non-overlapping subproblems of
        the same type.</p>
    <p class="line_zh">总之，分而治之算法包括一个：将问题分解为相同类型的非重叠子问题。</p>
    <p class="">Two: recursively solving those subproblems.</p>
    <p class="line_zh">二：递归解决这些子问题。</p>
    <p class="">And three: combining the results.</p>
    <p class="line_zh">三：结合结果。</p>
    <p class="">In the next video, we'll see an extremely simple example of divide and conquer.</p>
    <p class="line_zh">在下一个视频中，我们将看到一个非常简单的分而治之的例子。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 30 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_30">第02章 linear search
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02线性搜索</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">We're going to start our divide and conquer algorithms with what might be considered a degenerate form of divide and
        conquer: Searching in an unsorted array using linear search.</p>
    <p class="line_zh">我们将开始分裂并用可能被认为是分裂和征服的退化形式征服算法：使用线性搜索在未排序的数组中搜索。</p>
    <p class="">Here's an example of an array.</p>
    <p class="line_zh">这是一个数组的例子。</p>
    <p class="">To find a particular element of the array, we look at the first element, if it's not there, we look at the second element.</p>
    <p class="line_zh">为了找到数组的特定元素，我们查看第一个元素，如果它不存在，我们将查看第二个元素。</p>
    <p class="">We continue until we either find the element we're interested in, or until we reach the end of the array.</p>
    <p class="line_zh">我们继续，直到找到我们感兴趣的元素，或者直到我们到达数组的末尾。</p>
    <p class="">This same type of search is also used to free elements that are stored in a linked list.</p>
    <p class="line_zh">这种类型的搜索也用于释放存储在链表中的元素。</p>
    <p class="">Let me describe a real-life use of linear search.</p>
    <p class="line_zh">让我描述线性搜索的实际使用。</p>
    <p class="">Twenty years ago I did consulting for a company developing software for one the first hand-held computers, the Apple
        Newton.
    </p>
    <p class="line_zh">二十年前，我为一家为第一台手持电脑Apple Newton开发软件的公司提供咨询服务。</p>
    <p class="">The application translated words between any two of the languages: English, French, Italian, German, or Spanish.</p>
    <p class="line_zh">该应用程序翻译了任何两种语言之间的文字：英语，法语，意大利语，德语或西班牙语。</p>
    <p class="">Its data was stored in five parallel arrays.</p>
    <p class="line_zh">它的数据存储在五个并行数组中。</p>
    <p class="">So for example, car was in English at the second position.</p>
    <p class="line_zh">因此，例如，汽车在第二位置是英语。</p>
    <p class="">In Spanish, car is auto, so the second position of the Spanish array contained auto.</p>
    <p class="line_zh">在西班牙语中，car是auto，所以西班牙语数组的第二个位置包含auto。</p>
    <p class="">The program would take the user's input word along with from and to languages.</p>
    <p class="line_zh">该程序将使用用户的输入词以及语言和语言。</p>
    <p class="">Then it would search through the corresponding from array, English for example with trying to translate car from English
        to Spanish.</p>
    <p class="line_zh">然后它将搜索相应的数组，例如英语，试图将汽车从英语翻译成西班牙语。</p>
    <p class="">If it found a match, it returned the element at the same index location and target language.</p>
    <p class="line_zh">如果找到匹配项，则返回相同索引位置和目标语言的元素。</p>
    <p class="">With a small dictionary of three words, as in this example, this linear search is quick.</p>
    <p class="line_zh">使用三个单词的小字典，如本例所示，这种线性搜索很快。</p>
    <p class="">However, I was brought in as a consultant to speed up the application.</p>
    <p class="line_zh">但是，我是作为顾问加入应用程序的。</p>
    <p class="">When users clicked on the translate button, it'd take seven to ten seconds to retrieve the translated word, an eternity
        as far as the user was concerned.</p>
    <p class="line_zh">当用户点击翻译按钮时，需要七到十秒的时间来检索翻译的单词，就用户而言是永恒的。</p>
    <p class="">There were about 50,000 words in the dictionary, so on average it took 25,000 word checks in order to find a match.</p>
    <p class="line_zh">字典中大约有50,000个单词，因此平均需要25,000个单词检查才能找到匹配项。</p>
    <p class="">The next video, I'll show you how we sped up this application using binary search.</p>
    <p class="line_zh">下一个视频，我将向您展示我们如何使用二进制搜索加速此应用程序。</p>
    <p class="">The problem statement for linear search is as follows: given an unsorted array with n elements in it and a key k, find
        an index, i of the array element that's equal to k.</p>
    <p class="line_zh">线性搜索的问题陈述如下：给定一个带有n个元素的未排序数组和一个密钥k，找到一个等于k的数组元素的索引i。</p>
    <p class="">If no element array is equal to k, the output should be NOT_FOUND.</p>
    <p class="line_zh">如果没有元素数组等于k，则输出应为NOT_FOUND。</p>
    <p class="">Note that we say an index rather than the index, to account for the fact that there may be duplicates in the array.</p>
    <p class="line_zh">请注意，我们说索引而不是索引，以说明数组中可能存在重复的事实。</p>
    <p class="">This might seem pedantic, but it's important to be as careful as possible in specifying our problem statement.</p>
    <p class="line_zh">这可能看起来很迂腐，但在指定我们的问题陈述时要尽可能小心谨慎。</p>
    <p class="">The well known solution to this problem is a linear search.</p>
    <p class="line_zh">该问题的众所周知的解决方案是线性搜索。</p>
    <p class="">Iterate through the array until you find the chosen element.</p>
    <p class="line_zh">遍历数组直到找到所选元素。</p>
    <p class="">If you reach the end of the array and haven't yet found the element, return NOT_FOUND.</p>
    <p class="line_zh">如果到达数组的末尾但尚未找到该元素，则返回NOT_FOUND。</p>
    <p class="">We can construct a divide and conquer recursive algorithm to solve this problem.</p>
    <p class="line_zh">我们可以构造一个分而治之的递归算法来解决这个问题。</p>
    <p class="">Our recursive function will take four parameters: A, the array of values; low, the lower bound of the array in which
        to search; hgh, the upper bound of the array in which to search; and k, the key for which to search.</p>
    <p class="line_zh">我们的递归函数将采用四个参数：A，值数组; low，要搜索的数组的下限; hgh，要搜索的数组的上限; 和k，搜索的关键。</p>
    <p class="">It will return either: an index in the range low to high, if it finds a matching value; or NOT_FOUND, if it finds no
        such match.</p>
    <p class="line_zh">如果找到匹配值，它将返回：从低到高范围内的索引; 或NOT_FOUND，如果找不到这样的匹配。</p>
    <p class="">As with all recursive solutions, we'll need to accurately handle the base case.</p>
    <p class="line_zh">与所有递归解决方案一样，我们需要准确处理基本情况。</p>
    <p class="">In particular, base cases for this problem will be either: be given an empty array, or finding a match on the first element.</p>
    <p class="line_zh">特别是，此问题的基本情况将是：给出一个空数组，或在第一个元素上找到匹配项。</p>
    <p class="">The subproblem is to search through the sub array constructed by skipping the first element.</p>
    <p class="line_zh">子问题是通过跳过第一个元素来搜索构造的子数组。</p>
    <p class="">We'll recursively search through that smaller sub array, and then just return the result of the recursive search.</p>
    <p class="line_zh">我们将递归搜索那个较小的子数组，然后只返回递归搜索的结果。</p>
    <p class="">Although this is a recursive routine that breaks the problem into smaller problems, some would argue that this shouldn't
        be called divide and conquer.</p>
    <p class="line_zh">虽然这是一个将问题分解为较小问题的递归例程，但有些人会认为这不应该被称为分而治之。</p>
    <p class="">They claim that a divide and conquer algorithm should divide the problem into a smaller subproblem, where the smaller
        subproblem is some constant fraction of the original problem.</p>
    <p class="line_zh">他们声称分而治之算法应该将问题分成一个较小的子问题，其中较小的子问题是原始问题的一些不变部分。</p>
    <p class="">In this case the su-problem isn't 50%, or 80%, or even 95% of the original problem size.</p>
    <p class="line_zh">在这种情况下，su问题不是原始问题大小的50％，或80％，或甚至95％。</p>
    <p class="">Instead, it's just one smaller than the original problem size.</p>
    <p class="line_zh">相反，它只比原始问题大小小一个。</p>
    <p class="">I don't know, maybe we should call this algorithm subtract and conquer rather than divide and conquer.</p>
    <p class="line_zh">我不知道，也许我们应该把这个算法称为减法和征服而不是分而治之。</p>
    <p class="">In order to examine the runtime of our recursive algorithm it's often useful to define the time that the algorithm takes
        in the form of a recurrence relation.</p>
    <p class="line_zh">为了检查递归算法的运行时间，定义算法采用递归关系形式的时间通常很有用。</p>
    <p class="">A recurrence relation defines a sequence of values in terms of a recursive formula.</p>
    <p class="line_zh">递归关系根据递归公式定义值序列。</p>
    <p class="">The example here shows the recursive definition of the values in the Fibonacci sequence.</p>
    <p class="line_zh">此处的示例显示了Fibonacci序列中值的递归定义。</p>
    <p class="">You can see that we defined the value for the n'th Fibonacci as the sum of the preceding two values.</p>
    <p class="line_zh">您可以看到我们将第n个Fibonacci的值定义为前两个值的总和。</p>
    <p class="">As with any recursive definition, we need one or more base cases.</p>
    <p class="line_zh">与任何递归定义一样，我们需要一个或多个基本情况。</p>
    <p class="">Here, we define base cases when evaluating F(0) and F(1).</p>
    <p class="line_zh">在这里，我们在评估F（0）和F（1）时定义基本情况。</p>
    <p class="">From this recursive definition, we've defined values for evaluating F(n) for any non-negative integer, n.</p>
    <p class="line_zh">从这个递归定义中，我们定义了用于评估任何非负整数n的F（n）的值。</p>
    <p class="">The sequence starts with 0, 1, 1, 2, 3, 5, 8, and continues on.</p>
    <p class="line_zh">序列以0,1,1,2,3,5,8开始，并继续。</p>
    <p class="">When we're doing run-time analysis for divide and conquer algorithms, we usually define a recurrence relation for T(n).</p>
    <p class="line_zh">当我们对分而治之算法进行运行时分析时，我们通常会定义T（n）的递归关系。</p>
    <p class="">where T stands for the worst time taken for the algorithm, and n is the size of the problem.</p>
    <p class="line_zh">其中T代表算法所用的最差时间，n是问题的大小。</p>
    <p class="">For this algorithm, the worst-case time is when an element isn't found because we must check every element of the array.</p>
    <p class="line_zh">对于此算法，最坏情况时间是找不到元素，因为我们必须检查数组的每个元素。</p>
    <p class="">In this case we have a recursion for a problem of size n which consists of a subproblem of size n minus one plus a constant
        amount of work.</p>
    <p class="line_zh">在这种情况下，我们对大小为n的问题进行递归，该问题由大小为n的子问题减去1加上恒定的工作量组成。</p>
    <p class="">The constant amount of work includes checking high versus low, checking A at low equals key, preparing the parameters
        for the recursive call, and then returning the result of that call.</p>
    <p class="line_zh">恒定的工作量包括检查高与低，检查A等于低等于密钥，准备递归调用的参数，然后返回该调用的结果。</p>
    <p class="">Thus the recurrence is T(n) equals T(n-1) plus c, where c is some constant.</p>
    <p class="line_zh">因此，重现是T（n）等于T（n-1）加c，其中c是某个常数。</p>
    <p class="">The base case of the recursion is in an empty array, there's a constant amount of work: checking high less than low and
        then returning NOT_FOUND.</p>
    <p class="line_zh">递归的基本情况是一个空数组，有一个恒定的工作量：检查高于低值然后返回NOT_FOUND。</p>
    <p class="">Thus T(0) equals c.</p>
    <p class="line_zh">因此T（0）等于c。</p>
    <p class="">Let's look at a recursion tree in order to determine how much total time the algorithm takes.</p>
    <p class="line_zh">让我们看一个递归树，以确定算法花费的总时间。</p>
    <p class="">As is normal, we're looking at worst-case runtime, which will occur when no matching element is found.</p>
    <p class="line_zh">正常情况下，我们正在查看最坏情况运行时，这将在找不到匹配元素时发生。</p>
    <p class="">In a recursion tree, we show the problem along with the size of the problem.</p>
    <p class="line_zh">在递归树中，我们显示问题以及问题的大小。</p>
    <p class="">We see that we have an original problem of size n which then generates a subproblem of size n-1, and so on all the way
        down to a subproblem of size zero: an empty array.</p>
    <p class="line_zh">我们看到我们有一个大小为n的原始问题，然后生成一个大小为n-1的子问题，依此类推到一个大小为零的子问题：一个空数组。</p>
    <p class="">The work column shows the amount of work that is done at each level.</p>
    <p class="line_zh">工作栏显示每个级别的工作量。</p>
    <p class="">We have a constant amount of work at each level which we represent by c, a constant.</p>
    <p class="line_zh">我们在每个级别都有不变的工作量，我们用c代表一个常量。</p>
    <p class="">Alternatively, we could have represented this constant amount of work with big theta of one.</p>
    <p class="line_zh">或者，我们可以用一个大的θ代表这个不变的工作量。</p>
    <p class="">The total work is just the sum of the work done at each level that's a summation from zero to n of a constant c.</p>
    <p class="line_zh">总工作量只是每个级别所做工作的总和，它是从零到n的常数c的总和。</p>
    <p class="">Which is n plus one times c, or just big theta of n.</p>
    <p class="line_zh">这是n加c的一倍，或者只是n的大θ。</p>
    <p class="">This analysis seems overly complicated for such a simple result.</p>
    <p class="line_zh">对于如此简单的结果，这种分析似乎过于复杂。</p>
    <p class="">We already know that searching through n elements of the array will take big theta of n time.</p>
    <p class="line_zh">我们已经知道，搜索数组中的n个元素将占用n次。</p>
    <p class="">However, this method of recurrence analysis will become more useful as we analyze more complicated divide and conquer
        algorithms.
    </p>
    <p class="line_zh">然而，当我们分析更复杂的分治算法时，这种递归分析方法将变得更有用。</p>
    <p class="">Many times a recursive algorithm is translated into an iterative one.</p>
    <p class="line_zh">很多时候，递归算法被转换为迭代算法。</p>
    <p class="">Here we've done that for the linear search.</p>
    <p class="line_zh">在这里，我们已经完成了线性搜索。</p>
    <p class="">We search through the elements of array A from index low to index high.</p>
    <p class="line_zh">我们搜索数组A的元素，从索引低到索引高。</p>
    <p class="">If we find a match, we return the associated index.</p>
    <p class="line_zh">如果我们找到匹配项，则返回关联的索引。</p>
    <p class="">If not, we return NOT_FOUND.</p>
    <p class="line_zh">如果没有，我们返回NOT_FOUND。</p>
    <p class="">To summarize, what we've done is one: created a recursive solution; two: defined a corresponding recurrence relation,
        T; three: solved T of n to determine the worst-case runtime; and four: created an iterative solution from the recursive
        one.
    </p>
    <p class="line_zh">总而言之，我们所做的就是：创建一个递归解决方案; 二：定义了相应的递归关系，T; 三：求解n的T来确定最坏情况的运行时间; 和四：从递归的解决方案中创建迭代解决方案。</p>
    <p class="">What you've seen in this video, then, is an example of a trivial use of our divide and conquer technique in order to
        do a linear search.</p>
    <p class="line_zh">那么，你在这个视频中看到的是一个简单使用我们的分而治之技术来进行线性搜索的例子。</p>
    <p class="">In our next video we'll look at a non-trivial use of the divide an conquer technique for searching in a sorted array:
        the well known binary search.</p>
    <p class="line_zh">在我们的下一个视频中，我们将看到一个非常重要的用于在一个有序数组中进行搜索的征服技术：众所周知的二进制搜索。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 31 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_31">第03章 binary search
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">03二进制搜索</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hi, so let's talk now about binary search.</p>
    <p class="line_zh">嗨，现在让我们谈谈二进制搜索。</p>
    <p class="">A dictionary is a good example of a ordered list.</p>
    <p class="line_zh">字典是有序列表的一个很好的例子。</p>
    <p class="">Okay, basically where every word is in order.</p>
    <p class="line_zh">好的，基本上每个单词都是有序的。</p>
    <p class="">And that makes finding words much easier.</p>
    <p class="line_zh">这使得查找单词变得更容易。</p>
    <p class="">You can imagine how difficult it would be to search a dictionary if the order of the words was random.</p>
    <p class="line_zh">你可以想象，如果单词的顺序是随机的，搜索字典是多么困难。</p>
    <p class="">You'd have to just search through every single page, and in fact, every word on every page.</p>
    <p class="line_zh">你必须只搜索每一页，事实上，每页上的每个单词。</p>
    <p class="">It'd take quite a long time.</p>
    <p class="line_zh">这需要很长时间。</p>
    <p class="">So let's look at the problem statement for searching in a sorted array.</p>
    <p class="line_zh">那么让我们看一下在排序数组中搜索的问题陈述。</p>
    <p class="">So what we have coming in is, A, an array, along with a low and upper bound that specify the bounds within the array
        in which to search.</p>
    <p class="line_zh">所以我们得到的是A，一个数组，以及一个低限和上限，指定数组中要搜索的范围。</p>
    <p class="">What's important about the array is that it's in sorted order.</p>
    <p class="line_zh">这个数组最重要的是它按排序顺序排列。</p>
    <p class="">What we mean by that is if we look at any index i at an element.</p>
    <p class="line_zh">我们的意思是，如果我们看一个元素的任何索引i。</p>
    <p class="">And then the next element, that this first element is no more than the next element.</p>
    <p class="line_zh">然后是下一个元素，即第一个元素不过是下一个元素。</p>
    <p class="">We don't say less than because we want to allow for arrays that have repeated elements.</p>
    <p class="line_zh">我们不要说因为我们想要允许具有重复元素的数组。</p>
    <p class="">So officially this is called a monotonic non-decreasing array.</p>
    <p class="line_zh">所以正式这被称为单调非递减阵列。</p>
    <p class="">The other input is the key to look for.</p>
    <p class="line_zh">另一个输入是寻找的关键。</p>
    <p class="">The output for this is an index such that the element at that index in the array is equal to the key.</p>
    <p class="line_zh">此输出是一个索引，使得数组中该索引处的元素等于键。</p>
    <p class="">We say an element and not the element just as we did in linear search.</p>
    <p class="line_zh">我们说的是元素而不是元素，就像我们在线性搜索中所做的那样。</p>
    <p class="">because of the fact that there may be more than one element-- more than one element that matches because there may be
        duplicates in the array.</p>
    <p class="line_zh">因为可能存在多个元素 - 多个元素匹配，因为数组中可能存在重复。</p>
    <p class="">If we don't have a match, instead of returning NOT_FOUND as we did in the linear search case, we're going to actually
        return somewhat more useful information, which is where in the array would you actually insert the element if you
        wanted to insert it? Or where would it have been, if it were there? So what we're going to return is the greatest
        index, such that A sub i is less than k.</p>
    <p class="line_zh">如果我们没有匹配，而不是像在线性搜索情况中那样返回NOT_FOUND，我们将实际返回一些更有用的信息，如果你想要在数组中实际插入元素的位置插入？或者它会在哪里，如果它在那里？所以我们要返回的是最大的指数，这样A sub i小于k。</p>
    <p class="">That is, if the key is not in the array, we're returning an index such that if you look at the element at that index,
        it's less than the key but the next element is greater than the key.</p>
    <p class="line_zh">也就是说，如果键不在数组中，我们将返回一个索引，如果你查看该索引处的元素，它会小于键，但下一个元素大于键。</p>
    <p class="">And we do have to take account of the fact that what if every element in the array is greater than the key? In that case,
        we're going to go ahead and return low- 1.</p>
    <p class="line_zh">而且我们必须考虑到如果数组中的每个元素都大于键那么该怎么办？在那种情况下，我们将继续前进并返回低位1。</p>
    <p class="">So look at an example.</p>
    <p class="line_zh">那么看一个例子。</p>
    <p class="">We've got this array with 7 elements in it, and the element 20 is repeated in it.</p>
    <p class="line_zh">我们有一个包含7个元素的数组，元素20在其中重复。</p>
    <p class="">So if we search in this array for 2, we want to go ahead and return 0, saying that every element in the array is larger
        than this.</p>
    <p class="line_zh">因此，如果我们在这个数组中搜索2，我们希望继续返回0，表示数组中的每个元素都大于此值。</p>
    <p class="">If on the other hand, we look for 3, we're going to return 1.</p>
    <p class="line_zh">另一方面，如果我们寻找3，我们将返回1。</p>
    <p class="">If we look for 4, we're also going to be returning 1.</p>
    <p class="line_zh">如果我们寻找4，我们也将返回1。</p>
    <p class="">which really signifies between 1 and 2.</p>
    <p class="line_zh">这实际上意味着1和2之间。</p>
    <p class="">That is, it's bigger than 3 but it's less than 5.</p>
    <p class="line_zh">也就是说，它大于3但不到5。</p>
    <p class="">If we search for 20, we return 4.</p>
    <p class="line_zh">如果我们搜索20，我们返回4。</p>
    <p class="">Or we might also return 5.</p>
    <p class="line_zh">或者我们也可能会返回5。</p>
    <p class="">Either one of those is valid because 20 is present at each of those indexes.</p>
    <p class="line_zh">其中任何一个都是有效的，因为每个索引都有20个。</p>
    <p class="">And if we search for 60, we'll return 7.</p>
    <p class="line_zh">如果我们搜索60，我们将返回7。</p>
    <p class="">But if we search for 70, we'll also return 7.</p>
    <p class="line_zh">但如果我们搜索70，我们也将返回7。</p>
    <p class="">So let's look at our implementation of BinarySearch.</p>
    <p class="line_zh">那么让我们看一下BinarySearch的实现。</p>
    <p class="">So we're going to write a recursive routine, taking in A, low, high and key, just as we specified in the problem statement.</p>
    <p class="line_zh">因此，我们将编写一个递归例程，接受A，low，high和key，就像我们在问题陈述中指定的那样。</p>
    <p class="">First our base case.</p>
    <p class="line_zh">首先我们的基础案例。</p>
    <p class="">If we have an empty array, that is if high is less than low, so no elements, then we're going to return low-1.</p>
    <p class="line_zh">如果我们有一个空数组，那就是如果high低于low，那么没有元素，那么我们将返回low-1。</p>
    <p class="">Otherwise, we're going to calculate the midpoint.</p>
    <p class="line_zh">否则，我们将计算中点。</p>
    <p class="">So we want something halfway between low and high.</p>
    <p class="line_zh">所以我们想要从低到高之间的中间位置。</p>
    <p class="">So what we're going to do is figure the width, which is high- low, cut it in half, so divide by 2, and then add that
        to low.</p>
    <p class="line_zh">所以我们要做的是计算宽度，即高 - 低，将其减半，然后除以2，然后将其加到低位。</p>
    <p class="">That might not be an integer because of the fact that high- low divided by 2 may give us a fractional portion, so we're
        going to take the floor of that.</p>
    <p class="line_zh">这可能不是一个整数，因为高 - 低除以2可能会给我们一个小数部分，所以我们将采取行动。</p>
    <p class="">For example, in the previous case, we had 1 to 7, it'll be 7- 1 is 6, divided by 2 is 3 + our low is 1 is 4, so the midpoint
        would be 4.</p>
    <p class="line_zh">例如，在前一种情况下，我们有1到7，它将是7-1是6，除以2是3 +我们的低是1是4，所以中点将是4。</p>
    <p class="">We'll see an example of this shortly.</p>
    <p class="line_zh">我们很快就会看到一个例子。</p>
    <p class="">And now we check and see is the element at that midpoint equal to our key.</p>
    <p class="line_zh">现在我们检查并看到该中点的元素等于我们的键。</p>
    <p class="">If so, we're done, we return it.</p>
    <p class="line_zh">如果是这样，我们已经完成了，我们将其归还。</p>
    <p class="">If not, the good news is of course, we don't have to check all the other elements, we've ruled out half of them.</p>
    <p class="line_zh">如果没有，好消息当然是，我们不必检查所有其他元素，我们已经排除了其中一半。</p>
    <p class="">So if the key is less than the midpoint element, then all the upper ones we can ignore.</p>
    <p class="line_zh">因此，如果键小于中点元素，那么我们可以忽略所有上层元素。</p>
    <p class="">So we're going to go ahead and now return the BinarySearch in A from low to mid- 1, completely ignoring all the stuff
        over here.</p>
    <p class="line_zh">因此我们将继续前进，现在将A中的BinarySearch从低到中1返回，完全忽略了这里的所有内容。</p>
    <p class="">Otherwise, the key is greater than the midpoint, and again, we can throw away the lower stuff and go from midpoint +
        1, all the way to high.</p>
    <p class="line_zh">否则，键值大于中点，再次，我们可以扔掉较低的东西，从中点+ 1，一直到高点。</p>
    <p class="">Let's look at an example.</p>
    <p class="line_zh">我们来看一个例子。</p>
    <p class="">So let's say we're searching for the key 50 in this array with 11 elements.</p>
    <p class="line_zh">因此，假设我们正在使用11个元素搜索此数组中的键50。</p>
    <p class="">So we'll do a binary search on this array, from 1 to 11, looking for 50.</p>
    <p class="line_zh">所以我们将对这个数组进行二进制搜索，从1到11，寻找50。</p>
    <p class="">Low is 1, high is 11.</p>
    <p class="line_zh">低是1，高是11。</p>
    <p class="">We'll calculate the midpoint, the midpoint will be 11- 1 is 10, divided by 2 is 5, add that to 1, the midpoint is 6.</p>
    <p class="line_zh">我们将计算中点，中点将是11-1是10，除以2是5，将其加到1，中点是6。</p>
    <p class="">And now we check and see is the midpoint element equal to 50? Well, no.</p>
    <p class="line_zh">现在我们检查并看到中点元素等于50？好吧，不。</p>
    <p class="">The midpoint element is 15 and the element we are looking for, the key we're looking for, is 50.</p>
    <p class="line_zh">中点元素是15，我们正在寻找的元素，我们正在寻找的关键是50。</p>
    <p class="">So we're going to go ahead and ignore the lower half of the array and now call binary search again, with the low equal
        to 7, so one more than the midpoint.</p>
    <p class="line_zh">因此，我们将继续忽略数组的下半部分，现在再次调用二进制搜索，低等于7，因此比中点多一个。</p>
    <p class="">So now we've got a smaller version of the problem.</p>
    <p class="line_zh">所以现在我们有一个较小版本的问题。</p>
    <p class="">We're looking for 50 within the elements 7 to 11, we'll calculate the midpoint.</p>
    <p class="line_zh">我们在元素7到11中寻找50，我们将计算中点。</p>
    <p class="">11- 7 is 4 divided by 2 is 2, so we'll add that to 7 to get a midpoint of 9.</p>
    <p class="line_zh">11- 7是4除以2是2，所以我们将其加到7得到9的中点。</p>
    <p class="">We check, is the element at index 9 equal to our key? The element at index 9 is 20, our key is 50, they're not equal.</p>
    <p class="line_zh">我们检查，索引9处的元素是否等于我们的键？索引9处的元素是20，我们的键是50，它们不相等。</p>
    <p class="">However, 50 is greater than 20, so we're going to go ahead and make a new recursive call with midpoint + 1, which is
        10.
    </p>
    <p class="line_zh">但是，50大于20，所以我们将继续使用中点+ 1（即10）进行新的递归调用。</p>
    <p class="">So, again, we do our binary search from 10 to 11.</p>
    <p class="line_zh">所以，我们再次从10到11进行二进制搜索。</p>
    <p class="">We calculate the midpoint.</p>
    <p class="line_zh">我们计算中点。</p>
    <p class="">High- low, 11- 10 is 1, divided by 2 is one-half + 10 is 10 and a half, we take the floor of that, we get 10 and a half,
        so our midpoint is 10 and a half.</p>
    <p class="line_zh">高 - 低，11 - 10是1，除以2是一半+ 10是10，我们采取的是，我们得到10点半，所以我们的中点是10点半。</p>
    <p class="">I'm sorry, our midpoint is 10.</p>
    <p class="line_zh">对不起，我们的中点是10点。</p>
    <p class="">And now we check.</p>
    <p class="line_zh">现在我们检查一下。</p>
    <p class="">Is the value at element 10 equal to our key? Well the value at element 10 is 50, our key is 50 so yes.</p>
    <p class="line_zh">元素10的值是否等于我们的键？元素10的值是50，我们的关键是50，所以是的。</p>
    <p class="">We're going to go ahead and return that midpoint which is 10.</p>
    <p class="line_zh">我们将继续前进并返回10点的中点。</p>
    <p class="">In summary then, what we've done is broken our problem into non-overlapping subproblems of the same type.</p>
    <p class="line_zh">总而言之，我们所做的是将我们的问题分解为相同类型的非重叠子问题。</p>
    <p class="">We've recursively solved the subproblems.</p>
    <p class="line_zh">我们递归地解决了子问题。</p>
    <p class="">And then we're going to combine the results of those subproblems.</p>
    <p class="line_zh">然后我们将结合这些子问题的结果。</p>
    <p class="">We broke the problem into a problem of size half (slightly less than half).</p>
    <p class="line_zh">我们将问题分解为大小一半（略小于一半）的问题。</p>
    <p class="">We recursively solved that single subproblem and then we combined the result very simply just by returning the result.</p>
    <p class="line_zh">我们递归地解决了单个子问题，然后我们通过返回结果非常简单地组合结果。</p>
    <p class="">In the next video, we're going to go ahead and look at the runtime for binary search, along with an iterative version.</p>
    <p class="line_zh">在下一个视频中，我们将继续讨论二进制搜索的运行时以及迭代版本。</p>
    <p class="">And we'll get back to actually discussing that problem that I discussed with the dictionary translation problem.</p>
    <p class="line_zh">我们将回到实际讨论我讨论的字典翻译问题。</p>
    <p class="">We'll see you shortly.</p>
    <p class="line_zh">我们很快就会见到你。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 32 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_32">第04章 binary search runtime
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">04二进制搜索运行时</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hi, in this video we're going to be looking at the run time of BinarySearch along with looking at an iterative version
        of it.</p>
    <p class="line_zh">嗨，在这个视频中，我们将查看BinarySearch的运行时间以及查看它的迭代版本。</p>
    <p class="">So here's our BinarySearch algorithm again.</p>
    <p class="line_zh">所以这是我们的BinarySearch算法。</p>
    <p class="">We look in the middle, if it's not found, then we either look in the lower half or the upper half.</p>
    <p class="line_zh">我们看中间，如果没有找到，那么我们要么看下半部分还是上半部分。</p>
    <p class="">So whats our recurrence relation for the worst-case runtime? Well, the worst case is if we don't find an element.</p>
    <p class="line_zh">那么最坏情况运行时的递归关系是什么？好吧，最糟糕的情况是如果我们找不到元素。</p>
    <p class="">So were going to look at T(n) Is equal to T of roughly n over 2 + c.</p>
    <p class="">所以要看T（n）等于大约n超过2 + c的T.</p>
    <p class="">We have a floor there of n over 2 because if n is odd, let's say there are five elements, then the question is: how big
        is the problem size on the next call.</p>
    <p class="line_zh">我们有一个n超过2的楼层，因为如果n是奇数，假设有五个元素，那么问题是：下一次调用时问题大小有多大。</p>
    <p class="">So if we have five elements we're going to either end up looking in the upper half of the array.</p>
    <p class="line_zh">因此，如果我们有五个元素，我们将最终查看数组的上半部分。</p>
    <p class="">Those two elements or the lower half of the array, those two elements because we skipped the midpoint.</p>
    <p class="line_zh">那两个元素或数组的下半部分，那两个元素因为我们跳过了中点。</p>
    <p class="">We already checked them.</p>
    <p class="line_zh">我们已经检查了它们。</p>
    <p class="">Plus some constant amount of work to add together, to calculate the midpoint.</p>
    <p class="line_zh">加上一些不断增加的工作量来计算中点。</p>
    <p class="">As well as checking the midpoint against the key.</p>
    <p class="line_zh">以及根据钥匙检查中点。</p>
    <p class="">And then our base case is when we have an empty array.</p>
    <p class="line_zh">然后我们的基本情况是我们有一个空数组。</p>
    <p class="">And that's just a constant amount of time to check.</p>
    <p class="line_zh">这只是一个不变的时间来检查。</p>
    <p class="">So what's the runtime look like? We got our original size n, and we're going to break it down, n over 2, n over 4.</p>
    <p class="line_zh">那么运行时是什么样的？我们得到了我们原来的大小n，我们将打破它，n超过2，n超过4。</p>
    <p class="">All the way down.</p>
    <p class="line_zh">一直往下。</p>
    <p class="">How many of these problems are there.</p>
    <p class="line_zh">有多少这些问题。</p>
    <p class="">Well, if we're cutting something in two over and over again.</p>
    <p class="line_zh">好吧，如果我们一次又一次地切两件事。</p>
    <p class="">It's going to take log base two such iterations until we get down to 1.</p>
    <p class="line_zh">它将采用log base两次这样的迭代，直到我们降到1。</p>
    <p class="">So the total here, is actually log base two of n + 1.</p>
    <p class="line_zh">所以这里的总数实际上是n + 1的log base 2。</p>
    <p class="">The amount of work we're doing is c.</p>
    <p class="line_zh">我们正在做的工作量是c。</p>
    <p class="">So at each level, we're doing c work.</p>
    <p class="line_zh">所以在每个级别，我们都在做c工作。</p>
    <p class="">So the total amount of work if we sum it, is just the sum from i=0 to log base 2 of n of c.</p>
    <p class="line_zh">因此，如果我们总结它的总工作量，只是从i = 0到c的n的log 2的总和。</p>
    <p class="">That is just log base 2 of n + 1, that is log base 2 of n, that quantity, plus one times c.</p>
    <p class="line_zh">这只是n + 1的对数基数2，即n的对数基数2，该数量加c的一倍。</p>
    <p class="">And that is just theta of log based two of n, but really what we'd normally say is theta of log n, because the base doesn't
        matter.
    </p>
    <p class="line_zh">这只是基于n的两个基数的log，但实际上我们通常所说的是log n的theta，因为基数并不重要。</p>
    <p class="">That's just a constant multiplicative factor.</p>
    <p class="line_zh">这只是一个不变的乘法因素。</p>
    <p class="">All right, what's the iterative version look like.</p>
    <p class="line_zh">好吧，迭代版本是什么样的。</p>
    <p class="">The iterative version has the same parameters low, high, and key.</p>
    <p class="line_zh">迭代版本具有相同的参数low，high和key。</p>
    <p class="">And we have a while loop that goes through similar to the base case so in the base case of the recursive version we were
        stopping if high is less than low.</p>
    <p class="line_zh">我们有一个类似于基本情况的while循环，因此在递归版本的基本情况下，如果high低于low，我们就会停止。</p>
    <p class="">Here, we have a while loop where the while loop stops if high is less than low.</p>
    <p class="line_zh">在这里，我们有一个while循环，如果high低于low，while循环停止。</p>
    <p class="">We calculate the midpoint and then again check the key.</p>
    <p class="line_zh">我们计算中点，然后再次检查密钥。</p>
    <p class="">If it matches the element at the midpoint we return the midpoint.</p>
    <p class="line_zh">如果它与中点处的元素匹配，则返回中点。</p>
    <p class="">Otherwise, if the key is less than the element, we know we're in the first half of the array and so instead of making
        a new recursive call like we did in the recursive version we have the original array.</p>
    <p class="line_zh">否则，如果键小于元素，我们知道我们在数组的前半部分，因此不像我们在递归版本中那样进行新的递归调用，而是使用原始数组。</p>
    <p class="">And we want to look at the first half of it so we're going to change the value of high and that will be mid minus one
        because we already checked mid.</p>
    <p class="line_zh">我们想看看它的前半部分，所以我们要改变高值，这将是中间减去一，因为我们已经检查了中期。</p>
    <p class="">Otherwise, we want to look in the upper half of the array so we move low up.</p>
    <p class="line_zh">否则，我们想要查看数组的上半部分，以便我们向上移动。</p>
    <p class="">If we reach the end of the while loop.</p>
    <p class="line_zh">如果我们到达while循环的末尾。</p>
    <p class="">That is if we drop out of the while loop because high is less than low.</p>
    <p class="line_zh">那就是如果我们退出while循环，因为high低于low。</p>
    <p class="">That meant we have nothing more to search.</p>
    <p class="line_zh">这意味着我们没有更多的搜索。</p>
    <p class="">We have an empty array.</p>
    <p class="line_zh">我们有一个空数组。</p>
    <p class="">And therefore, we didn't find the element in the array.</p>
    <p class="line_zh">因此，我们没有在数组中找到元素。</p>
    <p class="">We're going to return low minus 1.</p>
    <p class="line_zh">我们将返回低-1。</p>
    <p class="">So the same result as the recursive version.</p>
    <p class="line_zh">因此与递归版本的结果相同。</p>
    <p class="">The difference is we won't be using the stack space that the recursive version uses.</p>
    <p class="line_zh">不同之处在于我们不会使用递归版本使用的堆栈空间。</p>
    <p class="">You remember we talked two videos ago about this real-life example where we had five languages and we were translating
        words between any two of those languages.</p>
    <p class="line_zh">你记得我们之前谈过两个视频关于这个现实生活中的例子，我们有五种语言，我们正在翻译任何两种语言之间的单词。</p>
    <p class="">The way we had that represented was parallel arrays, so that at any given index, each of the element in the arrays represented
        words that were the same in all those languages.</p>
    <p class="line_zh">我们所代表的方式是并行数组，因此在任何给定的索引中，数组中的每个元素都代表所有这些语言中相同的单词。</p>
    <p class="">So for instance, chair in English is at index two, and in Spanish that's silla and in Italian it's sedia.</p>
    <p class="line_zh">因此，例如，英语主席在索引2，在西班牙语中是silla，在意大利语中是sedia。</p>
    <p class="">The problem was it took a long time to look, right? We had 50,000 elements in our arrays, and it took like ten seconds
        for searching, because we had to really search through all of them if it wasn't there, on average, half of them,
        just 25,000.</p>
    <p class="line_zh">问题是花了很长时间才看，对吧？我们的数组中有50,000个元素，搜索需要10秒钟，因为如果它不存在，我们必须真正搜索所有元素，平均而言，其中一半只有25,000个。</p>
    <p class="">So one question might be, why didn't we use a sorted array? Right? You could imagine, for instance, sorting these arrays.</p>
    <p class="line_zh">所以有一个问题，为什么我们不使用排序数组呢？对？例如，您可以想象对这些数组进行排序。</p>
    <p class="">Here they're sorted.</p>
    <p class="line_zh">他们在这里排序。</p>
    <p class="">The good part is, it's easy to find a particular word in a particular language.</p>
    <p class="line_zh">好的部分是，很容易找到特定语言的特定单词。</p>
    <p class="">So I can find house in English, for instance, and find what index that is at very quickly, using binary search.</p>
    <p class="line_zh">例如，我可以用英语找到house，并使用二进制搜索找到非常快的索引。</p>
    <p class="">The problem is, I no longer have this correspondence, because the order of the words that are sorted in English is different
        from the order of the words sorted in Spanish.</p>
    <p class="line_zh">问题是，我不再有这种对应关系，因为用英语排序的单词的顺序与用西班牙语排序的单词的顺序不同。</p>
    <p class="">So if I look at chair, for instance, in English, it no longer maps to silla.</p>
    <p class="line_zh">因此，如果我用英语看椅子，它就不再映射到新罗了。</p>
    <p class="">So instead, if I look at chair and that's to casa.</p>
    <p class="line_zh">所以相反，如果我看看椅子，那就是casa。</p>
    <p class="">So although we can find a particular word in our source language, we don't know the corresponding word in the target
        language.
    </p>
    <p class="line_zh">因此，尽管我们可以在源语言中找到特定单词，但我们不知道目标语言中的相应单词。</p>
    <p class="">So the solution was to try and find some way we could do sorting and yet still preserve this relationship where everything
        at an index meant the same translated word.</p>
    <p class="line_zh">因此，解决方案是尝试找到一些我们可以进行排序的方法，但仍保留这种关系，其中索引处的所有内容都意味着相同的翻译单词。</p>
    <p class="">The way to do that was an augmented set of arrays.</p>
    <p class="line_zh">这样做的方法是增加一组数组。</p>
    <p class="">So what we really did was keep these augmented arrays which were pointers back into the original arrays in sorted order.</p>
    <p class="line_zh">所以我们真正做的是将这些增强数组按指令排列回原始数组中。</p>
    <p class="">So we're having a kind of level of indirection.</p>
    <p class="line_zh">所以我们有一种间接的水平。</p>
    <p class="">So if I look at English for example, the order of the words in English is chair, house, pimple.</p>
    <p class="line_zh">因此，如果我以英语为例，英语单词的顺序是椅子，房子，疙瘩。</p>
    <p class="">Well, what order is that in the original array? It is first element 2, and then element 1, and then element 3.</p>
    <p class="line_zh">那么，原始数组中的顺序是什么？它是第一个元素2，然后是元素1，然后是元素3。</p>
    <p class="">So if you want to do a binary search, you can use this sorted array.</p>
    <p class="line_zh">因此，如果要进行二分查找，可以使用此排序数组。</p>
    <p class="">Whenever you want to look at what an element is in that represented sorted array.</p>
    <p class="line_zh">每当你想要查看表示排序数组的元素时。</p>
    <p class="">So for instance, if we looked at the middle element, which in the sorted array is 2, it has the value 1 and that says
        go find house.</p>
    <p class="line_zh">因此，例如，如果我们查看中间元素，它在排序数组中是2，它的值为1，并且表示找到房子。</p>
    <p class="">So we basically, say house is sort of at element 2 and chair is at element 1 and pimple's at element 3.</p>
    <p class="line_zh">所以我们基本上说，房子是元素2，椅子是元素1，疙瘩是元素3。</p>
    <p class="">The Spanish, of course, has different mapping, so in Spanish, the first sorted word happens to be the first word in the
        array.
    </p>
    <p class="line_zh">当然，西班牙语有不同的映射，所以在西班牙语中，第一个排序的单词恰好是数组中的第一个单词。</p>
    <p class="">The second sorted word is the third word in the Spanish array; and the third sorted word, silla, is the second element.</p>
    <p class="line_zh">第二个排序的单词是西班牙语数组中的第三个单词; 第三个排序单词silla是第二个元素。</p>
    <p class="">So what happened when we ran this? Well what happened, we had a space time trade off.</p>
    <p class="line_zh">那么当我们跑这个时发生了什么？那么发生了什么，我们有一个时空交易。</p>
    <p class="">We had to pay extra space.</p>
    <p class="line_zh">我们不得不支付额外的空间。</p>
    <p class="">And there were, of course, not only just English and Spanish sorted but also French, Italian, and German.</p>
    <p class="line_zh">当然，不仅有英语和西班牙语，还有法语，意大利语和德语。</p>
    <p class="">So, five arrays, extra arrays.</p>
    <p class="line_zh">所以，五个数组，额外的数组。</p>
    <p class="">Each array, had 50,000 entries in it and what was the size of each element of the array? Well, it represented a number
        from one to 50,000 that can be represented in 16-bits which is two bytes.</p>
    <p class="line_zh">每个数组中有50,000个条目，数组中每个元素的大小是多少？好吧，它表示一个从1到50,000的数字，可以用16位表示，即两个字节。</p>
    <p class="">So we had 50,000 elements times 2 bytes, that is 100,000 bytes times 5 is 500,000 bytes.</p>
    <p class="line_zh">所以我们有50,000个元素乘以2个字节，即100,000个字节乘以5个是500,000个字节。</p>
    <p class="">So about a half a megabyte, which today is almost nothing.</p>
    <p class="line_zh">所以大约半兆字节，今天几乎没有。</p>
    <p class="">And even then, was certainly doable 20 years ago.</p>
    <p class="line_zh">即便如此，20年前肯定是可行的。</p>
    <p class="">That's the cost we have in space.</p>
    <p class="line_zh">这就是我们在太空中的成本。</p>
    <p class="">What is the benefit that we get.</p>
    <p class="">我们得到的好处是什么？</p>
    <p class="">Well, instead of having to do let's say 50,000 look ups in the worst-case.</p>
    <p class="line_zh">好吧，在最糟糕的情况下，不要让我们说50,000次查找。</p>
    <p class="">Instead, we have to do log base two of 50,000 lock ups.</p>
    <p class="line_zh">相反，我们必须做5万个锁定中的两个记录库。</p>
    <p class="">So log base 2 of 50,000, that's about, let's see, log base of 1,000 is about ten because two to the ten equals 1024,
        so we have another factor of 50 to go.</p>
    <p class="line_zh">所以记录基数2为50,000，那就是，让我们看一下，1000的对数基数大约为10，因为两个到十个等于1024，所以我们有另一个因子50。</p>
    <p class="">Log base 2 of 50 is around, let's say six because I know that 2 to the 5th is equal 32, 2 to the 6th equals 64.</p>
    <p class="line_zh">记录基数为50的50左右，比方说6，因为我知道2到5是等于32,2到6等于64。</p>
    <p class="">So, what that means is, we have 16 references we have to do the array instead of 50,000.</p>
    <p class="line_zh">那么，这意味着，我们有16个参考，我们必须做数组而不是50,000。</p>
    <p class="">That's almost a factor of a thousand, so what that ended up meaning is that when the user clicks translate, instead of
        taking ten seconds, it was what appeared to be instantaneous.</p>
    <p class="line_zh">这几乎是千分之一，所以最终的意思是，当用户点击翻译时，而不是花费十秒钟，这似乎是瞬间的。</p>
    <p class="">It was well under a tenth of a second.</p>
    <p class="line_zh">这还不到十分之一秒。</p>
    <p class="">So in summary, what we've seen is that the runtime of binary search is big theta of log n.</p>
    <p class="line_zh">总而言之，我们所看到的是二进制搜索的运行时间是log n的大值。</p>
    <p class="">Substantially quicker than the big theta of n that linear search takes.</p>
    <p class="line_zh">比线性搜索所需的n大的θ快得多。</p>
    <p class="">So sorted arrays really help.</p>
    <p class="">如此排序的数组确实有帮助</p>
    <p class="">In the next lesson we're going to be looking at a more complicated application of divide and conquer, where we actually
        have multiple subproblems instead of just one subproblem.</p>
    <p class="line_zh">在下一课中，我们将讨论一个更复杂的分而治之的应用，其中我们实际上有多个子问题而不是一个子问题。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 33 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_33">第01章 problem overview and naive solution
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01问题概述和天真的解决方案</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this lecture we're going to talk about a more complicated divide-and-conquer algorithm to solve polynomial multiplication.</p>
    <p class="line_zh">在这个讲座中，我们将讨论一个更复杂的分而治之算法来解决多项式乘法。</p>
    <p class="">So first we'll talk about what polynomial multiplication is.</p>
    <p class="line_zh">首先我们将讨论多项式乘法是什么。</p>
    <p class="">So polynomial multiplication is basically just taking two polynomials and multiplying them together.</p>
    <p class="line_zh">因此，多项式乘法基本上只取两个多项式并将它们相乘。</p>
    <p class="">It's used in a variety of ways in computer science.</p>
    <p class="line_zh">它在计算机科学中以各种方式使用。</p>
    <p class="">Error correcting codes, if you want to multiply large integers together.</p>
    <p class="line_zh">如果要将大整数相乘，则纠错代码错误。</p>
    <p class="">Right, so if you've got thousand digit integers and you want to multiply them together, there's a quicker way than doing
        it the normal way you learned in elementary school.</p>
    <p class="line_zh">是的，所以如果你有千位数的整数并且想要将它们相乘，那么比在小学学习的正常方式更快。</p>
    <p class="">And that uses the idea of multiplying polynomials.</p>
    <p class="line_zh">这使用了乘法多项式的思想。</p>
    <p class="">It is used for generating functions, and for convolution.</p>
    <p class="line_zh">它用于生成函数和卷积。</p>
    <p class="">Let's look at an example.</p>
    <p class="line_zh">我们来看一个例子。</p>
    <p class="">So let's say you have polynomial A, which is 3 x squared + 2x + 5, and polynomial B, which is 5 x squared + x + 2.</p>
    <p class="line_zh">因此，假设您有多项式A，即3 x平方+ 2x + 5，以及多项式B，即5 x平方+ x + 2。</p>
    <p class="">If you multiply them together you get 15 x to the fourth + 13 x cubed + 33 x squared + 9x + 10.</p>
    <p class="line_zh">如果将它们相乘，则得到15 x到第四个+ 13 x立方+ 33 x平方+ 9x + 10。</p>
    <p class="">Why is that? Well, let's look, for instance the 15 x to the fourth comes from multiplying 3 x squared times 5 x squared,
        that's 15x to the fourth.</p>
    <p class="line_zh">这是为什么？那么，让我们看一下，例如，15 x到第四个来自3 x平方乘以5 x平方，即15x到第四个。</p>
    <p class="">The 10 comes from multiplying 5 by 2.</p>
    <p class="line_zh">10来自5乘以2。</p>
    <p class="">The 13 x cubed comes from 3 x squared times x, which is 3 x cubed, plus 2x times 5 x squared, which is 10 x cubed.</p>
    <p class="line_zh">13 x立方体来自3 x平方倍x，3 x立方，加2 x乘5 x平方，10 x立方。</p>
    <p class="">For a total of 13 x cubed.</p>
    <p class="line_zh">总共13 x立方。</p>
    <p class="">So let's look at the problem statement.</p>
    <p class="line_zh">那么让我们看一下问题陈述。</p>
    <p class="">So we're going to have two n- 1 degree polynomials, all right? a sub n-1 is the coefficient of the x to the n-1 all the
        way down to a0 which is the coefficient of the x to the 0 term or the one term.</p>
    <p class="line_zh">所以我们将有两个n-1次多项式，好吧？子n-1是x到n-1的系数，一直到a0，即x到0项或一个项的系数。</p>
    <p class="">And then we similarly have a b polynomial as well.</p>
    <p class="line_zh">然后我们同样也有ab多项式。</p>
    <p class="">Now first you may wonder what happens if you actually want to multiply polynomials that don't happen to have the same
        degree? What if you want to multiply a degree three polynomial times a degree two polynomial? Right, where the degree
        is just the exponent of the highest term.</p>
    <p class="line_zh">首先你可能想知道如果你真的想要乘以不具有相同度数的多项式会发生什么？如果你想将度数三次多项式乘以二次多项式怎么办？是的，学位只是最高学期的指数。</p>
    <p class="">Well in that case, what you you could do is just pad out the smaller polynomial, the lower degree polynomial, to have
        zeros for its earlier coefficients.</p>
    <p class="line_zh">那么在这种情况下，你能做的就是填充较小的多项式，即较低次多项式，使其早期系数为零。</p>
    <p class="">I'll give an example of that in just a second.</p>
    <p class="line_zh">我会在一秒钟内给出一个例子。</p>
    <p class="">And then the product polynomial is the result that we want to come up with so that's a higher degree polynomial, right?
        If our incoming polynomials, are degree n- 1, then we're going to get a term of the x to the n- 1 in a, times x to
        the n- 1 in b, and that's going to give us an x to the 2n- 2 in the c term.</p>
    <p class="line_zh">然后产品多项式是我们想要得到的结果，这是一个更高次多项式，对吗？如果我们的输入多项式是度数n-1，那么我们将得到一个x的项到a中的n-1，乘以x到n中的n-1，这将给我们一个x到c项中的2n-2。</p>
    <p class="">So, the c sub 2n-2 term, comes about from multiplying the a sub n-1 term and the b sub n-1 term.</p>
    <p class="line_zh">因此，c sub 2n-2项来自a sub n-1项和b sub n-1项的乘法。</p>
    <p class="">The c sub 2n-3 term comes from the a sub n-1, b sub n-2, and a sub n-2, b sub n-1.</p>
    <p class="line_zh">c sub 2n-3项来自a sub n-1，b sub n-2和sub n-2，b sub n-1。</p>
    <p class="">So it's got two terms that multiply together.</p>
    <p class="line_zh">所以它有两个术语相乘。</p>
    <p class="">The c sub 2n-4 term would have three terms that multiply together.</p>
    <p class="line_zh">c sub 2n-4术语将有三个术语相乘。</p>
    <p class="">And we have more and more terms that get multiplied and summed together, and then fewer and fewer back down.</p>
    <p class="line_zh">而且我们有越来越多的术语成倍增加并相加，然后越来越少的退缩。</p>
    <p class="">So c sub 2 has three pairs which get added together, c sub 1 has two pairs and c sub 0 has one pair.</p>
    <p class="line_zh">因此，c sub 2有三对加在一起，c sub 1有两对，c sub 0有一对。</p>
    <p class="">So here's an example.</p>
    <p class="line_zh">所以这是一个例子。</p>
    <p class="">This is actually the same example we had before.</p>
    <p class="line_zh">这实际上是我们之前的例子。</p>
    <p class="">So n is three and all we need, notice, are the coefficients.</p>
    <p class="line_zh">所以n是三，我们需要注意的是系数。</p>
    <p class="">We don't actually need to have the x's written out.</p>
    <p class="line_zh">我们实际上并不需要写出x。</p>
    <p class="">So 3, 2, and 5 means 3 x squared plus 2x plus 5.</p>
    <p class="line_zh">所以3,2和5意味着3 x平方加2x加5。</p>
    <p class="">5, 1, 2 means 5 x squared plus x plus 2.</p>
    <p class="line_zh">5,1,2表示5 x平方加x加2。</p>
    <p class="">What if B were only a degree one polynomial? It was just x plus 2.</p>
    <p class="line_zh">如果B只是一次多项式怎么办？它只是x加2。</p>
    <p class="">Well then we would set B equal 0, 1, 2.</p>
    <p class="line_zh">那么我们将B设置为0,1,2。</p>
    <p class="">That is, B's x squared term is 0 x squared.</p>
    <p class="line_zh">也就是说，B的x平方项是0 x平方。</p>
    <p class="">So A(x) is this, B(x) is that.</p>
    <p class="line_zh">所以A（x）就是这个，B（x）就是这个。</p>
    <p class="">When you multiply them together, we get the same result we got before.</p>
    <p class="line_zh">当你将它们相乘时，我们得到的结果与之前相同。</p>
    <p class="">And now we just pluck off the coefficients here, so the 15, the 13, the 33, the 9, and the 10.</p>
    <p class="line_zh">现在我们只是在这里取出系数，所以15,13,​​33,9和10。</p>
    <p class="">And that's our resulting answer: those coefficients.</p>
    <p class="line_zh">这就是我们得到的答案：那些系数。</p>
    <p class="">So let's look at a naive algorithm to solve this.</p>
    <p class="line_zh">那么让我们看一个天真的算法来解决这个问题。</p>
    <p class="">The naive algorithm basically just says, well first off, let's create a product array.</p>
    <p class="line_zh">天真的算法基本上只是说，首先，让我们创建一个产品数组。</p>
    <p class="">This is basically going to be the C, the result, and it's going to be of highest degree 2n-2.</p>
    <p class="line_zh">这基本上是C，结果，它将是最高度2n-2。</p>
    <p class="">So it's going to have 2n-1 terms all the way from the 0 term up to the 2n-2 term.</p>
    <p class="line_zh">所以它从0个词到2n-2个词一直有2n-1个词。</p>
    <p class="">So we'll initialize it to 0, and then we'll have a nested for loop.</p>
    <p class="line_zh">所以我们将它初始化为0，然后我们将有一个嵌套的for循环。</p>
    <p class="">For i equals 0 to n-1, for j equals 0 to n-1.</p>
    <p class="line_zh">对于i等于0到n-1，对于j等于0到n-1。</p>
    <p class="">And at every time, what we'll do is we will calculate a particular pair.</p>
    <p class="line_zh">而且每次我们要做的就是计算一对特定的一对。</p>
    <p class="">So we'll calculate the A[i], B[j] pair, multiply them together and add them into the appropriate product.</p>
    <p class="line_zh">因此，我们将计算A [i]，B [j]对，将它们相乘并将它们添加到适当的产品中。</p>
    <p class="">Which is the appropriate product to put it in? It's the i + j case.</p>
    <p class="line_zh">将它放入适当的产品中是哪种？这是i + j案例。</p>
    <p class="">As an example, when i is 0 and j is 0, we calculate A at 0 times B at 0 and we add that to product at 0.</p>
    <p class="line_zh">例如，当i为0且j为0时，我们在0处将A计算为0乘以B，并将其添加到0处的乘积。</p>
    <p class="">So that says the two zero-degree terms in A and B get multiplied together to the zero-degree term in C.</p>
    <p class="line_zh">这就是说A和B中的两个零度项一起乘以C中的零度项。</p>
    <p class="">At the other extreme, if i is n-1 and j is n-1, we take A at n-1 times B at n-1 and we store that in the product of 2n-2.</p>
    <p class="line_zh">在另一个极端，如果i是n-1且j是n-1，我们在n-1处取A的n-1倍，并将其存储在2n-2的乘积中。</p>
    <p class="">As you can see, the intermediate values in product are going to have more terms added to them than the edges.</p>
    <p class="line_zh">如您所见，产品中的中间值将添加更多的术语而不是边缘。</p>
    <p class="">And, of course, then we return the product.</p>
    <p class="line_zh">当然，然后我们返回产品。</p>
    <p class="">How long does this take? Well, this takes order n squared.</p>
    <p class="line_zh">这需要多长时间？好吧，这需要n平方的顺序。</p>
    <p class="">Clearly, we've got two for loops, one smaller for loop that's from 0 to 2n-2, so that's order n.</p>
    <p class="line_zh">显然，我们有两个for循环，一个小循环，从0到2n-2，所以这是n阶。</p>
    <p class="">And then a nested for loop, where i goes from 0 to n-1, j goes from 0 to n-1, so those each go through the first one
        n times, the second one n squared times.</p>
    <p class="line_zh">然后是一个嵌套的for循环，其中i从0变为n-1，j从0变为n-1，因此每个都经历n次n次，第二次n次平方次。</p>
    <p class="">So our runtime is O(n squared).</p>
    <p class="line_zh">所以我们的运行时间是O（n平方）。</p>
    <p class="">In the next video, we're going to look at a divide and conquer algorithm to solve this problem.</p>
    <p class="line_zh">在下一个视频中，我们将看一个分而治之的算法来解决这个问题。</p>
    <p class="">Although, we'll see that it too will be somewhat naive.</p>
    <p class="line_zh">虽然，我们会发现它也有些幼稚。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 34 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_34">第02章 naive divide and conquer algorithm
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02天真分而治之算法</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">So let's look at a naive divide and conquer algorithm, to solve polynomial multiplication problem.</p>
    <p class="line_zh">让我们看一个天真的分而治之算法，来解决多项式乘法问题。</p>
    <p class="">The idea is, we're going to take our long polynomial and we're going to break it in two parts.</p>
    <p class="line_zh">我们的想法是，我们将采用我们的长多项式，我们将分两部分进行分解。</p>
    <p class="">The upper half and the lower half.</p>
    <p class="line_zh">上半部分和下半部分。</p>
    <p class="">So A(x) is going to be D sub one of X ,times x sub n over 2, plus d sub 0 of x, the bottom half.</p>
    <p class="line_zh">所以A（x）将成为X中的D sub，乘以2中的x sub n，加上x的d sub 0，即下半部分。</p>
    <p class="">D sub 1 of x, since we've pulled out x sub n over 2 terms, it's lowest term is actually, just a sub n over 2.</p>
    <p class="line_zh">由于我们已经在2个项中拉出了x sub n，所以它的最低项实际上只是一个超过2的子n。</p>
    <p class="">So we have two parallel sub polynomials, the high and the low.</p>
    <p class="line_zh">所以我们有两个并行的子多项式，即高和低。</p>
    <p class="">We do the same thing for B.</p>
    <p class="line_zh">我们为B做同样的事情。</p>
    <p class="">So we break that into E sub 1 of x, and E sub 0 of x.</p>
    <p class="line_zh">所以我们把它分成x的E sub 1和x的E sub 0。</p>
    <p class="">Again, where E sub 1 of x is the high terms, E sub 0 of x is the low terms.</p>
    <p class="line_zh">同样，在x的E sub 1是高项的情况下，x的E sub 0是低项。</p>
    <p class="">When we do our multiplication, then, we just multiply together D 1, x sub n over 2 plus D 0 and E 1 times x sub n over
        2 plus E 0.</p>
    <p class="line_zh">当我们进行乘法运算时，我们只需将D 1，x sub n乘以2加D 0和E 1乘以x sub n乘以2加E 0。</p>
    <p class="">And that then yields for terms, D sub 1 E sub 1 times x sub n, D sub 1 E sub 0 + D sub 0 E sub 1 times x sub n/2 + D
        sub 0 E sub 0.</p>
    <p class="line_zh">然后产生术语，D sub 1 E sub 1次x sub n，D sub 1 E sub 0 + D sub 0 E sub 1次x sub n / 2 + D sub 0 E sub 0。</p>
    <p class="">The key here is that, we now just need to calculate D1 E1, D1 E0, D0 E1, and D0 E0.</p>
    <p class="line_zh">关键在于，我们现在只需要计算D1 E1，D1 E0，D0 E1和D0 E0。</p>
    <p class="">Those are all polynomials of degree n over 2.</p>
    <p class="line_zh">这些都是n次超过2的多项式。</p>
    <p class="">And so, now we can go ahead and use a recursive solution to solve this problem.</p>
    <p class="line_zh">所以，现在我们可以继续使用递归解决方案来解决这个问题。</p>
    <p class="">So it gives us a divide and conquer problem.</p>
    <p class="line_zh">所以它给了我们一个分而治之的问题。</p>
    <p class="">Its run time is T of n, equals 4 T of n over 2.</p>
    <p class="line_zh">它的运行时间是T的n，等于4的n超过2。</p>
    <p class="">Why 4? 4, because we're breaking into 4 subproblems.</p>
    <p class="line_zh">为什么4？4，因为我们分成了4个子问题。</p>
    <p class="">Each of them takes time T of n over 2 ecause the problem is broken in half.</p>
    <p class="line_zh">由于问题被打破了一半，因此每个时间T取n超过2的时间。</p>
    <p class="">Plus, then, in order to take the results and do our addition that's going to take order n time.</p>
    <p class="line_zh">另外，为了获得结果并进行我们的添加，这将需要时间。</p>
    <p class="">So some constant k, times that.</p>
    <p class="line_zh">所以有些常数k，倍。</p>
    <p class="">Let's look at an example.</p>
    <p class="line_zh">我们来看一个例子。</p>
    <p class="">So we have, n is 4, so we have degree three polynomials.</p>
    <p class="line_zh">所以我们有，n是4，所以我们有三次多项式。</p>
    <p class="">And we're going to break up A of x into the top half, 4x plus 3, and the bottom half, 2x plus 1.</p>
    <p class="line_zh">而且我们要将A的x分为上半部分，4x加3，下半部分，2x加1。</p>
    <p class="">Similarly, we're going to break up the top half of B of x.</p>
    <p class="line_zh">同样，我们将打破x的B的上半部分。</p>
    <p class="">X cubed plus 2 x squared just becomes x plus 2.</p>
    <p class="line_zh">X立方加2 x平方只是x加2。</p>
    <p class="">And 3x plus 4, stays at 3x plus 4.</p>
    <p class="line_zh">3倍加4倍，3倍加4倍。</p>
    <p class="">Now, we compute D1 E1.</p>
    <p class="line_zh">现在，我们计算D1 E1。</p>
    <p class="">So multiplying together, 4x + 3, times x plus 2, gives us 4 x squared + 11x + 6.</p>
    <p class="line_zh">所以乘以4x + 3乘以x加2，得到4 x平方+ 11x + 6。</p>
    <p class="">Similarly, we calculate D1 E0, D0 E1, and D0 E0.</p>
    <p class="line_zh">同样，我们计算D1 E0，D0 E1和D0 E0。</p>
    <p class="">Now we've done all four of those computations, AB is just D1 E1, 4 x squared + 11x + 6 times x to the 4th, plus the sum
        of D1 E0 and D0 E1, times x squared, plus finally D0 E0.</p>
    <p class="line_zh">现在我们完成了所有这四个计算，AB只是D1 E1,4 x平方+ 11x + 6倍x到4，再加上D1 E0和D0 E1的总和，乘以x平方，再加上D0 E0。</p>
    <p class="">If we sum this all together, we get 4 x to the 6th, plus 11 x to the 5th, plus 20 x to the 4th, plus 30 x cubed, plus
        20 x squared, plus 11x plus 4.</p>
    <p class="line_zh">如果我们将所有这些加在一起，我们得到4 x到6，加上11 x到5，加上20 x到4，再加上30 x立方，加上20 x平方，再加上11 x加4。</p>
    <p class="">Which is our solution.</p>
    <p class="line_zh">这是我们的解决方案。</p>
    <p class="">Now, how long's this take to run? We're going to look at that in a moment.</p>
    <p class="line_zh">现在，这需要多长时间才能运行？我们马上就会看一下。</p>
    <p class="">Let's look at the actual code for it.</p>
    <p class="line_zh">我们来看看它的实际代码。</p>
    <p class="">So we're going to compute a resulting array, from 0 to 2n-2, so is all the results coefficients.</p>
    <p class="line_zh">所以我们要计算一个结果数组，从0到2n-2，所有结果系数都是如此。</p>
    <p class="">And our base case is that if n of size 1, we're going to multiply together A at a sub l, plus B at b sub l.</p>
    <p class="">我们的基本情况是，如果大小为1的n，我们将在子l加上A加上b sub l加上B.</p>
    <p class="">Let's look at those parameters again.</p>
    <p class="line_zh">让我们再看看这些参数。</p>
    <p class="">So A and B are our arrays of coefficients, n is the size of the problem, a sub l is the first coefficient that we're
        interested in.</p>
    <p class="line_zh">所以A和B是我们的系数数组，n是问题的大小，sub l是我们感兴趣的第一个系数。</p>
    <p class="">And b sub l is the coefficient in B, that we're interested in.</p>
    <p class="line_zh">而b sub l是B中的系数，我们感兴趣。</p>
    <p class="">So we're going to be going from b sub l, b sub l plus one, b sub l plus two, etc.</p>
    <p class="line_zh">所以我们将从b sub l，b sub l加一，b sub l加两，等等。</p>
    <p class="">And for n times.</p>
    <p class="line_zh">并且n次。</p>
    <p class="">First thing we'll do, is multiply together the D sub one and E sub one.</p>
    <p class="line_zh">我们要做的第一件事就是将D sub one和E sub one相乘。</p>
    <p class="">So basically what we're doing, I'm sorry, the D sub zero and E sub zero.</p>
    <p class="line_zh">基本上我们正在做什么，对不起，D子零和E子零。</p>
    <p class="">So, what we're doing is taking A and B, we're reducing the problem size by 2 and we're starting with those same coefficients.</p>
    <p class="line_zh">所以，我们正在做的是采用A和B，我们将问题大小减少2，我们从相同的系数开始。</p>
    <p class="">And we're going to assign those to the lower half of the elements in R.</p>
    <p class="line_zh">我们将把这些分配给R中元素的下半部分。</p>
    <p class="">Then we're going to do something similar, where we take the upper halves of each of A and B.</p>
    <p class="line_zh">然后我们将做类似的事情，我们采取A和B各自的上半部分。</p>
    <p class="">So again, the problem size becomes n/2, but now we're moving the lower coefficient we're interested in from a sub l to
        a sub l + n/2 and b sub l to b sub l + n/2.</p>
    <p class="line_zh">再次，问题大小变为n / 2，但现在我们将我们感兴趣的较低系数从sub l移动到sub l + n / 2和b sub l到b sub l + n / 2。</p>
    <p class="">And we're going to assign those to the high coefficients in our result.</p>
    <p class="line_zh">我们将在结果中将这些分配给高系数。</p>
    <p class="">Then, what we have to do is calculate D sub 0 E1, and D1 E0.</p>
    <p class="line_zh">然后，我们要做的是计算D sub 0 E1和D1 E0。</p>
    <p class="">And then, sum those together.</p>
    <p class="line_zh">然后，将它们加在一起。</p>
    <p class="">When we sum those together, we're going to assign those to the middle elements of the resulting array.</p>
    <p class="line_zh">当我们将它们相加时，我们将把它们分配给结果数组的中间元素。</p>
    <p class="">And we'll then return that result.</p>
    <p class="line_zh">然后我们将返回该结果。</p>
    <p class="">Now the question comes up, how long does it take? So we have an original problem of size n, we break it into four problems
        of size n over 2.</p>
    <p class="line_zh">现在问题出现了，需要多长时间？所以我们有一个大小为n的原始问题，我们把它分成4个大小超过2的问题。</p>
    <p class="">So, level 0 we have size n, level 1 we have size of n over 2, at level i, our problems are of size n over 2 to the i.</p>
    <p class="line_zh">所以，级别0我们有大小n，级别1我们有n大小超过2，在级别i，我们的问题是大小n超过2到i。</p>
    <p class="">And all the way down to the bottom of the tree is at log base 2 of n, and each of the problems are of size 1.</p>
    <p class="line_zh">一直到树的底部是n的log 2，每个问题的大小都是1。</p>
    <p class="">How many problems do we have? At level 0, we have 1 problem.</p>
    <p class="line_zh">我们有多少问题？在0级，我们有1个问题。</p>
    <p class="">We have then 4 problems.</p>
    <p class="line_zh">我们有4个问题。</p>
    <p class="">If we go to the i'th level, we have 4 to the i problems.</p>
    <p class="line_zh">如果我们进入第i级，我们就会遇到4个问题。</p>
    <p class="">And at the very bottom, then we have 4 to the log base 2 of n problems.</p>
    <p class="line_zh">而在最底层，那么我们有4个问题的日志基数2。</p>
    <p class="">How much work is there? Well, we just need to multiply together the number of problems times the amount of work, so we
        have kn here, and 4 times, 4 because there are 4 problems, kn over 2, because the problem size is n over 2 and the
        amount of work we're doing at each level is k times n over 2 per problem.</p>
    <p class="line_zh">有多少工作？好吧，我们只需要将问题的数量乘以工作量，所以我们知道这里有4次，4次因为有4个问题，因此问题大小超过2且数量超过2我们在每个级别所做的工作是每次问题超过2次k次。</p>
    <p class="">So 4 kn over 2 just equals k times 2n, At the ith level for the i problems, each problem takes k times n over 2 to the
        i to deal with, we multiply together, k 2 to the i times n.</p>
    <p class="line_zh">所以4 kn超过2就等于k乘以2n，在i问题的第i级，每个问题需要k次n超过2来处理i，我们将它们相乘，k 2乘以i乘以n。</p>
    <p class="">And at the very bottom, we have k amount of work, we have a problem size of 1, times 4 to the log base 2 of n.</p>
    <p class="line_zh">在最底层，我们有大量的工作，我们有一个问题大小为1，乘以4到n的log 2。</p>
    <p class="">Well four the log base two of n, is just n squared.</p>
    <p class="line_zh">四个n的对数基数为2，只是n平方。</p>
    <p class="">So we have k n squared.</p>
    <p class="line_zh">所以我们已经知道了。</p>
    <p class="">Our total as we sum up all the work is going to be summation from i equals zero to log base two of n of four to the i
        k times n over two to the i.</p>
    <p class="line_zh">我们总结所有工作的总和将是从i等于零到记录基数为4的n中的两个到i的两倍到i的总和。</p>
    <p class="">And that just gets dominated by the very bottom term which is big theta of n squared.</p>
    <p class="line_zh">而这只是被n平方的大theta这个最底层的术语所支配。</p>
    <p class="">So that's what our runtime takes.</p>
    <p class="line_zh">这就是我们的运行时所需要的。</p>
    <p class="">This is kind of weird.</p>
    <p class="line_zh">这有点奇怪。</p>
    <p class="">We went through all this work to create a divide and conquer algorithm.</p>
    <p class="line_zh">我们完成了所有这些工作，以创建一个分而治之的算法。</p>
    <p class="">And yet, the run time is the same run time as it was with our naive original algorithm.</p>
    <p class="line_zh">然而，运行时间与我们天真的原始算法的运行时间相同。</p>
    <p class="">We're going to see in the next video, a way to redo our divide and conquer algorithm, so we have less work to do at each
        level, and so we actually get a better final run time.</p>
    <p class="line_zh">我们将在下一个视频中看到重做我们的分而治之算法的方法，因此我们在每个级别上都没有多少工作要做，因此我们实际上获得了更好的最终运行时间。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 35 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_35">第03章 faster divide and conquer algorithm
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">03更快的分而治之算法</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this video we'll look at creating a faster divide and conquer algorithm in order to solve the polynomial multiplication
        problem.
    </p>
    <p class="line_zh">在这个视频中，我们将着眼于创建一个更快的分而治之算法，以解决多项式乘法问题。</p>
    <p class="">This problem, this approach was invented by Karatsuba in the early 1960s.</p>
    <p class="line_zh">这个问题，这种方法是由Karatsuba在20世纪60年代早期发明的。</p>
    <p class="">So he was a graduate student of Komolgorov, a famous Russian mathematician.</p>
    <p class="line_zh">所以他是俄罗斯着名数学家科莫戈罗夫的研究生。</p>
    <p class="">And Komolgorov theorized that n squared was the best that one could do.</p>
    <p class="line_zh">而Komolgorov认为，n平方是最好的。</p>
    <p class="">So there was a lower bound of n squared, doing polynomial multiplication.</p>
    <p class="line_zh">所以有一个n平方的下界，做多项式乘法。</p>
    <p class="">Karatsuba, a grad student, heard the problem, went away, came back a week later with a solution.</p>
    <p class="line_zh">研究生Karatsuba听到了这个问题，离开了，一周后回来找了解决方案。</p>
    <p class="">So let's look at what is involved.</p>
    <p class="line_zh">那么让我们看一下所涉及的内容。</p>
    <p class="">So if we look at A(x) it's just a very simple polynomial, a1x + a0.</p>
    <p class="line_zh">因此，如果我们看A（x），它只是一个非常简单的多项式，a1x + a0。</p>
    <p class="">And B(x) = b1x + b0, and then C(x) is, what would match in there? a1b1x squared + (a1b0 + a0b1)x + a0b0.</p>
    <p class="line_zh">并且B（x）= b1x + b0，然后是C（x），那里会匹配什么？a1b1x平方+（a1b0 + a0b1）x + a0b0。</p>
    <p class="">So we'll notice here we need four multiplications.</p>
    <p class="line_zh">所以我们在这里注意到我们需要四次乘法运算。</p>
    <p class="">We need to multiply a1 times b1.</p>
    <p class="line_zh">我们需要乘以a1乘以b1。</p>
    <p class="">We need to multiply a1 times b0, a0 times b1, and a0 times b0.</p>
    <p class="line_zh">我们需要乘以a1乘以b0，a0乘以b1，a0乘以b0。</p>
    <p class="">This is how we did the divide and conquer in fact in our last video.</p>
    <p class="line_zh">这就是我们在上一个视频中实现分歧和征服的方式。</p>
    <p class="">So we need four multiplications.</p>
    <p class="line_zh">所以我们需要四次乘法。</p>
    <p class="">Karatsuba's insight was that there was a way to re-write C(x), so that you only needed to do three multiplications.</p>
    <p class="line_zh">Karatsuba的见解是有一种方法可以重写C（x），所以你只需要做三次乘法。</p>
    <p class="">So basically what he did is he re-wrote that inner term, a1b0 + a0b1 as something slightly more complicated.</p>
    <p class="line_zh">所以基本上他所做的就是重写那个内部术语，a1b0 + a0b1稍微复杂一些。</p>
    <p class="">So he added together, (a1 + a0) (b1 + b0).</p>
    <p class="line_zh">所以他加在一起，（a1 + a0）（b1 + b0）。</p>
    <p class="">So (a1 + a0) (b1 + b0) is just a1b1 + a0b1 + a1b0 + a0b0.</p>
    <p class="line_zh">所以（a1 + a0）（b1 + b0）只是a1b1 + a0b1 + a1b0 + a0b0。</p>
    <p class="">And then he subtracted out the a1b1 and the a0b0, so he's left with a1b0 + a0b1.</p>
    <p class="line_zh">然后他减去了a1b1和a0b0，所以他留下了a1b0 + a0b1。</p>
    <p class="">Which is exactly what's there to begin with.</p>
    <p class="line_zh">这正是从那开始的。</p>
    <p class="">The key here though, is how many multiplications are needed.</p>
    <p class="line_zh">这里的关键是需要多少次乘法。</p>
    <p class="">It only needs three multiplications.</p>
    <p class="line_zh">它只需要三次乘法。</p>
    <p class="">We need to compute a1 b1, even though we use it twice.</p>
    <p class="line_zh">我们需要计算a1 b1，即使我们使用它两次。</p>
    <p class="">We need to compute a0 b0, even again, though we use it only twice.</p>
    <p class="line_zh">我们需要再次计算a0 b0，尽管我们只使用它两次。</p>
    <p class="">And then we need to multiply together (a1 + a0) and (b1 + b0).</p>
    <p class="line_zh">然后我们需要将（a1 + a0）和（b1 + b0）相乘。</p>
    <p class="">So we do have some extra additions.</p>
    <p class="line_zh">所以我们确实有一些额外的补充。</p>
    <p class="">But the key is, when we have three multiplications instead of four.</p>
    <p class="line_zh">但关键是，当我们有三次乘法而不是四次。</p>
    <p class="">Why does this matter? Well, why it matters is because we are reducing the number of problems at each level.</p>
    <p class="line_zh">为什么这很重要？那么，重要的是因为我们正在减少每个级别的问题数量。</p>
    <p class="">But let's first look at an example.</p>
    <p class="line_zh">但我们先来看一个例子。</p>
    <p class="">So here we've got A(x).</p>
    <p class="line_zh">所以这里我们有A（x）。</p>
    <p class="">We're going to have 4 x cubed + 3 x squared + 2x +1.</p>
    <p class="line_zh">我们将有4 x立方+ 3 x平方+ 2x +1。</p>
    <p class="">B(x) = x cubed + 2 x squared + 3x + 4.</p>
    <p class="line_zh">B（x）= x立方+ 2 x平方+ 3x + 4。</p>
    <p class="">We're going to go ahead and pull out D1 and D0 like we did before.</p>
    <p class="line_zh">我们将像以前一样继续推出D1和D0。</p>
    <p class="">In our divide and conquer.</p>
    <p class="line_zh">在我们的分而治之。</p>
    <p class="">The key is what we're going to actually do in terms of the subproblems.</p>
    <p class="line_zh">关键是我们要在子问题上实际做的事情。</p>
    <p class="">So we have D1 and D0.</p>
    <p class="line_zh">所以我们有D1和D0。</p>
    <p class="">We have E1 and we have E0.</p>
    <p class="line_zh">我们有E1，我们有E0。</p>
    <p class="">We're going to compute D1 E1, again, just like we did before.</p>
    <p class="line_zh">我们将再次计算D1 E1，就像我们之前一样。</p>
    <p class="">We're going to compute D0 E0, again just like we did before.</p>
    <p class="line_zh">我们将再次计算D0 E0，就像我们之前一样。</p>
    <p class="">But now we won't compute D1 E0 and D0 E1.</p>
    <p class="line_zh">但现在我们不会计算D1 E0和D0 E1。</p>
    <p class="">Instead we're going to sum together D1 and D0.</p>
    <p class="line_zh">相反，我们要把D1和D0加在一起。</p>
    <p class="">Sum together E1 and E0.</p>
    <p class="line_zh">将E1和E0相加在一起。</p>
    <p class="">So (D1 + D0) is going to be (6x + 4).</p>
    <p class="line_zh">所以（D1 + D0）将是（6x + 4）。</p>
    <p class="">(E1 + E0) is going to be (4x plus 6).</p>
    <p class="line_zh">（E1 + E0）将是（4x加6）。</p>
    <p class="">And then we multiply those two polynomials together, yielding 24 x squared + 52x + 24.</p>
    <p class="line_zh">然后我们将这两个多项式相乘，得到24 x平方+ 52x + 24。</p>
    <p class="">So, so far, how many multiplications have we done? Three.</p>
    <p class="line_zh">那么，到目前为止，我们做了多少次乘法？三。</p>
    <p class="">And then, our final result for A(x) B(x) is D1E1 times x to the fourth +, now what do we do here? We take that (D1 +
        D0) (E1 + E0).</p>
    <p class="line_zh">然后，我们对A（x）B（x）的最终结果是D1E1倍x到第四个+，现在我们在这做什么？我们取（D1 + D0）（E1 + E0）。</p>
    <p class="">(24x squared + 52x + 24), okay? Add that in the second term.</p>
    <p class="line_zh">（24x平方+ 52x + 24），好吗？在第二学期添加。</p>
    <p class="">And then subtract out D1 E1.</p>
    <p class="line_zh">然后减去D1 E1。</p>
    <p class="">Subtract out D0 E0.</p>
    <p class="line_zh">减去D0 E0。</p>
    <p class="">And then our final term will be D0 E0.</p>
    <p class="line_zh">然后我们的最终用语将是D0 E0。</p>
    <p class="">If we simplify that middle portion, and all of it.</p>
    <p class="line_zh">如果我们简化中间部分，以及所有部分。</p>
    <p class="">We just end up with 4 x to the sixth + 11 x to the fifth + 20 x to the fourth + 3 x cubed + 20 x squared + 11x + 4.</p>
    <p class="line_zh">我们最终得到4 x到第六+ 11 x到第五+ 20 x到第四+ 3 x立方+ 20 x平方+ 11x + 4。</p>
    <p class="">Which is the exact same result we got doing it in the more naive divide and conquer.</p>
    <p class="line_zh">这是我们在更天真的分而治之中做到的完全相同的结果。</p>
    <p class="">And also the same way we'd do it if we did a straight naive problem, okay? So we get the same result, three multiplications
        instead of four multiplications.</p>
    <p class="line_zh">如果我们做一个直接天真的问题，我们也会这样做，好吗？所以我们得到相同的结果，三次乘法而不是四次乘法。</p>
    <p class="">That extra multiplication makes a big difference.</p>
    <p class="line_zh">额外的乘法会带来很大的不同。</p>
    <p class="">Let's look at our runtime.</p>
    <p class="line_zh">我们来看看我们的运行时。</p>
    <p class="">So our initial problem is of size n.</p>
    <p class="line_zh">所以我们最初的问题是大小为n。</p>
    <p class="">When we break it down, we have three problems of size n over 2, again, rather than 4.</p>
    <p class="line_zh">当我们分解它时，我们有三个大小为n超过2的问题，而不是4。</p>
    <p class="">So level 0, problem size n.</p>
    <p class="line_zh">所以级别0，问题大小n。</p>
    <p class="">Level 1, a problem of size n over 2.</p>
    <p class="line_zh">等级1，大小为n超过2的问题。</p>
    <p class="">At level i, our problems are of size n over 2 to the i, just like they were in the other divide and conquer problem.</p>
    <p class="line_zh">在第一级，我们的问题是大小超过2的i，就像他们在另一个分而治之的问题。</p>
    <p class="">And we have the same number of leaves.</p>
    <p class="line_zh">我们有相同数量的叶子。</p>
    <p class="">So at log base 2 of n level, all the problems are of size 1.</p>
    <p class="line_zh">所以在n级的log 2中，所有问题都是1。</p>
    <p class="">And the number of problems that we have, 1 of them at level 0, 3 instead of 4 at level 1, 3 to the i.</p>
    <p class="line_zh">我们遇到的问题数量，其中1个在0级，3个而不是4级，1级，3个。</p>
    <p class="">instead of 4 to the i, at level i.</p>
    <p class="line_zh">在i级，而不是4到i。</p>
    <p class="">And 3 to the log base 2 of n, instead of 4 to the log base, 2 of n at the bottom level.</p>
    <p class="line_zh">并且3到n的对数基数2，而不是4到对数基数，2到n的底层。</p>
    <p class="">How much work? We'll multiply together, so we'll figure out for each problem how much it takes.</p>
    <p class="line_zh">多少工作？我们将一起繁殖，因此我们将为每个问题找出需要多少的问题。</p>
    <p class="">In this case at level 0 it's kn.</p>
    <p class="line_zh">在这种情况下，在0级它是kn。</p>
    <p class="">At level 1, each problem takes k(n/2) work.</p>
    <p class="line_zh">在级别1，每个问题需要k（n / 2）个工作。</p>
    <p class="">And there are three of them.</p>
    <p class="line_zh">其中有三个。</p>
    <p class="">So it's k(3/2) n.</p>
    <p class="line_zh">所以它是k（3/2）n。</p>
    <p class="">At the ith level, we end up with k times (3/2) to the i times n.</p>
    <p class="line_zh">在第i级，我们最终得到k次（3/2）到i次n。</p>
    <p class="">And at the bottom level, k times 3 to the log base 2 of n.</p>
    <p class="line_zh">并且在底层，k乘以3到n的对数基数2。</p>
    <p class="">a to the log base b of c, is the same thing as c to the log base b of a.</p>
    <p class="line_zh">a到c的log对象b，与a的log对象b的c相同。</p>
    <p class="">So therefore this is the same as kn to the log base 2 of 3.</p>
    <p class="line_zh">因此，这与3的对数基数2的kn相同。</p>
    <p class="">We sum those, summation from i = zero to log base 2 of n of 3 to the i times k times n over 2 to the i.</p>
    <p class="line_zh">我们总结那些，从i = 0到n的3的对数基数2到i乘以2的k倍n乘以i。</p>
    <p class="">This is bounded, it's this geometric series bounded by the last term.</p>
    <p class="line_zh">这是有限的，它是由最后一个术语限定的几何系列。</p>
    <p class="">Which is big Theta of n to the log base 2 of 3.</p>
    <p class="line_zh">哪个是n的大Theta到3的基数2。</p>
    <p class="">Log base 2 of 3 is about 1.58.</p>
    <p class="line_zh">2的对数基数约为1.58。</p>
    <p class="">So, we now have a problem where our solution is big Theta of n to the 1.58.</p>
    <p class="line_zh">所以，我们现在遇到的问题是我们的解决方案是n到1.58的大Theta。</p>
    <p class="">Compared to our original problem, which had a big Theta of n squared solution.</p>
    <p class="line_zh">与我们原来的问题相比，它有一个很大的θ平方解决方案。</p>
    <p class="">So this makes a huge difference as n gets large, in terms of our final runtime.</p>
    <p class="line_zh">因此，就最终运行时而言，当n变大时，这会产生巨大的差异。</p>
    <p class="">It's not uncommon for divide and conquer algorithms sometimes to require sort of a way of looking at it in terms of breaking
        up a problem.</p>
    <p class="line_zh">分裂和征服算法有时需要某种方式来分解问题，这种情况并不少见。</p>
    <p class="">So that you have fewer subproblems.</p>
    <p class="line_zh">这样你就可以减少子问题。</p>
    <p class="">And because of the compounding of the fact that the more subproblems at a level, you have more, and more, and more.</p>
    <p class="line_zh">并且由于在一个级别上存在更多子问题这一事实的复合，您拥有更多，更多，更多。</p>
    <p class="">Reducing the number of subproblems, reduces the final runtime.</p>
    <p class="line_zh">减少子问题的数量，减少最终的运行时间。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 36 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_36">第01章 what is the master theorem
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01什么是主定理</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Here we're going to talk about the master theorem.</p>
    <p class="line_zh">在这里，我们将讨论主定理。</p>
    <p class="">We'll describe what the master theorem is and how to use it.</p>
    <p class="line_zh">我们将描述主定理是什么以及如何使用它。</p>
    <p class="">And we'll reserve to the next video a proof.</p>
    <p class="line_zh">我们将保留下一个视频的证明。</p>
    <p class="">So we've had many occasions where we have had to write a recurrence relation for a divide and conquer problem.</p>
    <p class="line_zh">所以我们曾经有过许多场合，我们不得不为分而治之的问题写一个递归关系。</p>
    <p class="">This is an example of one for binary search.</p>
    <p class="line_zh">这是二进制搜索的示例。</p>
    <p class="">We break a problem down into a problem half as big and we do a constant amount of work at each level.</p>
    <p class="line_zh">我们将问题分解为一半大的问题，并且我们在每个级别进行一定量的工作。</p>
    <p class="">And this gives us a solution T(n) = O(log n).</p>
    <p class="line_zh">这给了我们一个解T（n）= O（log n）的解。</p>
    <p class="">The problem is for each one of these we have to create a recurrence tree, figure out how much work is done at each level,
        sum up that work.</p>
    <p class="line_zh">问题是每一个我们必须创建一个递归树，计算每个级别完成了多少工作，总结这项工作。</p>
    <p class="">That's a lot to do to solve each recurrence relation.</p>
    <p class="line_zh">要解决每个递归关系，还有很多工作要做。</p>
    <p class="">Here's an example that we used for the polynomial multiplication.</p>
    <p class="line_zh">这是我们用于多项式乘法的一个例子。</p>
    <p class="">So we broke a problem into four sub-problems, each half the size, and did a linear amount of work.</p>
    <p class="line_zh">因此，我们将问题分解为四个子问题，每个问题的大小只有一半，并且做了一系列线性工作。</p>
    <p class="">And the solution was T(n) = O(n squared).</p>
    <p class="line_zh">并且解决方案是T（n）= O（n平方）。</p>
    <p class="">When we had the more efficient algorithm, where we had only three sub-problems instead of four, we then got a solution
        of O(n to the log base 2 of 3).</p>
    <p class="line_zh">当我们有更高效的算法时，我们只有三个子问题而不是四个子问题，然后我们得到一个O的解（n到3的对数基数为2）。</p>
    <p class="">Sometimes we break a problem into only two subproblems and there the solution is O(n log n).</p>
    <p class="line_zh">有时我们只将问题分解为两个子问题，解决方案是O（n log n）。</p>
    <p class="">So, wouldn't it be nice if there was a way that we just had a formula to tell us what the solution is rather than having
        to create this recurrence tree each time? And that's what the Master Theorem basically does.</p>
    <p class="line_zh">那么，如果我们只有一个公式来告诉我们解决方案是什么而不是每次都必须创建这个重复树，那不是很好吗？这就是主定理基本上做的。</p>
    <p class="">So, the Master Theorem says if you have a recurrence relation T(n) equals a, some constant, times T( the ceiling of n
        divided by b) + a polynomial in n with degree d.</p>
    <p class="line_zh">所以，主定理说如果你有一个递推关系T（n）等于a，一些常数，乘以T（n的上限除以b）+ n中的多项式，其中d为d。</p>
    <p class="">And that ceiling, by the way, could just as well be a floor or not be there at all if n were a power of b.</p>
    <p class="line_zh">顺便说一下，如果n是b的力量，那么天花板也可以是一个地板，或者根本不存在。</p>
    <p class="">In any case, the a is a constant greater than 0.</p>
    <p class="line_zh">在任何情况下，a都是大于0的常数。</p>
    <p class="">b is greater than 1 because we want to actually make sure the problem size gets smaller.</p>
    <p class="line_zh">b大于1，因为我们希望确实确保问题大小变小。</p>
    <p class="">And d is greater than equal to 0.</p>
    <p class="line_zh">并且d大于等于0。</p>
    <p class="">Well, in that case, we have a solution for T of n.</p>
    <p class="line_zh">那么，在这种情况下，我们有一个解决T的n。</p>
    <p class="">There are three sub cases.</p>
    <p class="line_zh">有三个子案例。</p>
    <p class="">Case number 1, and all of these cases depend on the relationship between d, a, and b.</p>
    <p class="line_zh">案例编号1，所有这些案例都取决于d，a和b之间的关系。</p>
    <p class="">In particular, is d greater than log base b of a? If so, the solution is just this polynomial in n, O(of n to the d).</p>
    <p class="line_zh">特别是，d大于log的基数b？如果是这样，解决方案只是n，O（n到d）的多项式。</p>
    <p class="">If d is exactly equal log base b of a, then the solution is big O of n to the d with an extra factor of log n.</p>
    <p class="line_zh">如果d恰好等于a的log base b，那么解决方案是d的大O，其中log n的额外因子。</p>
    <p class="">And finally, if d is less than log base b of a, then the solution is big O of n to the log base b of a.</p>
    <p class="line_zh">最后，如果d小于a的log b，那么解决方案是a的大O到a的log b。</p>
    <p class="">So let's look at some applications of this theorem.</p>
    <p class="line_zh">那么让我们来看看这个定理的一些应用。</p>
    <p class="">So here's one where we go back to the polynomial multiplication.</p>
    <p class="line_zh">所以这是我们回到多项式乘法的地方。</p>
    <p class="">Here a is 4, b is 2, and d is 1.</p>
    <p class="line_zh">这里a是4，b是2，d是1。</p>
    <p class="">Because O(n) is just O(n to the 1).</p>
    <p class="line_zh">因为O（n）只是O（n到1）。</p>
    <p class="">And we look at the relationship between d, which is 1, and log base b of a, which is log base 2 of 4 or 2.</p>
    <p class="line_zh">我们来看看d（1）和a的log base b之间的关系，它是4或2的对数基数2。</p>
    <p class="">Well clearly d is less than log base b of a, so we're in case three.</p>
    <p class="line_zh">很明显d小于a的log b，所以我们就是三个。</p>
    <p class="">Therefore T(n) = O(n to the log base b of a), or just O(n squared).</p>
    <p class="line_zh">因此，T（n）= O（对于a的对数基数b为n），或者仅为O（n的平方）。</p>
    <p class="">If now we change the 4 to a 3, a is 3, b is 2, d is 1.</p>
    <p class="line_zh">如果现在我们将4改为3，a为3，b为2，d为1。</p>
    <p class="">Now d is still less than log base b of a because log base 2 of 3 is greater than 1, and so again we're in case three.</p>
    <p class="line_zh">现在d仍然小于a的log base b，因为3的log base 2大于1，所以我们再次讨论3。</p>
    <p class="">T(n) equals O(n to the log base b of a), which equals O(n to the log base 2 of 3).</p>
    <p class="line_zh">T（n）等于O（n对应于a的对数基数b），等于O（n对数基数2为3）。</p>
    <p class="">If we reduce the 3 down to a 2 what happens? Well here, a is 2, b is 2, d is 1.</p>
    <p class="line_zh">如果我们将3减少到2会发生什么？那么，a是2，b是2，d是1。</p>
    <p class="">Log base b of a is log base 2 of 2, which is just 1.</p>
    <p class="line_zh">a的log base b是2的log 2，也就是1。</p>
    <p class="">So now d is equal log base b or a.</p>
    <p class="line_zh">所以现在d等于log base b或a。</p>
    <p class="">We're in case two now.</p>
    <p class="line_zh">我们现在遇到两个。</p>
    <p class="">And so, T of n equals O(n log n).</p>
    <p class="line_zh">因此，n的T等于O（n log n）。</p>
    <p class="">And now this shows an example also of case two.</p>
    <p class="line_zh">现在，这也显示了案例二的一个例子。</p>
    <p class="">So this is the binary search example.</p>
    <p class="line_zh">所以这是二进制搜索示例。</p>
    <p class="">A is 1, b is 2, d is 0.</p>
    <p class="line_zh">A是1，b是2，d是0。</p>
    <p class="">Well the log base two of one, log base b of a, is equal to zero.</p>
    <p class="line_zh">那么一个日志库中的两个，a的基数b，等于零。</p>
    <p class="">So d is equal to log base b of a.</p>
    <p class="line_zh">所以d等于a的log base b。</p>
    <p class="">We're in case two, T(n) = O(n to the d log n), which is in the 0 log n, which is just O(log n).</p>
    <p class="line_zh">我们遇到两种情况，T（n）= O（n到n log n），它在0 log n中，它只是O（log n）。</p>
    <p class="">And a final example where we are actually in case one.</p>
    <p class="line_zh">最后一个例子，我们实际上是一个例子。</p>
    <p class="">So here a is 2, b is 2, and d is 2.</p>
    <p class="line_zh">所以这里a是2，b是2，d是2。</p>
    <p class="">So log base b of a is log base 2 of 2, which is one.</p>
    <p class="line_zh">所以a的log base b是log 2的2，即1。</p>
    <p class="">So d is now greater than log base b of a.</p>
    <p class="line_zh">所以d现在大于a的log base b。</p>
    <p class="">We are now in case one, T(n) equals O(n to the d), which is O(n squared).</p>
    <p class="line_zh">我们现在处于第一种情况，T（n）等于O（n到n），即O（n平方）。</p>
    <p class="">So what we've seen now is that we have this master theorem that allows us, for most recurrences, when you do a divide
        and conquer which fit into this general formula, allows us to easily figure out which case we are based on the relationships
        between a, b, and d.</p>
    <p class="line_zh">所以我们现在看到的是，我们有这个主要定理，允许我们，对于大多数复发，当你进行符合这个通用公式的分而治之时，允许我们轻松地找出我们基于关系的情况a，b和d之间。</p>
    <p class="">And then figure out the result quite quickly.</p>
    <p class="line_zh">然后很快找出结果。</p>
    <p class="">In our next video we'll look at a proof of why the master theorem works.</p>
    <p class="line_zh">在我们的下一个视频中，我们将看一下主定理为何起作用的证明。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 37 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_37">第02章 proof of the master theorem
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02证明了主定理</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this video, we'll look at a proof of how the Master Theorem works.</p>
    <p class="line_zh">在本视频中，我们将看一下主定理如何工作的证明。</p>
    <p class="">So a reminder, the Master Theorem states that if T(n) equals a T of ceiling of n over b plus a polynomial, then we have
        these three cases.</p>
    <p class="line_zh">所以提醒一下，主定理指出，如果T（n）等于n超过b的上限T加上多项式，那么我们就有这三种情况。</p>
    <p class="">So let's do as we normally do with a recurrence relation and let's create a recurrence tree.</p>
    <p class="line_zh">因此，让我们像往常一样使用递归关系，让我们创建一个递归树。</p>
    <p class="">So we'll have our recurrence at the top to just remind ourselves what that is.</p>
    <p class="line_zh">因此，我们将在顶部再次发生，以便提醒自己这是什么。</p>
    <p class="">Let's assume for the sake of argument that n is a power of b.</p>
    <p class="line_zh">让我们假设为了论证n是b的幂。</p>
    <p class="">That's a reasonable assumption since we can always just pad n to be larger, right, if we increase it by no more than
        b we can get to the next closest power of b and then this will be a simpler analysis.</p>
    <p class="line_zh">这是一个合理的假设，因为我们总是可以将n填充为更大，对，如果我们将它增加不超过b，我们可以得到b的下一个最接近的幂，然后这将是一个更简单的分析。</p>
    <p class="">So we have our problem n.</p>
    <p class="line_zh">所以我们有问题。</p>
    <p class="">At the next level, we break the problem down into a copies of a problem n over b large.</p>
    <p class="line_zh">在下一个级别，我们将问题分解为b大问题的副本。</p>
    <p class="">So level zero.</p>
    <p class="line_zh">所以零级。</p>
    <p class="">We have a problem of size n.</p>
    <p class="line_zh">我们有一个大小为n的问题。</p>
    <p class="">Level 1 we have problems of size n/b.</p>
    <p class="line_zh">1级我们有大小n / b的问题。</p>
    <p class="">At the general level i we have problems of size n over b to the i.</p>
    <p class="line_zh">在一般水平上，我们在i上遇到大小为n的问题。</p>
    <p class="">At the bottom level, which is level log base b of n, we have problems of size 1.</p>
    <p class="line_zh">在底层，即n的级别log base b，我们遇到大小为1的问题。</p>
    <p class="">How many problems are there? At level 0 there's of course one problem.</p>
    <p class="line_zh">有多少问题？在0级，当然有一个问题。</p>
    <p class="">At level 1, a problems.</p>
    <p class="line_zh">在1级，出现问题。</p>
    <p class="">And in general at the ith level, a to the i problems.</p>
    <p class="line_zh">一般来说，在第i级，对于我的问题。</p>
    <p class="">At the log base b of n level, it's a to the log base b of n.</p>
    <p class="line_zh">在n级的log对数b中，它是n的log对数b。</p>
    <p class="">How much work do we have to do? Well work is just a function of how many problems we have and the amount of work for
        each problem.</p>
    <p class="line_zh">我们需要做多少工作？好的工作只是我们有多少问题以及每个问题的工作量的函数。</p>
    <p class="">So at level zero we have just O(n to the d) work.</p>
    <p class="line_zh">所以在零级我们只有O（n到d）的工作。</p>
    <p class="">There's one problem and it takes O(n to the d) time.</p>
    <p class="line_zh">有一个问题，需要O（n到d）时间。</p>
    <p class="">And level one we have a problems.</p>
    <p class="line_zh">一级我们有问题。</p>
    <p class="">And each of them takes O(n over b to the d) work.</p>
    <p class="line_zh">并且每个人都需要O（n over b到d）工作。</p>
    <p class="">Okay, we can pull out the a and the b and the d to be all together, and that's just O(n to the d) times a over b to the
        d.
    </p>
    <p class="line_zh">好的，我们可以将a和b以及d拉出来，这就是O（n到d）乘以d到d。</p>
    <p class="">At the ith level we have a to the i problems and each one is O(n over b to the i to the d).</p>
    <p class="line_zh">在第i级，我们有一个问题，每一个都是O（n到b到i到d）。</p>
    <p class="">Again, we can pull out the a to the i, the b to the i, and we're left with O(n to the d) times a over b to the d to the
        i.
    </p>
    <p class="line_zh">再一次，我们可以将a拉出到i，将b拉到i，然后我们留下O（n到d）乘以b到d到i。</p>
    <p class="">And finally, at the bottom level it's just a to the log base b of n because the problems are all size 1.</p>
    <p class="line_zh">最后，在底层，它只是n的log a b，因为问题都是1。</p>
    <p class="">It's just O(n to the log base b of a).</p>
    <p class="line_zh">它只是O（对于a的对数基数b）。</p>
    <p class="">So the total amount of work is the summation from 0 to the log base b of n.</p>
    <p class="line_zh">因此总工作量是从0到n的对数基数b的总和。</p>
    <p class="">O(n to the d) times the quantity a over b to the d, all that to the i.</p>
    <p class="line_zh">O（n到d）乘以a到b的数量a，到i的所有数量。</p>
    <p class="">So let's look at what seems like a slight digression, and that is geometric series.</p>
    <p class="line_zh">那么让我们看看看起来像是一个轻微的题外话，那就是几何系列。</p>
    <p class="">So a Geometric Series is a series of numbers that progresses by some multiplicative factor.</p>
    <p class="line_zh">所以几何系列是一系列由一些乘法因子推进的数字。</p>
    <p class="">I'll give you an example.</p>
    <p class="line_zh">我给你举个例子。</p>
    <p class="">If we take 1 + 2 + 4 + 8 + 16 + 32 + 64, that's a geometric series where our factor is a factor of 2 at each time.</p>
    <p class="line_zh">如果我们取1 + 2 + 4 + 8 + 16 + 32 + 64，这是一个几何系列，其中我们的因子每次都是2。</p>
    <p class="">Just as well, we could have a geometric series that goes down.</p>
    <p class="line_zh">同样，我们可能会有一个下降的几何系列。</p>
    <p class="">So we could have, for instance, let's say 10,000, 1,000, 100, 10, 1.</p>
    <p class="line_zh">例如，我们可以说10,000,1,000,100,10,1。</p>
    <p class="">Where we're going down by a constant factor of ten at each increment.</p>
    <p class="line_zh">我们在每个增量下降10个常数因子。</p>
    <p class="">Now it turns out, our multiplicative factor, let's call that r, as long as r is not equal to one we have a simple closed
        form for this.</p>
    <p class="line_zh">现在事实证明，我们的乘法因子，我们称之为r，只要r不等于1，我们就有一个简单的闭合形式。</p>
    <p class="">This is just a times (1-r) to the n over 1 minus r.</p>
    <p class="line_zh">这只是n超过1减去r的一倍（1-r）。</p>
    <p class="">And it turns out that big O notation, what happens is we care about the largest term.</p>
    <p class="line_zh">事实证明，大O符号，我们关心的是最大的术语。</p>
    <p class="">So our sum is going to be bounded by a constant times our largest term.</p>
    <p class="line_zh">因此，我们的总和将受到我们最大术语的恒定时间的限制。</p>
    <p class="">So, if r is less than 1 then our largest term is the first element a and therefore our solution is O(a).</p>
    <p class="line_zh">因此，如果r小于1，那么我们最大的项是第一个元素a，因此我们的解是O（a）。</p>
    <p class="">Okay, because it's our largest term, it gets smaller, smaller, smaller, smaller, smaller.</p>
    <p class="line_zh">好吧，因为它是我们最大的术语，它变得更小，更小，更小，更小，更小。</p>
    <p class="">And as long as it's by this multiplicative factor, then all that really matters is this first term, because the rest
        of it sums to no more than a constant times that first term.</p>
    <p class="line_zh">只要它是乘以这个乘法因子，那么真正重要的就是第一个项，因为其余部分总和不超过第一项的恒定时间。</p>
    <p class="">If on the other hand, r is greater than 1, then what matters is the very last term, because that's the biggest term and
        all the previous ones are smaller and smaller.</p>
    <p class="line_zh">另一方面，如果r大于1，那么重要的是最后一个术语，因为这是最大的术语，而之前的所有术语都越来越小。</p>
    <p class="">So it's smallest, larger, larger, larger, largest.</p>
    <p class="line_zh">所以它是最小的，更大的，更大的，更大的，最大的。</p>
    <p class="">And so that largest term is a r to the (n-1).</p>
    <p class="line_zh">所以最大的术语是（n-1）。</p>
    <p class="">So in a geometric series we care about either the first term or the last term, whichever one is bigger.</p>
    <p class="line_zh">因此，在几何系列中，我们关心的是第一项或最后一项，无论哪一项更大。</p>
    <p class="">Now if we take that back to the case of our recurrence tree, we notice our summation here.</p>
    <p class="line_zh">现在，如果我们回到我们的重复树的情况，我们在这里注意到我们的总结。</p>
    <p class="">This is the same summation we had from our recurrence tree and we see that we have a geometric series.</p>
    <p class="line_zh">这与我们从递归树得到的总和相同，我们看到我们有一个几何系列。</p>
    <p class="">a is taking the place of big O then to the d and r is taking the place of a over b to the d.</p>
    <p class="line_zh">a取代大O然后到d，r代替d到d。</p>
    <p class="">So our multiplicative factor is a over b to the d.</p>
    <p class="line_zh">所以我们的乘法因子是d的b。</p>
    <p class="">And there are three cases.</p>
    <p class="line_zh">有三种情况。</p>
    <p class="">You remember as we stated the solution to the Master Theorem.</p>
    <p class="line_zh">你记得我们说过主定理的解决方案。</p>
    <p class="">Case one is d is greater than log base b of a.</p>
    <p class="line_zh">情况一是d大于a的log base b。</p>
    <p class="">Well it's equivalent to saying a over b to the d is less than 1.</p>
    <p class="line_zh">嗯，这相当于说d超过b小于1。</p>
    <p class="">So now we have our multiplicative term is less than 1.</p>
    <p class="line_zh">所以现在我们的乘法项小于1。</p>
    <p class="">So it's getting smaller and smaller and smaller.</p>
    <p class="line_zh">所以它变得越来越小越来越小。</p>
    <p class="">That means that the largest term is the first term.</p>
    <p class="line_zh">这意味着最大的术语是第一个术语。</p>
    <p class="">And that's the one that we have an order of.</p>
    <p class="line_zh">这就是我们订购的那个。</p>
    <p class="">So this is big O of, officially big O of big O of n to the d, which is just the same as big O of n to the d.</p>
    <p class="line_zh">所以这是d的大O的正大O，这与d的大O相同。</p>
    <p class="">Case 2, where d equals log base b of a and equivalently, a over b to the d is equal 1.</p>
    <p class="line_zh">情况2，其中d等于a的对数基数b，并且等效地，对于d的a over b等于1。</p>
    <p class="">Well, if a over b to the d is equal to one, remember our geometric series formula didn't hold, so we're going to just
        have to calculate this.</p>
    <p class="line_zh">好吧，如果对于d的过度b等于1，请记住我们的几何级数公式不成立，所以我们只需要计算它。</p>
    <p class="">But if a over b to the d is 1, then a over b to the d to any power is still 1.</p>
    <p class="line_zh">但是如果对于d的过度b是1，则对于任何功率的过量b仍为1。</p>
    <p class="">So that means, that our summation is just a summation from i equals 0 to log base b of n of O(n to the d).</p>
    <p class="line_zh">这意味着，我们的求和只是从i等于0到n的n（n到d）的log b的求和。</p>
    <p class="">And that's just 1 plus log base b of n, because that's the number of terms in our summation times O(n to the d).</p>
    <p class="line_zh">而且这只是n加上n的对数基数b，因为这是我们求和时间O（n到d）中的项数。</p>
    <p class="">Well the 1 is a low order term we don't care about, and log base b of n can just be treated as log n, because a base
        change is just some multiplicative factor, and that disappears in our big O notation.</p>
    <p class="line_zh">那么1是我们不关心的低阶项，并且n的log log b可以被视为log n，因为基数变化只是一些乘法因子，并且在我们的大O表示法中消失。</p>
    <p class="">So we end up with, as we see in the theorem, O(n to the d times log n).</p>
    <p class="line_zh">因此，正如我们在定理中看到的那样，我们最终得到O（n到d次log n）。</p>
    <p class="">And then our final case, is d is less than log base b of a, which is equivalent to saying a over b to the d is greater
        than 1.</p>
    <p class="line_zh">然后我们的最后一种情况是，d小于a的log b，这相当于说d超过b大于1。</p>
    <p class="">So here, our multiplicative factor is greater than 1.</p>
    <p class="line_zh">所以在这里，我们的乘法因子大于1。</p>
    <p class="">So our smallest term is the first term and our largest term is the last term.</p>
    <p class="line_zh">因此，我们的最短期限是第一个期限，我们最大的期限是最后一个期限。</p>
    <p class="">So in this case, this is big O of our last term is O(n to the d) times a over b to the d to the log b of n.</p>
    <p class="line_zh">所以在这种情况下，这是我们最后一个术语的大O是O（n到d）乘以b到d到n的log b。</p>
    <p class="">So, i is log base b of n.</p>
    <p class="line_zh">所以，我是n的日志基数b。</p>
    <p class="">This is a bit of a mess.</p>
    <p class="line_zh">这有点乱。</p>
    <p class="">Let's see whether we can fix this a little bit.</p>
    <p class="line_zh">让我们看看我们是否可以解决这个问题。</p>
    <p class="">So let's go ahead and apply the log base b of n power separately to a and b to the d.</p>
    <p class="line_zh">那么让我们继续将n幂的log base b分别应用于a和b到d。</p>
    <p class="">So we have, in the numerator, a to the log base b of n.</p>
    <p class="line_zh">所以我们在分子中得到了n的对数基数b。</p>
    <p class="">And then the denominator, b to the d times log base b of n.</p>
    <p class="line_zh">然后是分母，b到d次记录n的基数b。</p>
    <p class="">Well, b to the log base b of n is just n.</p>
    <p class="line_zh">那么，b到n的对数基数b只是n。</p>
    <p class="">So, that's going to disappear down to n to the d in the denominator.</p>
    <p class="line_zh">所以，这将在分母中消失到n。</p>
    <p class="">In the numerator, a to the log base b of n, by logarithmic identity is equal to n to the log base b of a.</p>
    <p class="line_zh">在分子中，对于n的对数基数b，通过对数标识等于n到a的对数基数b。</p>
    <p class="">So we can swap those other two.</p>
    <p class="line_zh">所以我们可以交换其他两个。</p>
    <p class="">And now, if we compare big O of n to the d and n to the d, we know big O of n to the d is bounded by some constant, k
        times n to the d.</p>
    <p class="line_zh">而现在，如果我们将n的大O与d和n与d进行比较，我们知道d的大O是由一个常数限定的，k是n的d。</p>
    <p class="">So we have k n to the d divided by n to the d, which is just some k.</p>
    <p class="line_zh">所以我们将d除以n除以d，这只是k。</p>
    <p class="">And that constant can go away because we're still talking about big O notation.</p>
    <p class="line_zh">而这个常数可以消失，因为我们仍然在谈论大O符号。</p>
    <p class="">So we're left just with big O of n to the log base b of a, which is what we have for the final case.</p>
    <p class="line_zh">所以我们只剩下一个大的O到n的a的基数b，这就是我们对最终案例的看法。</p>
    <p class="">So the Master theorem is a shortcut.</p>
    <p class="line_zh">因此，Master定理是一种捷径。</p>
    <p class="">Our master theorem again as a restatement is here.</p>
    <p class="line_zh">我们的主要定理再次作为重述就在这里。</p>
    <p class="">I have a secret to tell you, however.</p>
    <p class="line_zh">不过，我有个秘密要告诉你。</p>
    <p class="">I do not remember the master theorem and I don't actually even look up the master theorem.</p>
    <p class="line_zh">我不记得主定理，我甚至不查看主定理。</p>
    <p class="">Here's what I do.</p>
    <p class="line_zh">这就是我的工作。</p>
    <p class="">When I have a recurrence of this rough form, I look at the amount of work done at the first level and at the second level
        (which is a very easy calculation) and then I just say to myself Is that the same amount of work? If it's the same
        amount of work it's going to be the same amount of work all the way down and so we're going to be in case two.</p>
    <p class="line_zh">当我再次出现这种粗糙的形式时，我会看一下在第一级和第二级完成的工作量（这是一个非常简单的计算）然后我只是对自己说这是相同的工作量吗？如果它的工作量相同，那么一直都是相同的工作量，所以我们将会遇到两个问题。</p>
    <p class="">So it's going to be the amount of work at the first level, which we known is O(n to the d), times log n because there
        are that many levels.</p>
    <p class="line_zh">所以它将是第一级的工作量，我们称之为O（n到d），乘以log n因为有很多级别。</p>
    <p class="">On the other hand, if the first term is larger than the second term I know the first term is going to dwarf all the other
        terms.
    </p>
    <p class="line_zh">另一方面，如果第一个术语大于第二个术语，我知道第一个术语将使所有其他术语相形见绌。</p>
    <p class="">And so, we're left with just O(n to the d).</p>
    <p class="line_zh">所以，我们只剩下O（n到d）。</p>
    <p class="">And finally, if the first term is less than the second term, I know they're going to keep increasing and it's the bottom
        term that I need.</p>
    <p class="line_zh">最后，如果第一学期少于第二学期，我知道他们将继续增加，这是我需要的最低学期。</p>
    <p class="">And that is just going to be the number of leaves which is n to the log base b of a.</p>
    <p class="line_zh">而这只是叶子的数量，它是a的对数基数b的n。</p>
    <p class="">The master theorem is really handy to use whether you memorize it or you have it written down and use it or in my case
        you sort of recreate it every time you need it.</p>
    <p class="line_zh">掌握定理非常方便使用，无论你是记住它还是记下它并使用它，或者在我的情况下，你可以在每次需要时重新创建它。</p>
    <p class="">Thanks.</p>
    <p class="line_zh">谢谢。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 38 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_38">第01章 problem overview
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01问题概述</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello, and welcome to the sorting problem lesson.</p>
    <p class="line_zh">您好，欢迎来到排序问题课程。</p>
    <p class="">As usual, we start with a problem I'll review.</p>
    <p class="line_zh">像往常一样，我们从一个问题开始，我将审查。</p>
    <p class="">So sorting is a fundamental computational problem.</p>
    <p class="line_zh">因此排序是一个基本的计算问题。</p>
    <p class="">Your input in this problem consists of a sequence of elements, and your goal is to output this element in, for example,
        non-decreasing order.</p>
    <p class="line_zh">您在此问题中的输入由一系列元素组成，您的目标是以非递减顺序输出此元素。</p>
    <p class="">The formal statement of this problem is as follows.</p>
    <p class="line_zh">该问题的正式陈述如下。</p>
    <p class="">You are given a sequence of finite elements.</p>
    <p class="line_zh">您将获得一系列有限元素。</p>
    <p class="">We will usually denote the sequence by A throughout this lesson.</p>
    <p class="line_zh">在本课程中，我们通常用A表示序列。</p>
    <p class="">And your goal is to output these same elements in non-decreasing order.</p>
    <p class="line_zh">您的目标是以非递减顺序输出这些相同的元素。</p>
    <p class="">Once again, sorting is an important computational task used in many efficient algorithms.</p>
    <p class="line_zh">再次，排序是许多有效算法中使用的重要计算任务。</p>
    <p class="">For some algorithms, it is just as important to process given elements in non-decreasing order, going from smaller ones
        to larger ones.</p>
    <p class="line_zh">对于某些算法，以非递减顺序处理给定元素同样重要，从较小的到较大的。</p>
    <p class="">In some other algorithms, just by sorting your input data, you gain a possibility to perform your queries much more efficiently.</p>
    <p class="line_zh">在其他一些算法中，只需对输入数据进行排序，就可以更有效地执行查询。</p>
    <p class="">A canonical example of such situation is a search problem.</p>
    <p class="line_zh">这种情况的典型例子是搜索问题。</p>
    <p class="">In this problem, we are given a sequence of finite elements.</p>
    <p class="line_zh">在这个问题中，我们给出了一系列有限元。</p>
    <p class="">And your goal is to check whether a particular element is present in your sequence.</p>
    <p class="line_zh">您的目标是检查序列中是否存在特定元素。</p>
    <p class="">A simple way to solve this problem, is of course, just to scan your input sequence from left to right and to check, whether
        your element is present in this sequence.</p>
    <p class="line_zh">解决此问题的一种简单方法当然是从左到右扫描输入序列并检查元素是否存在于此序列中。</p>
    <p class="">This gives you a linear kind algorithm.</p>
    <p class="line_zh">这为您提供了线性类算法。</p>
    <p class="">And you know already that if you input data, if you input sequences you sorted, then you can do this much more faster.</p>
    <p class="line_zh">而且你已经知道，如果你输入数据，如果输入你排序的序列，那么你可以更快地完成这项工作。</p>
    <p class="">Basically, in time, in logarithmic time, in the size of your input sequence.</p>
    <p class="line_zh">基本上，在对数时间内，在输入序列的大小。</p>
    <p class="">So ou first compare your element to the middle element.</p>
    <p class="line_zh">所以你首先要比较你的元素和中间元素。</p>
    <p class="">If it is just few element, then you are done, if it is not, you continue with the left half of your sequence or the right
        half of your sequence.</p>
    <p class="line_zh">如果它只是少数元素，那么你就完成了，如果不是，你继续你的序列的左半部分或序列的右半部分。</p>
    <p class="">So in logarithmic number of comparison, and the worst case, you will be able to say whether your element is present in
        this sequence or not.</p>
    <p class="line_zh">因此，在对数的比较和最坏的情况下，您将能够说明您的元素是否存在于此序列中。</p>
    <p class="">So, if you are given a sequence and you are expecting many such queries.</p>
    <p class="line_zh">所以，如果给你一个序列，你期待很多这样的查询。</p>
    <p class="">You're expecting to be asked to check whether a given object is present or not.</p>
    <p class="line_zh">您希望被要求检查给定对象是否存在。</p>
    <p class="">For me such objects, then it just makes sense to first sort your input data and only then perform all these queries.</p>
    <p class="line_zh">对于我这样的对象，那么首先对输入数据进行排序然后才执行所有这些查询才有意义。</p>
    <p class="">This will give you a much more efficient algorithm in general.</p>
    <p class="line_zh">这将为您提供更高效的算法。</p>
    <p class="">All right.</p>
    <p class="line_zh">好吧。</p>
    <p class="">And this is only a small example.</p>
    <p class="line_zh">这只是一个小例子。</p>
    <p class="">We will see many other situations, where sorting your data first helps to perform queries much more efficiently.</p>
    <p class="line_zh">我们将看到许多其他情况，首先对数据进行排序有助于更有效地执行查询。</p>
    <p class="">So in the subsequent videos of this lesson, we will study many efficient sorting algorithms.</p>
    <p class="line_zh">因此，在本课的后续视频中，我们将研究许多有效的排序算法。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 39 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_39">第02章 selection sort
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02选择排序</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this video, we will study one of the simplest sort of algorithms called selection sort.</p>
    <p class="line_zh">在本视频中，我们将研究一种称为选择排序的最简单的算法。</p>
    <p class="">So it's main idea is quite simple, we just keep growing the sorted part of our rate.</p>
    <p class="line_zh">所以它的主要思想很简单，我们只是继续增加我们的速率的分类部分。</p>
    <p class="">So let me illustrate it on a toy example, assume we're given a sequence of links.</p>
    <p class="line_zh">因此，让我在玩具示例中进行说明，假设我们给出了一系列链接。</p>
    <p class="">Five consistent of five integers, eight four two five and two.</p>
    <p class="line_zh">五个一致的五个整数，八个四个二五个和两个。</p>
    <p class="">So we start just by finding one of the minimum elements in this array, in this case it is two.</p>
    <p class="line_zh">所以我们开始只是找到这个数组中的一个最小元素，在这种情况下它是两个。</p>
    <p class="">Now lets just do the following, lets just swap it with the first element of our array.</p>
    <p class="line_zh">现在让我们执行以下操作，让我们只使用数组的第一个元素进行交换。</p>
    <p class="">After swapping, two stays in its final position, so two is the minimum value of our array and it is already in its first
        position.
    </p>
    <p class="line_zh">交换后，两个停留在最终位置，因此两个是我们阵列的最小值，它已经处于第一个位置。</p>
    <p class="">Now let's do the fun one, let's just forget about this element.</p>
    <p class="line_zh">现在让我们做一个有趣的事情，让我们忘掉这个元素吧。</p>
    <p class="">It is already in its final position and let's repeat the same procedure was the remaining part of our array.</p>
    <p class="line_zh">它已经处于最终位置，让我们重复相同的过程是我们阵列的剩余部分。</p>
    <p class="">Namely, we began first find the minimum value, it is again two.</p>
    <p class="line_zh">也就是说，我们开始先找到最小值，它又是两个。</p>
    <p class="">We'll swap it with the first element of the remaining part and then we'll just forget about this element.</p>
    <p class="line_zh">我们将它与剩下部分的第一个元素交换，然后我们将忘记这个元素。</p>
    <p class="">So again, we find the minimum value which is now four with what was the first element of the remaining part which is
        now the sole element of our array.</p>
    <p class="line_zh">再次，我们找到最小值，现在是4，剩下部分的第一个元素是现在我们数组的唯一元素。</p>
    <p class="">And then, we just forget about first three elements and we continue with only remaining parts.</p>
    <p class="line_zh">然后，我们忘记了前三个元素，我们只继续剩下的部分。</p>
    <p class="">So once again, we just keep growing the sorted part of our array.</p>
    <p class="line_zh">所以再一次，我们只是继续增长数组的排序部分。</p>
    <p class="">In the end, what we have, is that the whole array is sorted.</p>
    <p class="line_zh">最后，我们得到的是整个数组的排序。</p>
    <p class="">The pseudocode shown here on the slide, directly implements the idea of the selection sort algorithm that we just discussed.</p>
    <p class="line_zh">幻灯片上显示的伪代码直接实现了我们刚才讨论的选择排序算法的想法。</p>
    <p class="">So here we have a loop where i ranges from 1 to n.</p>
    <p class="line_zh">所以这里我们有一个循环，其中i的范围从1到n。</p>
    <p class="">Initially, i is equal to 1.</p>
    <p class="line_zh">最初，我等于1。</p>
    <p class="">Inside this loop, we compute the index of a minimal value in the array, from, within the list from i to n.</p>
    <p class="line_zh">在这个循环中，我们计算数组中最小值的索引，从i到n的列表中。</p>
    <p class="">We do this as follows, so we create a variable, minlndex which is initially equal to i.</p>
    <p class="line_zh">我们这样做，所以我们创建一个变量minlndex，它最初等于i。</p>
    <p class="">And then we go through all the remaining elements inside this part, I mean through elements from i + 1 to n.</p>
    <p class="line_zh">然后我们浏览这部分内的所有剩余元素，我的意思是从i + 1到n的元素。</p>
    <p class="">And if we find a smaller element we update the variable minlndex.</p>
    <p class="line_zh">如果我们找到一个更小的元素，我们更新变量minlndex。</p>
    <p class="">So in the end of this for loop, what we have is that minindex is a position of a minimal element inside the array from
        i to m.</p>
    <p class="line_zh">所以在这个for循环的最后，我们得到的是minindex是从i到m的数组内最小元素的位置。</p>
    <p class="">Then we swap this element with the element Ai.</p>
    <p class="line_zh">然后我们将这个元素与元素Ai交换。</p>
    <p class="">Namely, when i is equal to one, what we've done, we've found the minimal element in the well array and we've swapped
        it with the first element.</p>
    <p class="line_zh">也就是说，当i等于1时，我们已经完成了，我们在井数组中找到了最小元素，并且我们已经将它与第一个元素交换。</p>
    <p class="">So now, the first element of our array is in its final position.</p>
    <p class="line_zh">所以现在，我们数组的第一个元素处于最终位置。</p>
    <p class="">Then under second iteration of our loop, we do the same actually.</p>
    <p class="line_zh">然后在循环的第二次迭代中，我们实际上做了同样的事情。</p>
    <p class="">We find the minimum value, the position of a minimum value inside the remaining part of our array and put it on the second
        place.
    </p>
    <p class="line_zh">我们找到最小值，在我们的数组的剩余部分内的最小值的位置，并把它放在第二位。</p>
    <p class="">On the sort loop we find the minimum value in this remaining part and put it on the place and so on.</p>
    <p class="line_zh">在排序循环中，我们找到剩余部分中的最小值并将其放在该位置，依此类推。</p>
    <p class="">So we keep growing the sorted part of our array.</p>
    <p class="line_zh">所以我们继续增长数组的排序部分。</p>
    <p class="">So when it would be useful to check the online visualization to see how it goes, so let's do this.</p>
    <p class="line_zh">因此，当检查在线可视化以查看它是如何运行时，请执行此操作。</p>
    <p class="">This visualization shows how selection sort algorithm performs on a few different datasets.</p>
    <p class="line_zh">此可视化显示了选择排序算法如何在几个不同的数据集上执行。</p>
    <p class="">Namely on the random datasets, on a sequence which is nearly sorted.</p>
    <p class="line_zh">即在随机数据集上，在几乎排序的序列上。</p>
    <p class="">Also on a sequence which is sorted in reversed order.</p>
    <p class="line_zh">也在按顺序排序的序列上。</p>
    <p class="">And on a sequence which contains just a few unique elements.</p>
    <p class="line_zh">并且在一个只包含一些独特元素的序列中。</p>
    <p class="">So let's run this algorithm and see what happens.</p>
    <p class="line_zh">那么让我们运行这个算法，看看会发生什么。</p>
    <p class="">So you can see that indeed this algorithm just grows the sorted region, the sorted initial region of our array.</p>
    <p class="line_zh">所以你可以看到，这个算法确实只是增长了排序区域，即数组的排序初始区域。</p>
    <p class="">So another interesting property is it is revealed by this visualization is the following.</p>
    <p class="line_zh">因此，另一个有趣的特性是通过这种可视化揭示了以下内容。</p>
    <p class="">So the running time of this algorithm actually does not depend on input data.</p>
    <p class="line_zh">因此，该算法的运行时间实际上并不依赖于输入数据。</p>
    <p class="">So it only depends on the size of our initial sequence.</p>
    <p class="line_zh">所以它只取决于我们的初始序列的大小。</p>
    <p class="">The other [INAUDIBLE] time of how algorithm is quadratic and this is not difficult to see right? So what we have is two
        nested loops.</p>
    <p class="line_zh">算法是二次方的其他[听不清]时间，这不难看出来吗？所以我们有两个嵌套循环。</p>
    <p class="">In the outer loop, i ranges from 1 to n.</p>
    <p class="line_zh">在外环中，i的范围从1到n。</p>
    <p class="">In the inner loop, j ranges from i plus 1 to n, to find a minimum inside the remaining part of our array.</p>
    <p class="line_zh">在内部循环中，j的范围从i加1到n，以在数组的剩余部分内找到最小值。</p>
    <p class="">So in total we have quadratic number of iterations.</p>
    <p class="line_zh">所以我们总共有二次迭代次数。</p>
    <p class="">At this point however, we should ask ourselves whether our estimate was right in time of the selection, so our algorithm
        was too pessimistic.</p>
    <p class="line_zh">然而，在这一点上，我们应该问自己我们的估计是否在选择时是正确的，所以我们的算法过于悲观。</p>
    <p class="">And this is whar I mean by this.</p>
    <p class="line_zh">这就是我的意思。</p>
    <p class="">So recall that we have two nested loops.</p>
    <p class="line_zh">所以请记住，我们有两个嵌套循环。</p>
    <p class="">In the outer loop, i ranges from 1 to n.</p>
    <p class="line_zh">在外环中，i的范围从1到n。</p>
    <p class="">In the inner loop, g ranges from i + 1 to n.</p>
    <p class="line_zh">在内环中，g的范围从i + 1到n。</p>
    <p class="">So when i is equal to 1, the number of iterations of the inner loop is n- 1.</p>
    <p class="line_zh">因此，当i等于1时，内循环的迭代次数为n-1。</p>
    <p class="">However, when i is equal to 2, the number of iterations of the inner loop is n- 2, and so on.</p>
    <p class="line_zh">但是，当i等于2时，内循环的迭代次数为n-2，依此类推。</p>
    <p class="">So when i increases, the number of iterations of the inner loop decreases.</p>
    <p class="line_zh">因此，当我增加时，内循环的迭代次数减少。</p>
    <p class="">So a more accurate estimate for the total number of iterations of the inner loop would be the following, (n- 1) + (n-
        2) + (n- 3) and so on.</p>
    <p class="line_zh">因此，对内循环的总迭代次数的更准确估计将是以下，（n-1）+（n-2）+（n-3）等等。</p>
    <p class="">So it is definitely less than n-squared.</p>
    <p class="line_zh">所以肯定不到n平方。</p>
    <p class="">However we will show this it is equal to n-squared.</p>
    <p class="line_zh">但是我们会证明它等于n平方。</p>
    <p class="">Namely, this is xx n-squared, and this it is roughly equaled n-square divided by two.</p>
    <p class="line_zh">即，这是xx n平方，并且它大致等于n平方除以2。</p>
    <p class="">The sum is that we need to estimate is called an Arithmetic Series, and there is a known formula for this for this sum.</p>
    <p class="line_zh">总和是我们需要估计的称为算术系列，并且这个总和有一个已知的公式。</p>
    <p class="">Namely 1 + 2 + 3 +, and so on, n, is equal to n(n+1)/2.</p>
    <p class="line_zh">即1 + 2 + 3 +，依此类推，n等于n（n + 1）/ 2。</p>
    <p class="">And this is how we can prove this formula.</p>
    <p class="line_zh">这就是我们如何证明这个公式。</p>
    <p class="">Let's just try it, all our n integers in a row, 1, 2, and so on, n.</p>
    <p class="line_zh">让我们尝试一下，我们所有的n个整数连续，1,2，依此类推，n。</p>
    <p class="">Below them let's write the same set of integers, but in the reverse order.</p>
    <p class="line_zh">在它们下面让我们写相同的整数集，但顺序相反。</p>
    <p class="">So, n, then n minus 1, and so on, 2, and 1.</p>
    <p class="line_zh">那么，n，然后n减1，依此类推，2和1。</p>
    <p class="">Then what we get is a row of size 2 by n.</p>
    <p class="line_zh">然后我们得到的是一行大小为2的n。</p>
    <p class="">Having n columns, and in each column, the sum of the corresponding two integers is equal to n plus 1.</p>
    <p class="line_zh">具有n列，并且在每列中，相应的两个整数的总和等于n加1。</p>
    <p class="">Great, so in the first column we have n and one, and in the second column we have two and minus one and so on and in
        the last column we have n and one.</p>
    <p class="line_zh">太好了，所以在第一列中我们有n和一个，在第二列中我们有两个和减一个，依此类推，在最后一列我们有n和一个。</p>
    <p class="">So the sum in each column is equal to n plus one and zero n columns.</p>
    <p class="line_zh">因此每列中的总和等于n加1和0 n列。</p>
    <p class="">Which means that the sum of all the numbers in our table is equal to n, when supplied by n plus one.</p>
    <p class="line_zh">这意味着当由n加1提供时，表中所有数字的总和等于n。</p>
    <p class="">So since this table contains our sum, the sum of the integers from 1 to n twice, we conclude that the sum of all the
        numbers from 1 to n is equal to n(n+1)/2.</p>
    <p class="line_zh">因此，由于此表包含我们的和，即从1到n两次的整数之和，我们得出结论，从1到n的所有数字的总和等于n（n + 1）/ 2。</p>
    <p class="">Another possibility to find this formula, to see why this formula is correct is to take a rectangle of size n, of dimensions
        n multiplied by n plus 1.</p>
    <p class="line_zh">另一种找到这个公式的可能性，看看为什么这个公式是正确的是采用尺寸为n的矩形，其尺寸为n乘以n加1。</p>
    <p class="">So it's area is equal to n multiplied by n plus one.</p>
    <p class="line_zh">所以它的面积等于n乘以n加1。</p>
    <p class="">And to cut it into two parts such as it's shown in the slide, such as the area of each of these two parts is equal to
        1 + 2 + and so on n.</p>
    <p class="line_zh">并将其切割成两部分，如幻灯片中所示，例如这两部分中的每一部分的面积等于1 + 2 +等等。</p>
    <p class="">We're all ready to conclude.</p>
    <p class="line_zh">我们都准备好结束了。</p>
    <p class="">So we've just discussed the selection sort algorithm.</p>
    <p class="line_zh">所以我们刚刚讨论了选择排序算法。</p>
    <p class="">This algorithm is easy to implement, easy to analyze, and it's running time is n squared, where n is the size of the
        input sequence.</p>
    <p class="line_zh">该算法易于实现，易于分析，运行时间为n平方，其中n为输入序列的大小。</p>
    <p class="">So it sorts the input sequence and array in place.</p>
    <p class="line_zh">因此它将输入序列和数组排序到位。</p>
    <p class="">Meaning that it requires almost no extra memory.</p>
    <p class="line_zh">这意味着它几乎不需要额外的内存。</p>
    <p class="">I mean, all extra memory which is required by this algorithm is only for storing indices, like i, j and m index.</p>
    <p class="line_zh">我的意思是，此算法所需的所有额外内存仅用于存储索引，如i，j和m索引。</p>
    <p class="">There are many other quadratic algorithms, like insertion sort and bubble sort.</p>
    <p class="line_zh">还有许多其他二次算法，如插入排序和冒泡排序。</p>
    <p class="">We're not going to cover them here, and instead, in the next video we will proceed, to do a faster, a faster sort algorithm.</p>
    <p class="line_zh">我们不打算在这里介绍它们，相反，在下一个视频中我们将继续，做一个更快，更快的排序算法。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 40 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_40">第03章 merge sort
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">03合并排序</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this video, we will study the so-called merge sort algorithm.</p>
    <p class="line_zh">在本视频中，我们将研究所谓的合并排序算法。</p>
    <p class="">It is based on the divide and conquer technique, which main idea is the following.</p>
    <p class="line_zh">它基于分而治之的技术，其主要思想如下。</p>
    <p class="">To solve a given computational problem, you first split it into two or more disjoint subproblems, then you solve each
        of these subproblems recursively.</p>
    <p class="line_zh">要解决给定的计算问题，首先将其拆分为两个或更多不相交的子问题，然后递归地解决每个子问题。</p>
    <p class="">And finally, you combine the results that you get from the recursive calls to get the result for your initial subproblem.</p>
    <p class="line_zh">最后，您将从递归调用中获得的结果组合起来，以获得初始子问题的结果。</p>
    <p class="">And this is exactly what we're going to do in merge sort algorithm.</p>
    <p class="line_zh">这正是我们在合并排序算法中要做的事情。</p>
    <p class="">So let's show a toy example.</p>
    <p class="line_zh">所以让我们展示一个玩具示例。</p>
    <p class="">We're given an array of size eight, and we are going to sort it.</p>
    <p class="line_zh">我们给出了一个大小为8的数组，我们将对它进行排序。</p>
    <p class="">First, we just split this array into two halves of size four, just the left half and the right half.</p>
    <p class="line_zh">首先，我们将这个阵列分成四个大小的两半，只是左半部分和右半部分。</p>
    <p class="">Then we make two recursive calls to sort both these parts.</p>
    <p class="line_zh">然后我们进行两次递归调用来对这两部分进行排序。</p>
    <p class="">These are two results in arrays.</p>
    <p class="line_zh">这些是数组中的两个结果。</p>
    <p class="">Now what remains to be done is to merge these two arrays into one, these two arrays of size four into one array of size
        eight.
    </p>
    <p class="line_zh">现在还有待完成的是将这两个数组合并为一个，这两个大小为4的数组合并为一个大小为8的数组。</p>
    <p class="">Well, let's think how this can be done.</p>
    <p class="line_zh">那么，让我们想想如何做到这一点。</p>
    <p class="">First of all, I claim that it is easy to find the minimal value in the resulting array.</p>
    <p class="line_zh">首先，我声称在结果数组中很容易找到最小值。</p>
    <p class="">Indeed, we know that the minimum value in this case in the first array is two, and the minimum value in the second array
        is one.</p>
    <p class="line_zh">实际上，我们知道第一个数组中这种情况下的最小值是2，第二个数组中的最小值是1。</p>
    <p class="">Which means that the minimum value in the result in merge array must be one.</p>
    <p class="line_zh">这意味着合并数组中结果的最小值必须为1。</p>
    <p class="">So let's take one from the right side of array, put it in the resulting array and forget about it.</p>
    <p class="line_zh">所以让我们从数组的右侧取一个，将它放在结果数组中并忘记它。</p>
    <p class="">It is already in its right place.</p>
    <p class="line_zh">它已经在正确的位置。</p>
    <p class="">What remains is an array of size four and an array of size three that still need to be merged.</p>
    <p class="line_zh">剩下的是一个大小为4的数组和一个大小为3的数组，仍然需要合并。</p>
    <p class="">Well, again, it is easy to find the minimum value of the result of merging these two arrays.</p>
    <p class="line_zh">那么，再次，很容易找到合并这两个数组的结果的最小值。</p>
    <p class="">In this case, it is two, because the minimum value in the array of size four is two, and the minimum value in the arrays
        of size three is six.</p>
    <p class="line_zh">在这种情况下，它是两个，因为大小为4的数组中的最小值是2，而大小为3的数组中的最小值是6。</p>
    <p class="">So two is smaller than six, so we get two out of our left array, put it into the resulting array after one, and press
        hit.
    </p>
    <p class="line_zh">所以两个小于六个，所以我们从左侧数组得到两个，在一个之后将它放入结果数组中，然后按下命中。</p>
    <p class="">In the end, we get the following sorted array.</p>
    <p class="line_zh">最后，我们得到以下排序数组。</p>
    <p class="">Again, the pseudocode of the merge sort algorithm directly implements this idea.</p>
    <p class="line_zh">同样，合并排序算法的伪代码直接实现了这个想法。</p>
    <p class="">So this pseudocode takes an input array A of size n as an input.</p>
    <p class="line_zh">因此，该伪代码将大小为n的输入数组A作为输入。</p>
    <p class="">And if n is equal to 1, then in this case, just nothing needs to be done, we can just return the rate A itself.</p>
    <p class="line_zh">如果n等于1，那么在这种情况下，只需要做任何事情，我们就可以返回速率A本身。</p>
    <p class="">If n is greater than 1, on the other hand, then we split the rate A into two roughly equal parts and sort them recursively.</p>
    <p class="line_zh">另一方面，如果n大于1，那么我们将速率A分成两个大致相等的部分并递归地对它们进行排序。</p>
    <p class="">We call them B and C here.</p>
    <p class="">我们在这里称他们为B和C.</p>
    <p class="">Then the only thing that needs to be done is to merge these two sorted arrays.</p>
    <p class="line_zh">然后，唯一需要做的就是合并这两个排序的数组。</p>
    <p class="">So this is done in the procedure merge, which we will present on the next slide.</p>
    <p class="line_zh">所以这是在过程合并中完成的，我们将在下一张幻灯片中介绍。</p>
    <p class="">And finally, we just return the result of this merging procedure.</p>
    <p class="line_zh">最后，我们只返回此合并过程的结果。</p>
    <p class="">The pseudocode of the merging procedure is also straightforward.</p>
    <p class="line_zh">合并过程的伪代码也很简单。</p>
    <p class="">Assumes that we are given two sorted arrays, B and C, of size p and q respectively, and we would like to merge them into
        a sorted array of size p + q.</p>
    <p class="line_zh">假设我们给出了两个分别为大小为p和q的排序数组B和C，我们希望将它们合并为一个大小为p + q的排序数组。</p>
    <p class="">So the first thing we do is create an array of size p + q in array D.</p>
    <p class="line_zh">所以我们要做的第一件事是在数组D中创建一个大小为p + q的数组。</p>
    <p class="">It is initially empty.</p>
    <p class="line_zh">它最初是空的。</p>
    <p class="">Then we keep doing the following thing.</p>
    <p class="line_zh">然后我们继续做以下事情。</p>
    <p class="">So what is the minimum value among all the values stored in the arrays B and C? Well, it is easy to find.</p>
    <p class="line_zh">那么存储在数组B和C中的所有值中的最小值是多少？嗯，很容易找到。</p>
    <p class="">We know that the first element in the array B is its smallest element, and the first element in the array C is its smallest
        element.
    </p>
    <p class="line_zh">我们知道数组B中的第一个元素是它的最小元素，而数组C中的第一个元素是它的最小元素。</p>
    <p class="">So the smallest one among these two is the smallest element inside the unit of these two arrays.</p>
    <p class="line_zh">因此，这两者中最小的一个是这两个阵列单元内的最小元素。</p>
    <p class="">So we just find the minimum of these first elements and move it from one of these arrays to the results in array D, and
        forget about this element completely.</p>
    <p class="line_zh">所以我们只找到这些第一个元素的最小值，并将它从这些数组中的一个移到数组D中的结果，并完全忘记这个元素。</p>
    <p class="">Now what is left is essentially the same problem.</p>
    <p class="line_zh">现在剩下的就是同样的问题。</p>
    <p class="">We're left with two sorted arrays, and we still need to merge them.</p>
    <p class="line_zh">我们留下了两个排序的数组，我们仍然需要合并它们。</p>
    <p class="">So we do it exactly the same.</p>
    <p class="line_zh">所以我们完全一样。</p>
    <p class="">We take the first two elements, we compare them and move the smaller one to the resulting array.</p>
    <p class="line_zh">我们采用前两个元素，我们比较它们并将较小的元素移动到结果数组中。</p>
    <p class="">And we keep doing this while both of these arrays are empty.</p>
    <p class="line_zh">我们继续这样做，而这两个数组都是空的。</p>
    <p class="">I mean, we need this to be able to take their first elements.</p>
    <p class="line_zh">我的意思是，我们需要这个能够采取他们的第一个元素。</p>
    <p class="">When one of them becomes empty, we just copy the rest of the other array to the resulting array D.</p>
    <p class="">当其中一个变空时，我们只将其他数组的其余部分复制到结果数组D.</p>
    <p class="">I mean, where rest to the resulting array D.</p>
    <p class="">我的意思是，休息到结果数组D.</p>
    <p class="">Well, it is not difficult to see that this procedure is correct, and the trying time is p + q, namely, the size of the
        array p plus the size of the array q.</p>
    <p class="line_zh">嗯，不难看出这个程序是正确的，并且尝试时间是p + q，即数组p的大小加上数组q的大小。</p>
    <p class="">And this just because we just can both of these arrays from left to right in the run of this merging procedure.</p>
    <p class="line_zh">这只是因为我们只是在这个合并过程的运行中从左到右都可以使用这两个数组。</p>
    <p class="">This is how sorting our initial array of size eight by the merge sort algorithm looks like.</p>
    <p class="line_zh">这是通过合并排序算法对大小为8的初始数组进行排序的方式。</p>
    <p class="">So the merge sort algorithm first splits the initial array of size eight into two arrays of size four.</p>
    <p class="line_zh">因此，合并排序算法首先将大小为8的初始数组拆分为两个大小为4的数组。</p>
    <p class="">Each of these arrays of size four in turn is split into two arrays of size two, and each of them is split into two arrays
        of size one.</p>
    <p class="line_zh">这些大小为4的数组中的每一个依次被分成两个大小为2的数组，并且每个数组被分成两个大小为1的数组。</p>
    <p class="">Then merge procedure starts merging these arrays of size one into arrays of size twos and into, then these arrays of
        size two into a size four.</p>
    <p class="line_zh">然后合并过程开始将这些大小为1的数组合并为大小为twos的数组，然后将这些大小为2的数组合并为4。</p>
    <p class="">And finally, it merges the result into arrays of size four, into the resulting array of size eight.</p>
    <p class="line_zh">最后，它将结果合并到大小为4的数组中，并将其合并到大小为8的结果数组中。</p>
    <p class="">We are now going to prove that the running time of the merge sort algorithm, on a sequence containing n elements, is
        big O of n log n.</p>
    <p class="">我们现在要证明合并排序算法在包含n个元素的序列上的运行时间是n log n的大O.</p>
    <p class="">Know that this is significantly faster than a quadratic selection sort algorithm.</p>
    <p class="line_zh">知道这比二次选择排序算法快得多。</p>
    <p class="">For example, it is perfectly okay to sort the sequence of size 1 million, for example, 10 to the 6th, on your laptop
        using merge sort algorithm.</p>
    <p class="line_zh">例如，使用合并排序算法在笔记本电脑上排序大小为100万的序列（例如10到6）是完全可以的。</p>
    <p class="">While for the quadratic time selection sort algorithm, sorting a sequence of size 10 to the 6th, 1 million, will take
        roughly 10 to the 12th operations, which is too much for modern computers.</p>
    <p class="line_zh">而对于二次时间选择排序算法，将大小为10的序列排序到第6,100万，大约需要10到12次操作，这对于现代计算机来说太过分了。</p>
    <p class="">Okay, so to prove this lemma, to prove the upper bound on the running time of the merge sort algorithm, first know that
        to merge two parts of size n over 2 of our initial array, takes the linear time.</p>
    <p class="line_zh">好的，为了证明这个引理，为了证明合并排序算法运行时间的上限，首先要知道在我们的初始数组中合并两个大小为n的部分，需要线性时间。</p>
    <p class="">Namely, big O of n, because while the left part has size n over 2, the right part has size n over 2.</p>
    <p class="line_zh">即，n的大O，因为左边部分的尺寸n大于2，右边部分的尺寸n大于2。</p>
    <p class="">And for merging, we basically just combo these parts from left to right.</p>
    <p class="line_zh">对于合并，我们基本上只是从左到右组合这些部分。</p>
    <p class="">So it takes just a linear amount of work to do this.</p>
    <p class="line_zh">因此，这需要一定量的工作量。</p>
    <p class="">Which, in turn means, that if we denote by T of n the running time of our merge sort algorithm, then it satisfies the
        following recurrence.</p>
    <p class="line_zh">反过来意味着，如果我们用n表示我们的合并排序算法的运行时间，则它满足以下重复。</p>
    <p class="">T(n) is at most 2T(n / 2) + big O(n).</p>
    <p class="line_zh">T（n）至多为2T（n / 2）+大O（n）。</p>
    <p class="">Here 2T(n / 2) could response to two recursive calls.</p>
    <p class="line_zh">这里2T（n / 2）可以响应两个递归调用。</p>
    <p class="">So we denote it by T(n), the running time of our algorithm on input of size n.</p>
    <p class="line_zh">所以我们用T（n）来表示它，我们的算法在大小为n的输入上的运行时间。</p>
    <p class="">So when we sort two sequences of size n / 2, we spend time twice T(n / 2).</p>
    <p class="line_zh">因此，当我们对两个大小为n / 2的序列进行排序时，我们花费时间两次T（n / 2）。</p>
    <p class="">So the big O of n term corresponds to what we do before we make recursive calls and what we do after recursive calls.</p>
    <p class="line_zh">所以n项的大O对应于我们在进行递归调用之前所做的事情以及我们在递归调用之后所做的事情。</p>
    <p class="">So what we do before is just split the input array into two halves.</p>
    <p class="line_zh">所以我们之前做的只是将输入数组分成两半。</p>
    <p class="">What we do after is merging the results of two arrays into one array of size n.</p>
    <p class="line_zh">我们所做的是将两个数组的结果合并为一个大小为n的数组。</p>
    <p class="">So it is not difficult to see that all of this can be done in linear time.</p>
    <p class="line_zh">因此，不难看出所有这些都可以在线性时间内完成。</p>
    <p class="">So we get this recurrence, and on the next slide, we're going to show that this recurrence implies that the running time
        of our algorithm is bounded from above by n log n.</p>
    <p class="line_zh">所以我们得到了这种复发，在下一张幻灯片中，我们将证明这种复发意味着我们的算法的运行时间从上面开始被n log n限制。</p>
    <p class="">To estimate the running time of this algorithm, let's consider its recursion tree.</p>
    <p class="line_zh">为了估计这个算法的运行时间，让我们考虑它的递归树。</p>
    <p class="">Namely, at the top of this tree, we have one array of size n.</p>
    <p class="line_zh">也就是说，在这棵树的顶部，我们有一个大小为n的数组。</p>
    <p class="">So for this array of size n, we make two recursive calls for arrays of size n over 2.</p>
    <p class="line_zh">因此对于这个大小为n的数组，我们对大小为n超过2的数组进行两次递归调用。</p>
    <p class="">Each of these arrays of size n over 2 in turn is split into two arrays of size n over 4.</p>
    <p class="line_zh">这些大小为n超过2的阵列中的每一个依次被分成两个大小为n超过4的阵列。</p>
    <p class="">So we get four arrays of size of n over 4 and so on.</p>
    <p class="line_zh">所以我们得到四个大小为n的数组超过4，依此类推。</p>
    <p class="">So in this tree, we have log n levels.</p>
    <p class="line_zh">所以在这棵树中，我们有log n级。</p>
    <p class="">Now let's estimate the work done at each of the levels of these three separately, namely, once again, to solve a problem
        of size n.</p>
    <p class="line_zh">现在让我们分别估算这三个级别中的每个级别所做的工作，即再次解决大小为n的问题。</p>
    <p class="">To sort an array of size n, we first prepare to make recursive calls.</p>
    <p class="line_zh">要对大小为n的数组进行排序，我们首先准备进行递归调用。</p>
    <p class="">In this case, we just split the array into two halves of size n over 2.</p>
    <p class="line_zh">在这种情况下，我们只是将数组拆分为两个大小为n的两半。</p>
    <p class="">Then we do make recursive calls, and then we need to combine the results.</p>
    <p class="line_zh">然后我们做了递归调用，然后我们需要结合结果。</p>
    <p class="">So all the work now inside recursive calls will be accounted for on the lower levels of this tree.</p>
    <p class="line_zh">因此，现在递归调用内的所有工作都将在此树的较低级别进行说明。</p>
    <p class="">So now what we are going to do is to account for only the work done before the recursive calls and after the recursive
        calls at each separate level.</p>
    <p class="line_zh">所以现在我们要做的是只考虑递归调用之前和每个单独级别的递归调用之后完成的工作。</p>
    <p class="">And we know already that it takes linear time to do this.</p>
    <p class="line_zh">我们已经知道这需要线性时间。</p>
    <p class="">I mean, if we have an array of size n, it takes linear time to split it into two halves.</p>
    <p class="line_zh">我的意思是，如果我们有一个大小为n的数组，则需要线性时间将其分成两半。</p>
    <p class="">And then it takes linear time to combine the results of recursive calls into one array.</p>
    <p class="line_zh">然后需要线性时间将递归调用的结果组合到一个数组中。</p>
    <p class="">So let's just denote this time by cn, I mean let's denote the hidden constant inside big O by c.</p>
    <p class="line_zh">所以让我们用cn表示这个时间，我的意思是让我们用c来表示大O中隐藏的常数。</p>
    <p class="">Then what we can say is that on the top level we spend time cn.</p>
    <p class="line_zh">那么我们可以说的是，在顶级我们花费时间cn。</p>
    <p class="">Then on the next level, for each subarray, we spend time c times n over 2, because the size of array is n over 2.</p>
    <p class="line_zh">然后在下一个级别上，对于每个子阵列，我们花费时间c乘以n超过2，因为数组的大小是n超过2。</p>
    <p class="">However, we have 2 arrays, so the total work that we do at this level is 2 multiplied by c, multiplied by n over 2, which
        is again just cn.</p>
    <p class="line_zh">但是，我们有2个数组，所以我们在这个级别做的总工作是2乘以c，乘以n超过2，这也只是cn。</p>
    <p class="">On the next level, we spend time 4 because we have 4 arrays multiplied by c, multiplied by n over 4, because the size
        of the array is now n over 4.</p>
    <p class="line_zh">在下一个级别，我们花费时间4因为我们有4个数组乘以c，乘以n超过4，因为数组的大小现在是n超过4。</p>
    <p class="">This is a cn again, and so on.</p>
    <p class="line_zh">这又是一个cn，依此类推。</p>
    <p class="">So we have log n levels.</p>
    <p class="line_zh">所以我们有log n级别。</p>
    <p class="">At each level, we do roughly cn operations.</p>
    <p class="line_zh">在每个级别，我们都进行大致的操作。</p>
    <p class="">So the total number of operations in our algorithm is cn log n, which proves our lemma.</p>
    <p class="line_zh">因此，我们算法中的操作总数是cn log n，这证明了我们的引理。</p>
    <p class="">So again, what we've just proved is that the running time of the merge sort algorithm is big O of n log n.</p>
    <p class="">再说一遍，我们刚刚证明的是合并排序算法的运行时间是n log n的大O.</p>
    <p class="">So in the next video, we will show that actually no algorithm, no comparison based algorithms, to be completely formal,
        can sort a given sequence of n elements asymptotically faster than in n log n time.</p>
    <p class="line_zh">所以在下一个视频中，我们将展示实际上没有算法，没有基于比较的算法，完全正式，可以对n个元素的给定序列进行排序，比n log n时间更快。</p>
    <p class="">Which actually means that the merge sort algorithm is asymptotically optimal.</p>
    <p class="line_zh">这实际上意味着合并排序算法是渐近最优的。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 41 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_41">第04章 lower bound for comparison based sorting
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">04基于比较的排序下限</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In the previous video, we proved that the running time of the Warshall algorithm on a sequence consisting of n elements
        is big log of n.</p>
    <p class="line_zh">在前面的视频中，我们证明了Warshall算法在由n个元素组成的序列上的运行时间是n的大对数。</p>
    <p class="">In this video we will show that this bond is essentially optimal.</p>
    <p class="line_zh">在这个视频中，我们将证明这种联系基本上是最佳的。</p>
    <p class="">We will do this by showing that any correct sorting algorithm that sorts an object by comparing pairs of them.</p>
    <p class="line_zh">我们将通过显示任何正确的排序算法来做到这一点，该算法通过比较对象来对对象进行排序。</p>
    <p class="">Must make a clear stand log in operation such as particularly in the worst case.</p>
    <p class="line_zh">必须明确登记操作，特别是在最坏的情况下。</p>
    <p class="">Once again we say that the sorting algorithm is comparison based if it sorts the given objects just by comparing pairs
        of them.</p>
    <p class="line_zh">我们再一次说排序算法是基于比较的，如果它只是通过比较它们的对来对给定对象进行排序。</p>
    <p class="">We can imagine the following situation, we have add objects, that look the same, for example in walls, but have different
        weights.
    </p>
    <p class="line_zh">我们可以想象以下情况，我们添加了看起来相同的对象，例如在墙壁中，但具有不同的权重。</p>
    <p class="">And we also have pen balance.</p>
    <p class="line_zh">我们还有笔平衡。</p>
    <p class="">And this pen balance is, our only way to compare pairs of these balls.</p>
    <p class="line_zh">而这笔平衡是我们比较这些球的唯一方法。</p>
    <p class="">And our goal is to rearrange these balls, in order of increasing weights.</p>
    <p class="line_zh">我们的目标是按重量增加的顺序重新排列这些球。</p>
    <p class="">So, for example, the two source and algorithms that we'll already consider it, namely the selection sort algorithm and
        the merge sort algorithm are both comparison based algorithms.</p>
    <p class="line_zh">因此，例如，我们已经考虑过的两个源和算法，即选择排序算法和合并排序算法都是基于比较的算法。</p>
    <p class="">So for example, the selection sort algorithm at each region finds the minimum value in the remaining part of the array.</p>
    <p class="line_zh">因此，例如，每个区域的选择排序算法在数组的剩余部分中找到最小值。</p>
    <p class="">And it does so exactly by comparing pairs of objects, right? Also, the merge sort algorithm is also comparison based
        algorithm.
    </p>
    <p class="line_zh">它通过比较对象来完全这样做，对吗？此外，合并排序算法也是基于比较的算法。</p>
    <p class="">So it first splits an array into halves.</p>
    <p class="line_zh">所以它首先将一个数组分成两半。</p>
    <p class="">And then it needs to merge the two results in arrays.</p>
    <p class="line_zh">然后它需要将两个结果合并到数组中。</p>
    <p class="">And when merging the results in arrays, it also uses comparisons, right? So we take the first two elements of two sorted
        arrays.
    </p>
    <p class="line_zh">当将结果合并到数组中时，它也会使用比较，对吗？所以我们采用两个排序数组的前两个元素。</p>
    <p class="">We compare them, and based on this comparison we take one of these elements out of one of those two arrays and put it
        to the result in the array.</p>
    <p class="line_zh">我们比较它们，并根据这个比较，我们从这两个数组中的一个中取出其中一个元素，并将它放到数组中的结果中。</p>
    <p class="">So this as a formal statement that we're going to prove.</p>
    <p class="line_zh">所以这是我们要证明的正式声明。</p>
    <p class="">It says that any comparison based algorithm that sorts an object has running time.</p>
    <p class="line_zh">它说任何对对象进行排序的基于比较的算法都有运行时间。</p>
    <p class="">At least big and n log n in the worst case.</p>
    <p class="line_zh">在最坏的情况下至少大和n log n。</p>
    <p class="">So but in otherwise we can say the following.</p>
    <p class="line_zh">所以，否则我们可以说以下内容。</p>
    <p class="">Assume that you have an algorithm that sorts an object by comparing pairs of them.</p>
    <p class="line_zh">假设您有一个算法可以通过比较对象来对对象进行排序。</p>
    <p class="">It can be the case that for some given both sequences of an object, your algorithm performs less than analog operations.</p>
    <p class="line_zh">可能的情况是，对于给定对象的两个序列，您的算法执行的操作少于模拟操作。</p>
    <p class="">Say, linear number of operations.</p>
    <p class="line_zh">比方说，线性运算数。</p>
    <p class="">However, it cannot be the case that your algorithm always sorts in time, asymptotically less than n log n.</p>
    <p class="line_zh">但是，不可能的是，您的算法总是按时间排序，渐近地小于n log n。</p>
    <p class="">Meaning that, there must exist, sequence of objects, on which your algorithm will perform at least performing a login
        comparison to sort such sequences.</p>
    <p class="line_zh">这意味着，必须存在，对象序列，您的算法将在其上执行，至少执行登录比较以对这些序列进行排序。</p>
    <p class="">Any comparison based algorithm can be shown as a huge tree that contains all possible sequences of comparisons that can
        be made by this algorithm.</p>
    <p class="line_zh">任何基于比较的算法都可以显示为一个巨大的树，其中包含可以通过此算法进行的所有可能的比较序列。</p>
    <p class="">For example, here on the slide.</p>
    <p class="line_zh">例如，在幻灯片上。</p>
    <p class="">We show a simple algorithm that sort three object.</p>
    <p class="">我们展示了一个简单的算法，它排序三个对象</p>
    <p class="">Three objects.</p>
    <p class="line_zh">三个对象。</p>
    <p class="">So it starts by comparing a1 and a2.</p>
    <p class="line_zh">所以它首先比较a1和a2。</p>
    <p class="">If a1 happens to be smaller than a2, then we proceed to comparing a2 and a3.</p>
    <p class="line_zh">如果a1碰巧小于a2，那么我们继续比较a2和a3。</p>
    <p class="">If a2 is smaller than a3, then we already know the permutation of the input three objects in non-decreasing order.</p>
    <p class="line_zh">如果a2小于a3，那么我们已经知道输入三个对象的非排列顺序的排列。</p>
    <p class="">Namely, we know that a1 is smaller than a2, and we know that a2 is smaller than a3.</p>
    <p class="line_zh">也就是说，我们知道a1小于a2，我们知道a2小于a3。</p>
    <p class="">So we can just output the following permutation.</p>
    <p class="line_zh">所以我们可以输出以下排列。</p>
    <p class="">Right.</p>
    <p class="line_zh">对。</p>
    <p class="">If on the other hand, a2 happened to be at least a3, then at this point we already know that a2 is greater than a1.</p>
    <p class="line_zh">另一方面，如果a2碰巧至少是a3，那么此时我们已经知道a2大于a1。</p>
    <p class="">And a2 Is no smaller than a3.</p>
    <p class="line_zh">而且a2不小于a3。</p>
    <p class="">So at this point, we know that a2 is the maximum element among our three elements.</p>
    <p class="line_zh">所以在这一点上，我们知道a2是我们三个元素中的最大元素。</p>
    <p class="">However, we still need to compare a1 and a3, so we do this comparison, and based on its result, we output either this
        permutation or this permutation.</p>
    <p class="line_zh">但是，我们仍然需要比较a1和a3，所以我们进行这种比较，并根据其结果输出这种排列或这种排列。</p>
    <p class="">Well this was the case when a1 happened to be small as an a2.</p>
    <p class="line_zh">那么当a1恰好小到a2时就是这种情况。</p>
    <p class="">However we need also to consider the case when a1 happened to be at least a2.</p>
    <p class="line_zh">但是，我们还需要考虑a1恰好至少为a2的情况。</p>
    <p class="">So we proceed similarly in this case.</p>
    <p class="line_zh">所以我们在这种情况下也是如此。</p>
    <p class="">So this is just a toy example for an algorithm for a comparison based algorithm comparing three objects, sorting three
        objects.
    </p>
    <p class="line_zh">因此，这只是一个算法的玩具示例，用于基于比较的算法比较三个对象，对三个对象进行排序。</p>
    <p class="">However, such a huge tree can be drawn for any comparison based health algorithm.</p>
    <p class="line_zh">但是，可以为任何基于比较的健康算法绘制这样一棵巨大的树。</p>
    <p class="">So at the root of this tree we have the first comparison.</p>
    <p class="line_zh">所以在这棵树的根部我们进行了第一次比较。</p>
    <p class="">And its children will label just the next comparison that is made based on the result of the first comparison and so
        on.
    </p>
    <p class="line_zh">它的孩子将根据第一次比较的结果标记下一次比较，依此类推。</p>
    <p class="">So each internal node is labeled with some comparison.</p>
    <p class="line_zh">因此，每个内部节点都标有一些比较。</p>
    <p class="">And each leaf is labeled with a permutation of m input objects.</p>
    <p class="line_zh">每个叶子都标有m个输入对象的排列。</p>
    <p class="">A simple but crucial for this argument observation is that in this tree, we must have at least n factorial leaves.</p>
    <p class="line_zh">对于这个论证观察来说，一个简单但至关重要的是，在这棵树中，我们必须至少有n个阶乘叶。</p>
    <p class="">And this is because we have n factorial different permutations of n input objects.</p>
    <p class="line_zh">这是因为我们有n个因子不同的n个输入对象的排列。</p>
    <p class="">Where n factorial is defined to be the product of n and minus one and minus two and so on.</p>
    <p class="line_zh">其中n阶乘被定义为n和减1和减2的乘积，依此类推。</p>
    <p class="">So why is that? Why we must have any possible permutation as a leaf in our tree? Well, this is just because it is possible
        that this permutation is a lead output, is the right output of our algorithm.</p>
    <p class="line_zh">那为什么呢？为什么我们必须在树上留下任何可能的排列？嗯，这只是因为这个排列可能是一个前导输出，是我们算法的正确输出。</p>
    <p class="">So for example on our previous slide, on our toy example, we have three objects and there are six possible permutations
        of these three objects, and there are six leaves in our tree.</p>
    <p class="line_zh">例如，在我们之前的幻灯片中，在我们的玩具示例中，我们有三个对象，这三个对象有六种可能的排列，我们的树中有六个叶子。</p>
    <p class="">For example one of them is 213 and it says that the second element is the smallest one, then goes the first element,
        and then goes the third element.</p>
    <p class="line_zh">例如，其中一个是213，它表示第二个元素是最小的元素，然后是第一个元素，然后是第三个元素。</p>
    <p class="">And indeed there are cases when this is the right answer.</p>
    <p class="line_zh">事实确实，这是正确的答案。</p>
    <p class="">Right? So when the input data consists of three objects, such that the second element is the smallest one, the first
        one is the next one, and the third element is the largest one.</p>
    <p class="line_zh">对？因此，当输入数据由三个对象组成时，第二个元素是最小的一个，第一个是下一个，第三个元素是最大的一个。</p>
    <p class="">Right? So once again, you have a huge tree which carries a comparison based algorithm.</p>
    <p class="line_zh">对？再一次，你有一棵巨大的树，它带有一个基于比较的算法。</p>
    <p class="">There must be at least n factorial leaves, because each possible permutation must be present as a leaf in our tree.</p>
    <p class="line_zh">必须至少有n个阶乘叶，因为每个可能的排列必须作为我们树中的叶子存在。</p>
    <p class="">So on the other hand the maximal number of comparisons made by our algorithm corresponds to the depths of our tree.</p>
    <p class="line_zh">因此，另一方面，我们的算法所做的最大比较次数对应于树的深度。</p>
    <p class="">So the depths is defined as the maximal number of edges run away from the root to the leaf, to some leaf of our tree.</p>
    <p class="line_zh">所以深度定义为从根到叶子的最大边数，到树的一些叶子。</p>
    <p class="">So and this is exactly the maximal possible number of comparisons which our algorithm makes.</p>
    <p class="line_zh">所以，这正是我们的算法所做的最大可能的比较次数。</p>
    <p class="">So now we would like to show that d must be large in our case, must be at least be big O omega of analog n.</p>
    <p class="line_zh">所以现在我们想表明在我们的情况下d必须很大，必须至少是模拟n的大O oga。</p>
    <p class="">And we know already that our tree contains many, many leaves.</p>
    <p class="line_zh">我们已经知道我们的树上有很多很多叶子。</p>
    <p class="">Mean n factorial is a function that grows extremely fast.</p>
    <p class="line_zh">平均n阶乘是一种非常快速增长的函数。</p>
    <p class="">Okay so, intuitively we would like to show that if a tree has many, many leaves, then it has a large depth.</p>
    <p class="line_zh">好的，直觉上我们想表明，如果一棵树有很多很多叶子，那么它有很大的深度。</p>
    <p class="">And at least intuitively this clear.</p>
    <p class="line_zh">至少在直觉上这清楚了。</p>
    <p class="">If you have a tree of very small depths then it must just a few leaves, right? But, we know that it has many, many, many
        leaves, in fact at least ten factorial leaves.</p>
    <p class="line_zh">如果你有一棵非常小的树，那么它必须只有几片叶子，对吧？但是，我们知道它有许多很多叶子，实际上至少有十个叶子叶。</p>
    <p class="">To formally show this we need the following, we need the following estimate.</p>
    <p class="line_zh">为了正式表明我们需要以下内容，我们需要以下估计。</p>
    <p class="">The depths of a binary tree is at least a binary algorithm of its number of leaves or equivalently 2 to the depths is
        at least its number of leaves.</p>
    <p class="line_zh">二叉树的深度至少是其叶数的二进制算法，或等效于深度的2至少是其叶数。</p>
    <p class="">Well this can be proved formally, but let me just show you this informally.</p>
    <p class="line_zh">嗯，这可以正式证明，但让我非正式地告诉你。</p>
    <p class="">Let's concede a tree for example of depth 1.</p>
    <p class="line_zh">让我们承认一棵树，例如深度1。</p>
    <p class="">So in this case, d is equal to 1.</p>
    <p class="line_zh">所以在这种情况下，d等于1。</p>
    <p class="">And it is clear that the maximal possible number of leaves in a tree of depth 1 is equal to 2.</p>
    <p class="line_zh">并且很明显，深度为1的树中叶子的最大可能数量等于2。</p>
    <p class="">So now, let's try to understand what is the maximal possible number of leaves in a depth of In a tree of depth 2.</p>
    <p class="line_zh">所以现在，让我们试着了解在深度为2的树深度中叶子的最大可能数量。</p>
    <p class="">For example, this is a tree of depth 2.</p>
    <p class="line_zh">例如，这是深度为2的树。</p>
    <p class="">This is another tree of depth 2, it has has three leaves.</p>
    <p class="line_zh">这是另一棵深度为2的树，它有三片叶子。</p>
    <p class="">And this is a tree of depth 2 that has maximal possible number of leaves, in this case it is 4.</p>
    <p class="line_zh">这是一棵深度为2的树，其叶子数量最多，在这种情况下为4。</p>
    <p class="">It is 2 to the d indeed.</p>
    <p class="line_zh">它确实是2。</p>
    <p class="">And intuitively it is clear that to have a tree of depth d that has maximal possible number of leaves.</p>
    <p class="line_zh">并且直观地显示具有最大可能叶数的深度为d的树。</p>
    <p class="">We need to take a tree which has a full binary tree of depth d, right? And this tree has exactly 2 to the d leaves.</p>
    <p class="line_zh">我们需要一棵树有一个深度为d的完整二叉树，对吧？而这棵树正好有2片叶子。</p>
    <p class="">So the maximal number of leaves in a tree of depth d is 2 to the d.</p>
    <p class="line_zh">因此深度为d的树中叶子的最大数量是d的2。</p>
    <p class="">Which proves that 2 to the d is at least l.</p>
    <p class="line_zh">这证明2到d至少是l。</p>
    <p class="">Okay, so the last step that we need to show is that if we have n factorial leaves, then the depths of our tree is at
        least big log n again.</p>
    <p class="line_zh">好的，所以我们需要展示的最后一步是，如果我们有n个阶乘叶子，那么我们树的深度至少是大log n。</p>
    <p class="">And we will show this on the next slide.</p>
    <p class="line_zh">我们将在下一张幻灯片中展示这一点。</p>
    <p class="">It remains to estimate log of n factorial.</p>
    <p class="line_zh">它仍然是估计n阶乘的对数。</p>
    <p class="">We're going to show here that log of n factorial is at least c times n log n.</p>
    <p class="line_zh">我们将在这里显示n因子的对数至少是n次n log n。</p>
    <p class="">Which means as it works that log of n factorial is big log of n log n.</p>
    <p class="line_zh">这意味着n因子的日志是n log n的大对数。</p>
    <p class="">To do this, we express n factorial as a product of 1, 2, 3.</p>
    <p class="line_zh">为此，我们将n阶乘表示为1,2,3的乘积。</p>
    <p class="">And so on n minus 1, and then right algorithm of product of these numbers as a sum of their algorithm.</p>
    <p class="line_zh">等等n减1，然后将这些数的乘积算法作为算法的总和。</p>
    <p class="">So, log of n factorial is equal to log of 1 plus log of 2 plus log of 3 and so on plus log of n.</p>
    <p class="line_zh">因此，n阶乘的log等于1的log加2的log加上3的log而依此类推n的log。</p>
    <p class="">So, this is a sum of an object.</p>
    <p class="line_zh">所以，这是一个对象的总和。</p>
    <p class="">Let's just throw away the first half of this and elements, and leave only the second half.</p>
    <p class="line_zh">让我们扔掉这个和元素的前半部分，只剩下下半部分。</p>
    <p class="">So in this second half, we have n over two elements and each of them is at least log of n over two, right? So this has
        algorithms of numbers which are at least n over two.</p>
    <p class="line_zh">所以在下半场，我们有n个超过两个元素，每个元素至少是两个n的对数，对吗？因此，这具有至少n超过两的数字算法。</p>
    <p class="">So we have n over two.</p>
    <p class="line_zh">所以我们有两个以上。</p>
    <p class="">Elements, each of them is at least algorithms of n over 2.</p>
    <p class="line_zh">元素，每个元素至少是n超过2的算法。</p>
    <p class="">This allows us to conclude that log sum is at least 10 over 2 times log of n over 2.</p>
    <p class="line_zh">这使我们得出结论，对数总和至少是2倍于2的n的log。</p>
    <p class="">And this in turn be big log of n for a simple reason.</p>
    <p class="line_zh">而这又是n的大对数，原因很简单。</p>
    <p class="">So log n over 2 is equal to log n minus 1.</p>
    <p class="line_zh">因此log 2 over 2等于log n减1。</p>
    <p class="">Well, this grows like log n, right? Because log n is a growing function and one is a constant so again minus one goes
        as log n.</p>
    <p class="line_zh">嗯，这就像log n一样，对吗？因为log n是一个增长的函数，一个是常数，所以再减去一个作为log n。</p>
    <p class="">And over grows as n, right? So, this is up to constant factors, this is just n.</p>
    <p class="line_zh">过度增长为n，对吗？所以，这取决于常数因素，这只是n。</p>
    <p class="">So, n over two times log n over two grows like n log n.</p>
    <p class="line_zh">因此，n超过两次log n超过两次增长就像n log n。</p>
    <p class="">Okay so this concludes our proof, and this concludes the proof of the fact that any comparison based algorithm must make
        at least n log n adorations in the worst case.</p>
    <p class="line_zh">好的，所以这就结束了我们的证明，这就证明了这样一个事实的证据：任何基于比较的算法必须在最坏的情况下至少进行n log n次加工。</p>
    <p class="">Once again, another conclusion is that when merged sort algorithms that we considered in the previous lecture e is asymmetrically
        optimal.
    </p>
    <p class="line_zh">再一次，另一个结论是，当我们在前面的讲座e中考虑的合并排序算法是非对称最优的。</p>
    <p class="">In the next video we will see an algorithm that actually sorts n given objects in time less than n log n.</p>
    <p class="line_zh">在下一个视频中，我们将看到一种算法，该算法实际上对n个给定对象的时间小于n log n。</p>
    <p class="">Actually in time just in linear time.</p>
    <p class="line_zh">实际上只是在线性时间。</p>
    <p class="">In time big log of n however, it will sort the n given objects, knowing something about these objects.</p>
    <p class="line_zh">然而，在n的时间大日志中，它将对n个给定对象进行排序，了解这些对象。</p>
    <p class="">It will only sort the given objects if the subject has small integers.</p>
    <p class="line_zh">如果主题具有小整数，它将仅对给定对象进行排序。</p>
    <p class="">And we will sort them without actually comparing them to each other.</p>
    <p class="line_zh">我们会对它们进行排序，而不是将它们相互比较。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 42 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_42">第05章 non comparison based sorting algorithms
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">05非基于比较的排序算法</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this last video we will show that there are cases when we can sort the n given objects without actually comparing
        them to each other.</p>
    <p class="line_zh">在最后一个视频中，我们将展示有些情况，我们可以对n个给定对象进行排序，而无需实际将它们相互比较。</p>
    <p class="">And for such algorithms, our lower bound with n log n does not apply.</p>
    <p class="line_zh">对于此类算法，我们的n log n下限不适用。</p>
    <p class="">Well, probably the most natural case when we can sort the n given objects without comparing them to each other is the
        case when our input sequence consists of small integers.</p>
    <p class="line_zh">好吧，当我们输入序列由小整数组成时，我们可以对n个给定对象进行排序而不将它们相互比较，这可能是最自然的情况。</p>
    <p class="">We will illustrate it with a toy example.</p>
    <p class="line_zh">我们将用玩具示例来说明它。</p>
    <p class="">So consider an array of size 12 which consists of just three different digits.</p>
    <p class="line_zh">因此，考虑一个大小为12的数组，它只包含三个不同的数字。</p>
    <p class="">I mean each element of our array is equal to either 1, 2 or 3.</p>
    <p class="line_zh">我的意思是我们数组的每个元素都等于1,2或3。</p>
    <p class="">Then we can do the following, let's just go through this array from left to right.</p>
    <p class="line_zh">然后我们可以执行以下操作，让我们从左到右遍历这个数组。</p>
    <p class="">I mean by a simple count and count the number of occurrences of 1, 2 and 3.</p>
    <p class="line_zh">我的意思是通过一个简单的计数并计算出现次数为1,2和3。</p>
    <p class="">Just by scanning this array you will find out that 1 appears two times, 2 appears seven times, and 3 appears three times.</p>
    <p class="line_zh">只需扫描此阵列，您就会发现1出现两次，2次出现7次，3次出现3次。</p>
    <p class="">And this information is enough for us to sort these objects, so we can use this information to fill in the resulting
        array, A prime.</p>
    <p class="line_zh">这些信息足以让我们对这些对象进行排序，因此我们可以使用这些信息来填充结果数组A prime。</p>
    <p class="">So we put 1 two times, then we put 2 seven times, and then we put 3 three times.</p>
    <p class="line_zh">所以我们放1次，然后我们放2次7次，然后放3次3次。</p>
    <p class="">And this gives us the resulting sorted array A prime, right? So what just happened is that we sorted this array, these
        n objects, without comparing these objects to each other.</p>
    <p class="line_zh">这给了我们生成的排序数组A prime，对吗？所以刚刚发生的事情是我们对这个数组进行了排序，这些n个对象，而不是将这些对象相互比较。</p>
    <p class="">We just counted the number of occurrences of each number, and for this we used, essentially, the information that this
        array contains small integers.</p>
    <p class="line_zh">我们只计算了每个数字的出现次数，为此我们基本上使用了这个数组包含小整数的信息。</p>
    <p class="">The algorithm that we just saw is called counting sort algorithm.</p>
    <p class="line_zh">我们刚刚看到的算法称为计数排序算法。</p>
    <p class="">Its main ideas are the following.</p>
    <p class="line_zh">其主要思想如下。</p>
    <p class="">I assume that we're given an array A of size n, and we know that all its elements are integers in the range from 1 to
        M.
    </p>
    <p class="line_zh">我假设我们给出了一个大小为n的数组A，我们知道它的所有元素都是1到M范围内的整数。</p>
    <p class="">Then, we do the following.</p>
    <p class="line_zh">然后，我们执行以下操作。</p>
    <p class="">We create an array count of size M, and by scanning the initial array A just once from left to right, we count the number
        of occurrences of each i from 1 to M, and we store this value in the cell count of i.</p>
    <p class="line_zh">我们创建一个大小为M的数组计数，并且通过从左到右扫描初始数组A，我们计算每个i的出现次数从1到M，并将该值存储在i的单元数中。</p>
    <p class="">So, we scan the array A from left to right, and whenever we see an element equal to i, we increment the value stored
        in the cell count of i.</p>
    <p class="line_zh">因此，我们从左到右扫描数组A，每当我们看到一个等于i的元素时，我们增加存储在i的单元数中的值。</p>
    <p class="">Then when this array is filled, we can use this information to fill in the resulting array A prime, as we did in our
        toy example.</p>
    <p class="line_zh">然后，当填充此数组时，我们可以使用此信息来填充结果数组A prime，就像我们在玩具示例中所做的那样。</p>
    <p class="">So this is a pseudocode of the count and sort algorithm.</p>
    <p class="line_zh">所以这是计数和排序算法的伪代码。</p>
    <p class="">Here we're given an array A of size M and we assume that all the elements of this array are integers from 1 to M.</p>
    <p class="line_zh">这里我们给出了一个大小为M的数组A，我们假设这个数组的所有元素都是从1到M的整数。</p>
    <p class="">So we introduce the recount of size M which is initially filled in by zeroes.</p>
    <p class="line_zh">因此，我们引入了大小为M的重新计数，它最初用零填充。</p>
    <p class="">Then by scanning our initial array we fill in this array.</p>
    <p class="line_zh">然后通过扫描我们的初始数组，我们填写这个数组。</p>
    <p class="">Namely, whenever we see an element k in our initial array, we increase the cell count of k.</p>
    <p class="line_zh">也就是说，每当我们在初始数组中看到元素k时，我们就会增加k的单元数。</p>
    <p class="">So after the first loop of this algorithm, we know exactly the total number of occurrences of each number k from 1 to
        M in our initial array.</p>
    <p class="">因此，在该算法的第一个循环之后，我们确切地知道在我们的初始数组中每个数字k的出现总数从1到M.</p>
    <p class="">So for example in our toy example two slides before, we counted that the number 1 appears two times in our initial array,
        the number 2 appears seven times in our initial array, and number 3 appears three times.</p>
    <p class="line_zh">因此，例如在我们的玩具示例之前的两张幻灯片中，我们计算出数字1在我们的初始数组中出现两次，数字2在我们的初始数组中出现七次，而数字3出现三次。</p>
    <p class="">So at this point, we know that in the resulting array, the first two elements will be occupied by the number 1, the next
        seven elements will be occupied by the number 2, and the next three elements will be occupied by the number 3.</p>
    <p class="line_zh">所以在这一点上，我们知道在结果数组中，前两个元素将被数字1占用，接下来的七个元素将被数字2占用，接下来的三个元素将被数字3占用。</p>
    <p class="">Now we would like, instead of having just the lengths of these three intervals, we would like to compute the starting
        point of each interval.</p>
    <p class="line_zh">现在我们想要计算每个区间的起点，而不是只有这三个区间的长度。</p>
    <p class="">So we do this in a new loop.</p>
    <p class="line_zh">所以我们在一个新循环中这样做。</p>
    <p class="">And for this we introduce a new array Pos.</p>
    <p class="line_zh">为此我们引入了一个新的阵列Pos。</p>
    <p class="">So Pos[1] is equal to 1, meaning that number 1 will occupy a range starting from the first index.</p>
    <p class="line_zh">因此Pos [1]等于1，意味着数字1将占据从第一个索引开始的范围。</p>
    <p class="">And the starting point for each subsequent range is computed as a starting point of each previous range, plus the length
        of this previous range.</p>
    <p class="line_zh">并且每个后续范围的起点被计算为每个先前范围的起始点加上该先前范围的长度。</p>
    <p class="">So Pos[j] is computed as Pos[j -1] + Count[j- 1].</p>
    <p class="line_zh">所以Pos [j]被计算为Pos [j -1] + Count [j-1]。</p>
    <p class="">So at this point we know the starting point for each range.</p>
    <p class="line_zh">所以在这一点上我们知道每个范围的起点。</p>
    <p class="">Namely, k in the resulting array, number k will occupy a range starting from Pos[k].</p>
    <p class="line_zh">即，在结果数组中的k，数字k将占据从Pos [k]开始的范围。</p>
    <p class="">Then we just count our initial array and whenever we see an element, we always know where to put it in the initial array.</p>
    <p class="line_zh">然后我们只计算我们的初始数组，每当我们看到一个元素时，我们总是知道将它放在初始数组中的哪个位置。</p>
    <p class="">So then let me remind you that we do not just fill in the array with numbers from 1 to M, but we copy elements from our
        initial array.</p>
    <p class="line_zh">那么让我提醒你，我们不只是用1到M的数字填充数组，但是我们从初始数组中复制元素。</p>
    <p class="">This is because what we are looking for in this certain problem is a permutation of our initial n given objects.</p>
    <p class="line_zh">这是因为我们在这个特定问题中寻找的是我们最初的n个给定对象的排列。</p>
    <p class="">Because what we have is probably not just number, not just integers from 1 to M, but these numbers are keys of some probably
        complex object.</p>
    <p class="line_zh">因为我们所拥有的不仅仅是数字，而不仅仅是从1到M的整数，但这些数字可能是某些复杂对象的关键。</p>
    <p class="">Okay, so the running time of this algorithm can be easily seen to be big O of M plus M.</p>
    <p class="">好的，所以这个算法的运行时间很容易看出是M加M的大O.</p>
    <p class="">This is just because here we have three loops.</p>
    <p class="line_zh">这只是因为我们有三个循环。</p>
    <p class="">So the first loop has n iterations, the second loop has M iterations, and the last loop also has n iterations.</p>
    <p class="line_zh">所以第一个循环有n次迭代，第二个循环有M次迭代，最后一个循环也有n次迭代。</p>
    <p class="">Well, so, this is the formal statement.</p>
    <p class="line_zh">那么，这是正式的声明。</p>
    <p class="">The running time of count and sort algorithm is just n + M.</p>
    <p class="">计数和排序算法的运行时间仅为n + M.</p>
    <p class="">And the final remark about this algorithm is that if M grows no faster than n, namely, for example, if our array is filled
        by integers from 1 to n, or if this array is filled just by integers which are upper bounded by some constant, then
        the running time of our count and sort algorithm is just linear in n.</p>
    <p class="line_zh">关于这个算法的最后一点是，如果M的增长速度不快于n，即，例如，如果我们的数组由1到n的整数填充，或者如果这个数组只是被一些常数上限的整数填充，那么我们的计数和排序算法的运行时间在n中只是线性的。</p>
    <p class="">I will now summarize the last three videos.</p>
    <p class="line_zh">我现在将总结最后三个视频。</p>
    <p class="">So we first covered the merge sort algorithm.</p>
    <p class="line_zh">所以我们首先介绍了合并排序算法。</p>
    <p class="">So this is a divide and conquer based algorithm that proceeds as follows.</p>
    <p class="line_zh">因此，这是一种基于分而治之的算法，其过程如下。</p>
    <p class="">Given an array of size n it first splits it into two halves, both roughly equal size, then it sorts them recursively
        and then it merges them into the resulting array.</p>
    <p class="line_zh">给定一个大小为n的数组，它首先将它分成两半，两者大小大致相等，然后递归地对它们进行排序，然后将它们合并到结果数组中。</p>
    <p class="">We then, and we showed that the running time of this algorithm is big O(n log n), which is quite fast actually.</p>
    <p class="line_zh">然后，我们证明了这个算法的运行时间是大O（n log n），实际上非常快。</p>
    <p class="">Almost teeny.</p>
    <p class="line_zh">几乎是小孩子。</p>
    <p class="">We then showed that no other comparison based algorithm can sort n given objects asymptotically faster than an n log
        n.
    </p>
    <p class="line_zh">然后我们表明，没有其他基于比较的算法可以对n个给定对象进行排序，比n log n更快。</p>
    <p class="">So we did this by showing that any comparison based algorithm must distinguish between too many cases.</p>
    <p class="line_zh">所以我们通过显示任何基于比较的算法必须区分太多的情况来做到这一点。</p>
    <p class="">Between n factorial possible permutations.</p>
    <p class="line_zh">在n个阶乘可能的排列之间。</p>
    <p class="">For this, in the worst case, a comparison based algorithm must perform at least big O(n log n) interpolations.</p>
    <p class="line_zh">为此，在最坏的情况下，基于比较的算法必须执行至少大的O（n log n）个插值。</p>
    <p class="">We then showed that it can be actually done faster and in certain problems, can be solved in time less than n log n,
        in some cases.</p>
    <p class="line_zh">然后我们表明它实际上可以更快地完成并且在某些问题中，在某些情况下可以在小于n log n的时间内解决。</p>
    <p class="">For example, in the case when our input array contains small varied integers.</p>
    <p class="line_zh">例如，在我们的输入数组包含小的变化整数的情况下。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 43 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_43">第01章 overview
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01概述</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello, and welcome to the next lesson in the Divide-and-Conquer model.</p>
    <p class="line_zh">您好，欢迎来到Divide-and-Conquer模型的下一课。</p>
    <p class="">This lesson is going to be devoted to the quick sort algorithm, which is one of the most efficient and commonly used
        in practice sorting algorithms.</p>
    <p class="line_zh">本课将专门介绍快速排序算法，这是实践排序算法中最有效和最常用的算法之一。</p>
    <p class="">Well, as usual, we start with the overview of this algorithm.</p>
    <p class="line_zh">好吧，像往常一样，我们从这个算法的概述开始。</p>
    <p class="">The algorithm is comparison based, meaning that it sorts the n given elements by comparing pairs of them.</p>
    <p class="line_zh">该算法是基于比较的，这意味着它通过比较它们的对来对n个给定元素进行排序。</p>
    <p class="">Its running time is also asymptotically n log n, but not in the worst case, as was with the merge sort algorithm, for
        example, but on the average case.</p>
    <p class="line_zh">它的运行时间也渐近n log n，但在最坏的情况下，例如，与合并排序算法不同，但在平均情况下。</p>
    <p class="">This is because this algorithm is randomized, so it uses random numbers to sort the given n objects.</p>
    <p class="line_zh">这是因为该算法是随机的，因此它使用随机数对给定的n个对象进行排序。</p>
    <p class="">Well, we will explain later in this lesson what this means.</p>
    <p class="line_zh">那么，我们将在本课后面解释这意味着什么。</p>
    <p class="">Finally, as I said before, this algorithm is very efficient in practice and, at the same time, not so difficult to implement.</p>
    <p class="line_zh">最后，正如我之前所说，这种算法在实践中非常有效，同时也不是那么难以实现。</p>
    <p class="">This is a toy example explaining the main idea of the quick sort algorithm.</p>
    <p class="line_zh">这是一个玩具示例，解释了快速排序算法的主要思想。</p>
    <p class="">So given an array, in this case of size 11, let's take its first element.</p>
    <p class="line_zh">所以给定一个数组，在这个大小为11的情况下，让我们看看它的第一个元素。</p>
    <p class="">In this case it is 6.</p>
    <p class="line_zh">在这种情况下它是6。</p>
    <p class="">And let's do the following.</p>
    <p class="line_zh">让我们做以下几点。</p>
    <p class="">Let's rearrange all the elements in this array such that the element 6 stays in its final position.</p>
    <p class="line_zh">让我们重新排列该数组中的所有元素，使元素6保持在其最终位置。</p>
    <p class="">All the elements that go before it are actually at most 6.</p>
    <p class="line_zh">之前的所有元素实际上最多为6。</p>
    <p class="">And all the elements that go after 6, after this element, are greater than 6.</p>
    <p class="line_zh">在此元素之后，6之后的所有元素都大于6。</p>
    <p class="">Well, we will show that this can be done by a single scan of the initial array.</p>
    <p class="line_zh">好吧，我们将证明这可以通过初始数组的单次扫描来完成。</p>
    <p class="">This is how the resulting array looks like.</p>
    <p class="line_zh">这就是生成的数组的样子。</p>
    <p class="">So once again, 6 stays in its final position.</p>
    <p class="line_zh">所以再一次，6人保持在最终位置。</p>
    <p class="">All the elements before it are at most 6.</p>
    <p class="line_zh">之前的所有元素最多为6。</p>
    <p class="">All the elements after it are greater than 6.</p>
    <p class="line_zh">之后的所有元素都大于6。</p>
    <p class="">So we do not need to move 6 anymore.</p>
    <p class="line_zh">所以我们不再需要移动6了。</p>
    <p class="">It is already in its final position.</p>
    <p class="line_zh">它已经处于最终位置。</p>
    <p class="">So what remains to be done is to sort all the elements that go before 6 and all the elements that go after 6.</p>
    <p class="line_zh">所以还有待做的是对6之前的所有元素和6之后的所有元素进行排序。</p>
    <p class="">And this can be done just with two recursive calls to the same algorithm, to the quick sort algorithm.</p>
    <p class="line_zh">这可以通过对同一算法的两次递归调用到快速排序算法来完成。</p>
    <p class="">So we do this, and immediately after these two recursive calls, we have a sorted array.</p>
    <p class="line_zh">所以我们这样做，并且在这两个递归调用之后，我们有一个排序数组。</p>
    <p class="">Well, in the next video we will explain all the details of this algorithm.</p>
    <p class="line_zh">那么，在下一个视频中，我们将解释该算法的所有细节。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 44 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_44">第02章 algorithm
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02算法</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this video, we'll provide the full outline of the Greek word algorithm.</p>
    <p class="line_zh">在本视频中，我们将提供希腊词算法的完整大纲。</p>
    <p class="">So as you remember that algorithm is recursive, for this reason we pass through this procedure [INAUDIBLE] a and also
        doing this is l and r in this array for left and right and this procedure saw the sub array inside r within this
        is form l to r.</p>
    <p class="line_zh">所以当你记得算法是递归的时候，为此我们通过这个过程[听不清] a并且在这个数组中左右都是l和r这个过程看到r里面的子数组是形式l到r。</p>
    <p class="">Well we first check whether l is at least r.</p>
    <p class="line_zh">那么我们首先检查l是否至少是r。</p>
    <p class="">And if yes then this means that they can respond in sub array contains at most one element.</p>
    <p class="line_zh">如果是，那么这意味着他们可以在子数组中响应最多包含一个元素。</p>
    <p class="">And this in turn means that nothing needs to be done so we just return.</p>
    <p class="line_zh">而这反过来意味着什么都不需要做，所以我们才回来。</p>
    <p class="">Otherwise we call the partition procedure with the same parameters.</p>
    <p class="line_zh">否则，我们使用相同的参数调用分区过程。</p>
    <p class="">It returns an index m between l and r.</p>
    <p class="line_zh">它返回l和r之间的索引m。</p>
    <p class="">So it rearranges all the elements inside this sub array with the following property.</p>
    <p class="line_zh">因此，它使用以下属性重新排列此子数组中的所有元素。</p>
    <p class="">After the call to this procedure, A of m stays in its final position, meaning that all the elements to the left of an
        element A of m are at most A of m.</p>
    <p class="line_zh">在调用此过程之后，m的A保持在其最终位置，这意味着m的元素A左侧的所有元素最多为m的m。</p>
    <p class="">And all the elements to the right are greater than A of m.</p>
    <p class="line_zh">右边的所有元素都大于m的a。</p>
    <p class="">Well once again, after the call to the partition procedure, A of m stays in its final position.</p>
    <p class="line_zh">再一次，在调用分区程序之后，m中的A保持在其最终位置。</p>
    <p class="">So what remains to be done is to sort all the elements that are at most A to m.</p>
    <p class="line_zh">因此，还有待完成的是对最多A到m的所有元素进行排序。</p>
    <p class="">They stay to the left of A of m, and all the elements that stay to the right.</p>
    <p class="line_zh">他们留在A的左边，以及留在右边的所有元素。</p>
    <p class="">So we do this just by making two recursive calls.</p>
    <p class="line_zh">所以我们只需要进行两次递归调用即可。</p>
    <p class="">So this is how the wall algorithm looks pictorially.</p>
    <p class="line_zh">所以这就是墙算法的图像。</p>
    <p class="">Again, we are given an array A, with two indices l and r, and we are going to sort the sub array inside from indices
        L to R.</p>
    <p class="line_zh">再次，我们给出一个数组A，有两个索引l和r，我们将从索引L到R内部对子数组进行排序。</p>
    <p class="">So with first call the participation procedure which parameter A, l and r.</p>
    <p class="line_zh">因此首先调用参数A，l和r的参与程序。</p>
    <p class="">And it gives us an index m between l and r was the following property.</p>
    <p class="line_zh">并且它给出了l和r之间的索引m是以下属性。</p>
    <p class="">All elements to the left of them are at most the element A of m.</p>
    <p class="">它们左边的所有元素最多都是m的元素A.</p>
    <p class="">All the elements to the right are great as an A of m.</p>
    <p class="line_zh">右边的所有元素都很棒，作为m的一个。</p>
    <p class="">Then we make two recursive calls to sort the left part within this is from l to m- 1 and to solve the right part within
        this is from m + 1 to r.</p>
    <p class="line_zh">然后我们进行两次递归调用，对其中的左边部分进行排序，从l到m-1，并解决其中的右边部分是从m + 1到r。</p>
    <p class="">And immediately after these two recursive call, we have a sorted array.</p>
    <p class="line_zh">在这两个递归调用之后，我们有一个排序数组。</p>
    <p class="">So before showing the actual of the partition procedure, we explain it's main ideas again, on a toy example.</p>
    <p class="line_zh">因此，在展示分区程序的实际情况之前，我们再次在一个玩具示例中解释它的主要想法。</p>
    <p class="">So first of all, we will take is the element A[l] and denoted by x.</p>
    <p class="line_zh">首先，我们将采用元素A [l]并用x表示。</p>
    <p class="">This will be called our pivot element.</p>
    <p class="line_zh">这将被称为我们的枢轴元素。</p>
    <p class="">So what pivot is exactly is the element with respect to which we're going to partition our sub array.</p>
    <p class="line_zh">那么什么是枢轴才是我们要对子数组进行分区的元素。</p>
    <p class="">So x will be placed in its final position.</p>
    <p class="line_zh">因此x将被置于其最终位置。</p>
    <p class="">So our goal now is to rearrange all the elements inside our current sub array so that x stays in its final position and
        all the elements to the left of x.</p>
    <p class="line_zh">所以我们现在的目标是重新排列当前子数组中的所有元素，使x保持在其最终位置，并且x的左侧包含所有元素。</p>
    <p class="">At most x and all the elements to the right of x are greater than x.</p>
    <p class="line_zh">最多x和x右边的所有元素都大于x。</p>
    <p class="">So we will do this gradually increasing the region of already discovered elements.</p>
    <p class="line_zh">因此，我们将逐步增加已发现元素的区域。</p>
    <p class="">So for this we will use a counter i, and we will maintain the following invariant.</p>
    <p class="line_zh">因此，我们将使用计数器i，我们将保持以下不变量。</p>
    <p class="">So I will go from l + 1 to r, and at each point of time when we have already have the i element we will keep to region
        in sizes these region from l + 1 to i.</p>
    <p class="line_zh">所以我将从l + 1转到r，并且在我们已经拥有i元素的每个时间点，我们将保持区域的大小，这些区域从l + 1到i。</p>
    <p class="">In the first region from l + y to j, we will keep all elements that are at most x.</p>
    <p class="line_zh">在从l + y到j的第一个区域中，我们将保留最多x的所有元素。</p>
    <p class="">In the second adjacent region within this is from j + 1 to i we will have all elements that are greater than x.</p>
    <p class="line_zh">在第二个相邻区域内，从j + 1到i，我们将拥有大于x的所有元素。</p>
    <p class="">Let's see it for example.</p>
    <p class="line_zh">让我们看看它的例子。</p>
    <p class="">So I assume that we are somewhere in the middle of this process.</p>
    <p class="line_zh">所以我假设我们处于这个过程的中间位置。</p>
    <p class="">In this case, x is equal to 6, and we need to partition all the elements with respect to x.</p>
    <p class="line_zh">在这种情况下，x等于6，我们需要相对于x对所有元素进行分区。</p>
    <p class="">We already have two sub regions so in the red region, we keep all elements that are at most x.</p>
    <p class="line_zh">我们已经有两个子区域，所以在红色区域，我们保留最多x的所有元素。</p>
    <p class="">There are at most 6 in the blue region we have holds elements that are greater than 6.</p>
    <p class="line_zh">蓝色区域中最多有6个我们拥有大于6的元素。</p>
    <p class="">Okay, now we move i to the next position and we discover the element 9.</p>
    <p class="line_zh">好的，现在我们将i移动到下一个位置，然后我们发现了元素9。</p>
    <p class="">So this element is greater than 6, so we just need to extend the second region, the blue region.</p>
    <p class="line_zh">所以这个元素大于6，所以我们只需要扩展第二个区域，即蓝色区域。</p>
    <p class="">The region of elements is at greater than 6.</p>
    <p class="line_zh">元素区域大于6。</p>
    <p class="">So in this case we just do nothing.</p>
    <p class="line_zh">所以在这种情况下我们什么都不做。</p>
    <p class="">Well the next case is more interesting, we move i to the next position, and we discover the element 4.</p>
    <p class="line_zh">那么下一个案例会更有趣，我们将我移动到下一个位置，然后我们发现元素4。</p>
    <p class="">In this case, we need to somehow move this element to the red region, to the region of elements which at most 6.</p>
    <p class="line_zh">在这种情况下，我们需要以某种方式将此元素移动到红色区域，移动到最多6个元素的区域。</p>
    <p class="">So to do this we just swoop it to currently first element of the blue region, in this case was 9.</p>
    <p class="line_zh">所以为了做到这一点，我们只是把它猛扑到蓝色区域的当前第一个元素，在这种情况下是9。</p>
    <p class="">So if we do this 4 will be the last element of currently red region and 9 will go to the blue region.</p>
    <p class="line_zh">因此，如果我们这样做，4将是当前红色区域的最后一个元素，9将转到蓝色区域。</p>
    <p class="">So we do this and now, we increase also the just to reflect the fact that our red region had just been extended.</p>
    <p class="line_zh">所以我们这样做，现在，我们也增加了正义，以反映我们的红色区域刚刚扩展的事实。</p>
    <p class="">Then we will find to the next element so we discover element 7 which is greater than 6 which means that we can just extend
        the blue region, then we discover another element which is 6.</p>
    <p class="line_zh">然后我们将找到下一个元素，因此我们发现元素7大于6，这意味着我们可以只扩展蓝色区域，然后我们发现另一个元素是6。</p>
    <p class="">6 is at most 6 and it is actually equal to 6, so we need to move it to the red region.</p>
    <p class="line_zh">6最多为6，实际上等于6，所以我们需要将它移动到红色区域。</p>
    <p class="">Again, we swap it with the first element of the blue region and then we extend the red region.</p>
    <p class="line_zh">再次，我们将它与蓝色区域的第一个元素交换，然后我们扩展红色区域。</p>
    <p class="">We increase g to reflect the fact that the red region has just been extended, then we discover another element, which
        is at most 6.</p>
    <p class="line_zh">我们增加g以反映红色区域刚刚扩展的事实，然后我们发现另一个元素，最多为6。</p>
    <p class="">We move it to the end of the red region.</p>
    <p class="line_zh">我们将它移动到红色区域的末尾。</p>
    <p class="">And finally, what we also need to do in the very end is to move the pivot element which is 6 in this case to its final
        position.
    </p>
    <p class="line_zh">最后，我们最后还需要做的是将在这种情况下为6的枢轴元件移动到其最终位置。</p>
    <p class="">And its final position actually can easily be found in this case.</p>
    <p class="line_zh">在这种情况下，它的最终位置实际上很容易找到。</p>
    <p class="">So we have red region and we have blue region.</p>
    <p class="line_zh">所以我们有红色区域，我们有蓝色区域。</p>
    <p class="">In red region, all the elements are at most 6, and in blue region, all the elements are greater than 6.</p>
    <p class="line_zh">在红色区域中，所有元素最多为6，而在蓝色区域中，所有元素都大于6。</p>
    <p class="">So we can just swap 6 with the last element of the red region.</p>
    <p class="line_zh">所以我们可以用红色区域的最后一个元素交换6。</p>
    <p class="">In this case it is 1, so if we swap these two elements then you can see that all the elements in the blue region are
        indeed greater than 6.</p>
    <p class="line_zh">在这种情况下它是1，所以如果我们交换这两个元素，那么你可以看到蓝色区域中的所有元素确实大于6。</p>
    <p class="">All the elements in the red region are smaller than 6.</p>
    <p class="line_zh">红色区域中的所有元素都小于6。</p>
    <p class="">So we are done with this partition procedure.</p>
    <p class="line_zh">所以我们完成了这个分区过程。</p>
    <p class="">Where now ready to present the Soutacot of the petition procedure.</p>
    <p class="line_zh">现在准备提出请愿程序的Soutacot。</p>
    <p class="">We called it what we're going to do is to place some element x, which is called the pivot, into it's final place so that
        all the elements before x are at most x and all the elements after x is greater than x.</p>
    <p class="line_zh">我们称之为我们要做的是将一些元素x（称为枢轴）放入其最终位置，以便x之前的所有元素最多为x，x之后的所有元素都大于x。</p>
    <p class="">So as the pivot element in this procedure, we are going to use just the first element of the correspondence of rate,
        so x is assigned A of l.</p>
    <p class="line_zh">因此，作为此过程中的pivot元素，我们将仅使用rate的对应关系的第一个元素，因此x被指定为l的l。</p>
    <p class="">We're also going to remain the following subregions.</p>
    <p class="line_zh">我们还将继续留在下列次区域。</p>
    <p class="">So first of all, we will readily increase the region of discovered elements.</p>
    <p class="line_zh">首先，我们将很容易地增加已发现元素的区域。</p>
    <p class="">So i goes from l +1 to r and inside this region of [INAUDIBLE] elements, we will maintain two sub regions.</p>
    <p class="line_zh">所以我从l + 1到r并且在[INAUDIBLE]元素的这个区域内，我们将保持两个子区域。</p>
    <p class="">In the first region with indices from l +1 to j, we will keep all of the elements at most x.</p>
    <p class="line_zh">在索引从l + 1到j的第一个区域中，我们将所有元素保持在最多x。</p>
    <p class="">In the second region with indices from j+1 to i, we will keep all of the elements that are greater than x and we will
        gradually and freeze the value of i.</p>
    <p class="line_zh">在从j + 1到i的索引的第二个区域中，我们将保留所有大于x的元素，并且我们将逐渐并冻结i的值。</p>
    <p class="">So when i is increased, so I assumed that i has just been increase so we discovered a new element of A of i.</p>
    <p class="line_zh">所以当我增加时，我假设我刚刚增加，所以我们发现了一个新的元素。</p>
    <p class="">So if A of i is greater than x then just the second of region of elements that are greater than x, is extended automatically
        and we do not need to do anything in this case.</p>
    <p class="line_zh">因此，如果i的a大于x，那么只有大于x的元素区域的第二个区域会自动扩展，在这种情况下我们不需要做任何事情。</p>
    <p class="">However, if the newly discovered element is at most x, then we need to move it to the first region.</p>
    <p class="line_zh">但是，如果新发现的元素最多为x，那么我们需要将其移动到第一个区域。</p>
    <p class="">So we do this as follows.</p>
    <p class="line_zh">所以我们这样做如下。</p>
    <p class="">So we just increase the value of j to indicate the fact that the first region has just been increased, and then swap
        the elements.</p>
    <p class="line_zh">所以我们只是增加j的值来表示第一个区域刚刚增加的事实，然后交换元素。</p>
    <p class="">A[j] and A[i], so this way, we just maintain our invariant each time when i is increased.</p>
    <p class="line_zh">A [j]和A [i]，所以这样，每当我增加时，我们只保持不变量。</p>
    <p class="">So in the very end, when i reaches the value of r, we also need to place our initial element that states that at the
        beginning our pivot between our two regions.</p>
    <p class="line_zh">所以在最后，当我达到r的值时，我们还需要放置我们的初始元素，该元素在开始时指出我们两个区域之间的枢轴。</p>
    <p class="">So for this we just swap elements A[l], so this is our pivot with element A[j].</p>
    <p class="line_zh">所以为此我们只交换元素A [l]，所以这是我们的元素A [j]的支点。</p>
    <p class="">And we then return the value j as an index of our pivot element.</p>
    <p class="line_zh">然后我们返回值j作为pivot元素的索引。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 45 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_45">第03章 random pivot
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">03随机枢轴</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Now when the algorithm is present, we need to estimate the running time.</p>
    <p class="line_zh">现在，当算法存在时，我们需要估计运行时间。</p>
    <p class="">For the Quicksort algorithm, the running time analysis is a little bit tricky.</p>
    <p class="line_zh">对于Quicksort算法，运行时分析有点棘手。</p>
    <p class="">So before stating, and proving the theorem about it's running time, let's be allowing partition.</p>
    <p class="line_zh">所以在陈述并证明关于它的运行时间的定理之前，让我们允许分区。</p>
    <p class="">First of all, let's consider a pathological case, when somehow, it always happens that we select the minimum value of
        our current subarray as our pivot element.</p>
    <p class="line_zh">首先，让我们考虑一个病态案例，当某种程度上，我们总是选择当前子阵列的最小值作为我们的枢轴元素。</p>
    <p class="">Well in this case, well let's see what happens with our current subarray.</p>
    <p class="line_zh">那么在这种情况下，让我们看看我们目前的子阵列会发生什么。</p>
    <p class="">Say of size n.</p>
    <p class="line_zh">说大小n。</p>
    <p class="">And we select its minimum value as a pivot.</p>
    <p class="line_zh">我们选择其最小值作为支点。</p>
    <p class="">And partition, the subarray with respect to the sum.</p>
    <p class="line_zh">和分区，关于总和的子阵列。</p>
    <p class="">Since this is the minimum value, it's final position is just the first position, is the resulting array, right? Which
        means that we partition into two parts.</p>
    <p class="line_zh">由于这是最小值，它的最终位置只是第一个位置，是生成的数组，对吗？这意味着我们分为两部分。</p>
    <p class="">The first part is just empty, we have no elements smaller than our pivot.</p>
    <p class="line_zh">第一部分是空的，我们没有比我们的支点小的元素。</p>
    <p class="">And the second part, contains n- 1 elements, because all the remaining elements are greater than our current element.</p>
    <p class="line_zh">第二部分包含n-1个元素，因为所有剩余元素都大于我们当前元素。</p>
    <p class="">Okay, so in this case, if this happens at this iteration, I mean at this call to partition procedure, then we can write
        the running time of our Quicksort algorithm, satisfies the following relation T of n is equal to n plus t of n minus
        one.
    </p>
    <p class="line_zh">好吧，所以在这种情况下，如果在这次迭代中发生这种情况，我的意思是在调用分区程序时，我们就可以编写Quicksort算法的运行时间，满足以下关系：n的n等于n加n的t减一。</p>
    <p class="">The term n here, the response to the running time of the petition procedure.</p>
    <p class="line_zh">这里的术语n是对请愿程序的运行时间的响应。</p>
    <p class="">Well, it is actually big often.</p>
    <p class="line_zh">嗯，它实际上经常很大。</p>
    <p class="">But just to simplify let's put n here.</p>
    <p class="line_zh">但只是为了简化让我们把n放在这里。</p>
    <p class="">Let me also recall you that, well if we have an array of size n, then the partition procedure indeed works in time, big
        often, because it just becomes the subarray? So now let's see what is the solution for this recurrence relation.</p>
    <p class="line_zh">让我也记得你，如果我们有一个大小为n的数组，那么分区程序确实可以及时运行，通常很大，因为它只是变成了子阵列？那么现在让我们看看这种递归关系的解决方案是什么。</p>
    <p class="">Well, we can just unwind this recurrence relation term by term.</p>
    <p class="line_zh">那么，我们可以按期限解除这个递归关系项。</p>
    <p class="">So we have n plus T of n minus 1.</p>
    <p class="line_zh">所以我们有n加T的n减1。</p>
    <p class="">Let's replace T of n minus 1 by n minus 1 plus T of n minus 2.</p>
    <p class="line_zh">让我们将n减1替换为n减1加上n减去2的T。</p>
    <p class="">Then we replace T of n minus 2 by n minus 2 plus T of n minus 3.</p>
    <p class="">然后我们将n减2的T替换为n减2加上n减3的T.</p>
    <p class="">And we keep doing so.</p>
    <p class="line_zh">我们一直这样做。</p>
    <p class="">So what is left is the following sum, n + (n- 1) + (n- 2) and so on.</p>
    <p class="line_zh">所以剩下的是以下和，n +（n-1）+（n-2）等等。</p>
    <p class="">So what we know is this sum already, so this is arithmetic series.</p>
    <p class="line_zh">所以我们所知道的就是这个数字，所以这是算术系列。</p>
    <p class="">And we know that it grows quadratically.</p>
    <p class="line_zh">我们知道它会以二次方式增长。</p>
    <p class="">Which give us something strange, I mean our Quicksort algorithm works in quadratic time.</p>
    <p class="line_zh">这给了我们一些奇怪的东西，我的意思是我们的Quicksort算法在二次时间内工作。</p>
    <p class="">Which means that it is not quick, actually, right? We'll resolve this issue later.</p>
    <p class="line_zh">这意味着它不快，实际上，对吧？我们稍后会解决这个问题。</p>
    <p class="">Now, let's consider a slightly different case.</p>
    <p class="line_zh">现在，让我们考虑一个稍微不同的情况。</p>
    <p class="">Assume that somehow, we always partition into two parts, such that one of them has size, for example, n- 5.</p>
    <p class="line_zh">假设不知何故，我们总是分成两部分，例如，其中一部分具有大小，例如，n-5。</p>
    <p class="">And the other one has the size four.</p>
    <p class="line_zh">而另一个的大小为四。</p>
    <p class="">Well I claim that even in this case.</p>
    <p class="line_zh">我声称即使在这种情况下也是如此。</p>
    <p class="">First of all, note that both these cases correspond to very unbalanced partitions.</p>
    <p class="line_zh">首先，请注意这两种情况都对应于非常不平衡的分区。</p>
    <p class="">In the first case, we have two parts one of size 0 and one of size n-1.</p>
    <p class="line_zh">在第一种情况下，我们有两个部分，一个是0号，另一个是n-1。</p>
    <p class="">In the second case, we have two parts one of size five.</p>
    <p class="line_zh">在第二种情况下，我们有两个部分，一个是五个。</p>
    <p class="">And one of size four and one of size n minus five.</p>
    <p class="line_zh">其中一个是四号和一号，大小为n减五。</p>
    <p class="">So the size of stuff parts are very unbalanced.</p>
    <p class="line_zh">所以零件的尺寸非常不平衡。</p>
    <p class="">They are very different.</p>
    <p class="line_zh">他们是非常不同的。</p>
    <p class="">Okay, so I claimed that in this case the running time, is also going to be quadratic.</p>
    <p class="line_zh">好的，所以我声称在这种情况下，运行时间也是二次方的。</p>
    <p class="">And this can also be shown, just be unwinding this recurrence relation.</p>
    <p class="line_zh">这也可以显示，只是解除这种递归关系。</p>
    <p class="">So let's just throw away this T(4), and leave only T(n- 5).</p>
    <p class="line_zh">所以，让我们扔掉这个T（4），只留下T（n-5）。</p>
    <p class="">Okay, so T(n) is equal to n plus T(n-5).</p>
    <p class="line_zh">好的，所以T（n）等于n加T（n-5）。</p>
    <p class="">Let's replace T(n-5) with (n-5)+T(n)-10.</p>
    <p class="line_zh">让我们用（n-5）+ T（n）-10代替T（n-5）。</p>
    <p class="">Let's then replace T of n minus ten with T of n with n minus ten plus T of n minus 15 and so on.</p>
    <p class="line_zh">然后让n替换为T减去十，其中t为n，其中n减去10加上T减去15，依此类推。</p>
    <p class="">So this leaves us with the following sum.</p>
    <p class="line_zh">所以这给我们留下了以下总和。</p>
    <p class="">N plus n minus five plus n minus ten and so on and this is also an arithmetic progression.</p>
    <p class="line_zh">N加n减5加n减10等等，这也是算术级数。</p>
    <p class="">The only difference with the previous arithmetic progression is that now, we have step five.</p>
    <p class="line_zh">与先前算术级数的唯一区别在于，现在，我们有第五步。</p>
    <p class="">The difference between neighbors is five, but not one.</p>
    <p class="line_zh">邻居之间的差异是五，但不是一个。</p>
    <p class="">Well, still, this arithmetic progression has a linear number of terms.</p>
    <p class="line_zh">嗯，这个算术级数仍然是线性的项数。</p>
    <p class="">Which means that it sums rows quadratically.</p>
    <p class="line_zh">这意味着它以二次方式对行进行求和。</p>
    <p class="">With the only difference that the hidden constant inside this set up is smaller than in the previous case.</p>
    <p class="line_zh">唯一的区别是此设置中的隐藏常量小于前一种情况。</p>
    <p class="">Now let's consider another pathological case.</p>
    <p class="line_zh">现在让我们考虑另一个病态案例。</p>
    <p class="">Assume that it somehow so happens for some unknown reasons that at each iteration at each call there's a partition procedure.</p>
    <p class="line_zh">假设它出于某些未知原因以某种方式发生，在每次调用的每次迭代中都有一个分区过程。</p>
    <p class="">It partitions the array into roughly equal sizes.</p>
    <p class="line_zh">它将数组分成大致相等的大小。</p>
    <p class="">Well in this case we can write the following reference relation on the running time of our algorithm.</p>
    <p class="line_zh">那么在这种情况下，我们可以在算法的运行时间上写下以下参考关系。</p>
    <p class="">T of n is equal to T of n over 2 plus the linear term.</p>
    <p class="line_zh">n的t等于2的T加上线性项。</p>
    <p class="">And we know this reference already.</p>
    <p class="line_zh">我们已经知道了这个参考。</p>
    <p class="">It is exactly the reference the running time of the satisfies.</p>
    <p class="line_zh">它正是参考运行时间的满足。</p>
    <p class="">Right? And we, proved that in this case t of n grows as n increases vertically.</p>
    <p class="line_zh">对？我们证明了在这种情况下，随着n垂直增加，n的t​​增长。</p>
    <p class="">Let me remind you, how we prove this.</p>
    <p class="line_zh">让我提醒你，我们如何证明这一点。</p>
    <p class="">We analyzed the.</p>
    <p class="line_zh">我们分析了。</p>
    <p class="">So, in this three of the route we have one array of size n.</p>
    <p class="line_zh">所以，在这三个路线中，我们有一个大小为n的数组。</p>
    <p class="">At the next level we have two arrays of size n over two n, at the next level we have four rays of size n over four, and
        so on.</p>
    <p class="line_zh">在下一个级别，我们有两个大小为n超过两个n的数组，在下一个级别，我们有四个大小为n的四条光线，依此类推。</p>
    <p class="">So the height of this tree is log base two, well it is basically logarithmic.</p>
    <p class="line_zh">所以这棵树的高度是log base 2，它基本上是对数的。</p>
    <p class="">At each level the sum of the sizes of of full arrays is equal to N.</p>
    <p class="">在每个级别，完整数组的大小总和等于N.</p>
    <p class="">So we have array of size N at the top, two arrays of size N over two at the next level, and four arrays of size N over
        four at the next level, the size is still N, and so on.</p>
    <p class="line_zh">因此，我们在顶部有大小为N的数组，在下一级有两个大小为N的数组，在下一级有四个大小为N的数组，大小为N，依此类推。</p>
    <p class="">At each level we spend a linear amount of work.</p>
    <p class="line_zh">在每个级别，我们花费大量的工作。</p>
    <p class="">This is essential.</p>
    <p class="line_zh">这很重要。</p>
    <p class="">We spend a linear amount of work at each level, and we have a logarithmic number of levels, which means we spent an N
        log N in time total.</p>
    <p class="">我们在每个级别上花费了线性的工作量，并且我们有一个对数的级别，这意味着我们在总时间上花费了N log N.</p>
    <p class="">Okay, let's consider another, again very pathological case.</p>
    <p class="line_zh">好吧，让我们考虑另一个非常病态的案例。</p>
    <p class="">I assume that we alway split an array of size n into two parts.</p>
    <p class="line_zh">我假设我们总是把一个大小为n的数组分成两部分。</p>
    <p class="">One of size n over 2, n over 10.</p>
    <p class="line_zh">尺寸n超过2，n超过10。</p>
    <p class="">I'm sorry.</p>
    <p class="line_zh">对不起。</p>
    <p class="">One of size 9n over 10.</p>
    <p class="line_zh">尺寸9n超过10。</p>
    <p class="">So in this case the recurrence is the following.</p>
    <p class="line_zh">所以在这种情况下，重复发生如下。</p>
    <p class="">T of n is equal to T of n, over 10.</p>
    <p class="line_zh">n的T等于n的T，超过10。</p>
    <p class="">Plus T of 9N over 10 plus a linear term.</p>
    <p class="line_zh">加上9N超过10的T加上一个线性项。</p>
    <p class="">I claim that even in this case we can prove [INAUDIBLE] again on the running time of how well and this is how we can
        do this.</p>
    <p class="line_zh">我声称即使在这种情况下，我们也可以在运行时间上再次证明[听不清]，这就是我们如何做到这一点。</p>
    <p class="">Well, lets again consider the [INAUDIBLE] because the [INAUDIBLE] of [INAUDIBLE] algorithm.</p>
    <p class="line_zh">好吧，让我们再考虑[听不清]，因为[听不清]算法的[听不清]。</p>
    <p class="">In this case, it is not balanced.</p>
    <p class="line_zh">在这种情况下，它是不平衡的。</p>
    <p class="">Right? Because when we go to the left branch, we reduce the size of the current subproblem by 10.</p>
    <p class="line_zh">对？因为当我们转到左分支时，我们将当前子问题的大小减小10。</p>
    <p class="">And when we go to the right branch, we reduce the size of the current subproblem only by factor of 10 divided by 9.</p>
    <p class="line_zh">当我们进入正确的分支时，我们只将当前子问题的大小减少10倍除以9。</p>
    <p class="">Which means that in our 3, the size of the left branch is of the left most branch, is actually log based ten.</p>
    <p class="line_zh">这意味着在我们的3中，左分支的大小是最左边的分支，实际上是基于日志的十分。</p>
    <p class="">Of n while is the size of the right most branch is log based ten over nine over m.</p>
    <p class="line_zh">在n的同时，最右边的分支的大小是以m为基数的十分之九。</p>
    <p class="">Well, still the height of this of this three is logarithmic.</p>
    <p class="line_zh">那么，这三者的高度仍然是对数。</p>
    <p class="">But the previous case is that nouns are based on the algorithm is different but it's still constant.</p>
    <p class="line_zh">但前一种情况是名词基于算法不同但它仍然是不变的。</p>
    <p class="">It is log based, log based 9 of m.</p>
    <p class="line_zh">它是基于日志的，基于日志的m为m。</p>
    <p class="">And also, but also, the previous property is true.</p>
    <p class="line_zh">而且，之前的属性也是如此。</p>
    <p class="">The sum of the sizes of all arrays at each level is still equal to n.</p>
    <p class="line_zh">每个级别的所有数组的大小总和仍然等于n。</p>
    <p class="">It is at most n, actually.</p>
    <p class="line_zh">实际上它至多是n。</p>
    <p class="">At the root we have one array of size n.</p>
    <p class="line_zh">在根目录，我们有一个大小为n的数组。</p>
    <p class="">At the next level we have two arrays, one of size n/10, and the other one is of size 9n/10.</p>
    <p class="line_zh">在下一级，我们有两个数组，一个是大小为n / 10，另一个是9n / 10。</p>
    <p class="">Right? So the size is still n.</p>
    <p class="line_zh">对？所以尺寸仍然是n。</p>
    <p class="">At the next level it is the same, and so on.</p>
    <p class="line_zh">在下一个级别它是相同的，依此类推。</p>
    <p class="">So we have a logarithmic number of levels, and at each level we spend a linear amount of work which gives us an n log
        n upper bound once again.</p>
    <p class="line_zh">所以我们有一个对数的级别，在每个级别我们花费一定数量的工作量，这使我们再次获得n log n上限。</p>
    <p class="">Okay, all this analysis of what about only pathological cases if we always split in a balanced way or in an unbalanced
        way.
    </p>
    <p class="line_zh">好吧，如果我们总是以平衡的方式或以不平衡的方式分裂，那么所有这些只分析病理案例的分析。</p>
    <p class="">In reality, or just when we run a Greek algorithm on some array, well some of the partitions are going to be balanced.</p>
    <p class="line_zh">实际上，或者只是当我们在某个阵列上运行希腊算法时，一些分区将会平衡。</p>
    <p class="">Some of the partitions are going to be unbalanced.</p>
    <p class="line_zh">一些分区将是不平衡的。</p>
    <p class="">So will still do not know what is the actual running time of the Greek algorithm.</p>
    <p class="line_zh">所以仍然不知道希腊算法的实际运行时间是多少。</p>
    <p class="">We still need to determine this.</p>
    <p class="line_zh">我们仍然需要确定这一点。</p>
    <p class="">However, we already get an important message.</p>
    <p class="line_zh">但是，我们已经收到了重要信息。</p>
    <p class="">So running time of Algorithm of the Greeks are depends on how balanced our partitions.</p>
    <p class="line_zh">因此，希腊人算法的运行时间取决于我们的分区如何平衡。</p>
    <p class="">What we know know is the following, if all our politicians are balanced does that make improved that the running time
        is at most n log n hypothetically.</p>
    <p class="line_zh">我们所知道的是以下内容，如果我们所有的政治家都是平衡的，那么可以改善运行时间至少是假设的。</p>
    <p class="">At the same time if all of our partitions are unbalanced then the running time is quadratic.</p>
    <p class="line_zh">同时，如果我们所有的分区都不平衡，那么运行时间是二次的。</p>
    <p class="">This means that we would like to have a way of selecting a pivot element such that it always guarantees a balanced partition.</p>
    <p class="line_zh">这意味着我们希望有一种选择枢轴元素的方法，以便始终保证平衡分区。</p>
    <p class="">At the same time it is not clear at all how to do this.</p>
    <p class="line_zh">同时，根本不清楚如何做到这一点。</p>
    <p class="">How to guarantee that we can always peek quickly.</p>
    <p class="line_zh">如何保证我们总能快速窥视。</p>
    <p class="">The pivot element with respect to this pivot, the rate is partitioned in a balanced way.</p>
    <p class="line_zh">枢轴元件相对于该枢轴，速率以平衡的方式分开。</p>
    <p class="">So instead of this we will use the following elegant solutions, so let's just select the pivot element from the current
        subarray randomly.</p>
    <p class="line_zh">因此，我们将使用以下优雅的解决方案来代替这一点，所以让我们随机选择当前子阵列中的pivot元素。</p>
    <p class="">To implement this solution, we do the following.</p>
    <p class="line_zh">要实现此解决方案，我们执行以下操作。</p>
    <p class="">Before following the partition procedure.</p>
    <p class="line_zh">在执行分区过程之前。</p>
    <p class="">We just select a random index between l and m, and we swap elements A[l] and this random element.</p>
    <p class="line_zh">我们只选择l和m之间的随机索引，然后我们交换元素A [l]和这个随机元素。</p>
    <p class="">Okay, then we call partition, and then we proceed in a usual way.</p>
    <p class="line_zh">好的，然后我们调用分区，然后我们以通常的方式进行。</p>
    <p class="">Let me explain intuitively why selecting a random partition is going to help us to prove a good upper bound on the running
        time of the Quicksort algorithm.</p>
    <p class="line_zh">让我直观地解释为什么选择随机分区将帮助我们证明Quicksort算法运行时间的良好上限。</p>
    <p class="">Well, for this, consider array A's that we're going to partition with respect to random p and consider it sorted version.</p>
    <p class="line_zh">好吧，为此，考虑我们将要对随机p进行分区的数组A并考虑它的排序版本。</p>
    <p class="">Assume for the moment that all the elements inside our array are different.</p>
    <p class="line_zh">假设我们阵列中的所有元素都是不同的。</p>
    <p class="">In the sorted version, consider the middle half elements.</p>
    <p class="line_zh">在排序版本中，考虑中间的半个元素。</p>
    <p class="">Well we can see that n/2 elements that stay exactly in the middle.</p>
    <p class="line_zh">好吧，我们可以看到n / 2元素完全保持在中间。</p>
    <p class="">Well an important property of all these elements is the following: for each of these n/2 elements there are at least
        n/4 elements that are greater than them.</p>
    <p class="line_zh">所有这些元素的重要特性如下：对于这些n / 2元素中的每一个，至少有n / 4个元素大于它们。</p>
    <p class="">And at least n over four elements that are smaller.</p>
    <p class="line_zh">并且至少n超过四个较小的元素。</p>
    <p class="">Well this means that if we select any of these elements inside our array a, then the partition with respect to this element
        is going to be balanced.</p>
    <p class="line_zh">嗯，这意味着如果我们在数组a中选择这些元素中的任何一个，那么关于这个元素的分区将是平衡的。</p>
    <p class="">Right? In both parts there will be at least n over four elements.</p>
    <p class="line_zh">对？在这两个部分中，至少有四个以上的元素。</p>
    <p class="">Well these n over two elements stay somewhere in the initial array.</p>
    <p class="line_zh">那么这两个元素的n就会保留在初始数组中的某个位置。</p>
    <p class="">So they stay in the middle in the sorted array and they stay somewhere in the initial array.</p>
    <p class="line_zh">所以它们保持在排序数组的中间，它们保留在初始数组中的某个位置。</p>
    <p class="">It doesn't matter for us.</p>
    <p class="line_zh">对我们来说没关系。</p>
    <p class="">What is important for us is that there are at least n over two elements with respect to which the partition is going
        to be balanced.</p>
    <p class="line_zh">对我们来说重要的是，至少有两个以上的元素，分区将被平衡。</p>
    <p class="">Which means that with probability one half we will have a balanced partition.</p>
    <p class="line_zh">这意味着概率为一半，我们将有一个平衡的分区。</p>
    <p class="">And this happens to be enough to prove it with upper bound.</p>
    <p class="line_zh">这恰好足以证明它具有上限。</p>
    <p class="">So we're going to show that the randomized Quicksort algorithm is actually very fast.</p>
    <p class="line_zh">因此，我们将展示兰德省略Quicksort算法实际上非常快。</p>
    <p class="">Well first of all it is fast in practice and we will prove it's theoretical analog out upper bound when it's running
        time.
    </p>
    <p class="line_zh">首先，它在实践中是快速的，并且当它的运行时间我们将证明它是理论模拟的上限。</p>
    <p class="">This is a formal statement of an upper bound on the running time of the Quicksort algorithm that we are going to prove
        in the next video.</p>
    <p class="line_zh">这是关于Quicksort算法运行时间上限的正式声明，我们将在下一个视频中证明这一点。</p>
    <p class="">So I assume that we are given an array A, and assume for the moment that all the elements of this array are pairwise
        different.
    </p>
    <p class="line_zh">所以我假设给出了一个数组A，并假设此数组的所有元素都是成对不同的。</p>
    <p class="">Then the average running time of the Quicksort algorithm on this array consisting of n elements, is big o of n log n.</p>
    <p class="line_zh">然后Quicksort算法在由n个元素组成的数组上的平均运行时间是n log n的大数。</p>
    <p class="">While the worst case running time of this algorithm is n squared.</p>
    <p class="line_zh">虽然该算法的最坏情况运行时间是n平方。</p>
    <p class="">Well let me explain the word on average here.</p>
    <p class="line_zh">那么让我在这里平均解释一下这个词。</p>
    <p class="">Well, this means that for any fixed array.</p>
    <p class="line_zh">嗯，这意味着对于任何固定阵列。</p>
    <p class="">So if we are very unlikely with the random beats, the running time potentially could be higher as an algorithm.</p>
    <p class="line_zh">因此，如果我们不太可能使用随机节拍，那么运行时间可能会更高。</p>
    <p class="">However, on average, and average is over all possible random beats.</p>
    <p class="line_zh">但是，平均而言，平均值超过所有可能的随机节拍。</p>
    <p class="">The running time of the QuickSort algorithm is n log n.</p>
    <p class="line_zh">QuickSort算法的运行时间为n log n。</p>
    <p class="">And this is true for any input.</p>
    <p class="line_zh">任何输入都是如此。</p>
    <p class="">So this theorem doesn't say well, for Quicksort algorithm.</p>
    <p class="line_zh">对于Quicksort算法，这个定理并不好说。</p>
    <p class="">For some arrays, the running time is large, for some arrays the running time is low.</p>
    <p class="line_zh">对于某些阵列，运行时间很长，对于某些阵列，运行时间很短。</p>
    <p class="">But on average, the running time is good enough.</p>
    <p class="line_zh">但平均而言，运行时间足够好。</p>
    <p class="">So it says that for any fixed rate, the average running time is then n log n.</p>
    <p class="line_zh">所以它说对于任何固定的速率，平均运行时间就是n log n。</p>
    <p class="">Okay, so we are going to prove this theorem in the next video.</p>
    <p class="line_zh">好的，我们将在下一个视频中证明这个定理。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 46 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_46">第04章 running time analysis optional
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">04运行时分析可选</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this video we are going to prove formally an upper bound on the running time of the randomized quick sort algorithm.</p>
    <p class="line_zh">在这个视频中，我们将正式证明随机快速排序算法的运行时间的上限。</p>
    <p class="">Namely we're going to prove that the running time on average of the randomized quick sort algorithm is n log n.</p>
    <p class="line_zh">也就是说，我们将证明随机快速排序算法的平均运行时间是n log n。</p>
    <p class="">That is it must be go for n log n.</p>
    <p class="line_zh">那就是必须去n log n。</p>
    <p class="">And that is, that, in the worst case, the running time is big O of n squared.</p>
    <p class="">也就是说，在最坏的情况下，运行时间是n平方的大O.</p>
    <p class="">Well, before going into the details of the proof.</p>
    <p class="line_zh">那么，在进入证明的细节之前。</p>
    <p class="">Let's again, intuition.</p>
    <p class="line_zh">让我们再一次，直觉。</p>
    <p class="">First of all, let's know that what we need to estimate is the number of comparisons.</p>
    <p class="line_zh">首先，让我们知道我们需要估计的是比较次数。</p>
    <p class="">Why is that? Well because a quick sort algorithm contains of first the call to the partition procedure and then to recursive
        calls.
    </p>
    <p class="line_zh">这是为什么？好吧，因为快速排序算法首先包含对分区过程的调用，然后是递归调用。</p>
    <p class="">Each of these two recursive calls is going to be unwinded into the call to partition procedure and another to small recursive
        calls.
    </p>
    <p class="line_zh">这两个递归调用中的每一个都将被释放到分区过程的调用中，而另一个递归到小的递归调用。</p>
    <p class="">So what is going on inside the quick sort algorithm is essentially many calls to the partition procedure.</p>
    <p class="line_zh">因此，快速排序算法内部发生的事情本质上是对分区过程的许多调用。</p>
    <p class="">While inside the partition procedure, what we do actually is to compare all the elements of the curve and separate who
        is the pivot element, right? So what we estimate is a total number of comparisons.</p>
    <p class="line_zh">在分区过程中，我们实际上做的是比较曲线的所有元素并分离谁是枢轴元素，对吧？所以我们估计的是总比较数。</p>
    <p class="">Which is not surprising because the quick sort algorithm is a comparison based algorithm.</p>
    <p class="line_zh">这并不奇怪，因为快速排序算法是基于比较的算法。</p>
    <p class="">Well, now let me also explain why balanced partitions are better for us.</p>
    <p class="line_zh">那么，现在让我解释为什么平衡分区对我们来说更好。</p>
    <p class="">I will explain this intuitively.</p>
    <p class="line_zh">我将直观地解释这一点。</p>
    <p class="">So consider this story example.</p>
    <p class="line_zh">所以考虑这个故事的例子。</p>
    <p class="">This array of size seven.</p>
    <p class="line_zh">这个七号阵列。</p>
    <p class="">Assume that we selected one as the pivot element.</p>
    <p class="line_zh">假设我们选择了一个作为枢轴元素。</p>
    <p class="">So we partitioned the rate is shown here on the left.</p>
    <p class="line_zh">所以我们分区的费率如左图所示。</p>
    <p class="">Now let's see what we now know.</p>
    <p class="line_zh">现在让我们看看我们现在所知道的。</p>
    <p class="">We can pair it all the elements in this array to the pivot element which is one in this case.</p>
    <p class="line_zh">我们可以将此数组中的所有元素与枢轴元素配对，在这种情况下是一个元素。</p>
    <p class="">So now we know that one, the final position of the pivot element is just the first position in the array.</p>
    <p class="line_zh">所以现在我们知道了一个，pivot元素的最终位置只是数组中的第一个位置。</p>
    <p class="">So we known that 1 is the minimum value.</p>
    <p class="line_zh">所以我们知道1是最小值。</p>
    <p class="">However, we know nothing about pairs of other elements, right? So we only learn that 1 is the minimum value.</p>
    <p class="line_zh">但是，我们对其他元素一无所知，对吧？所以我们只知道1是最小值。</p>
    <p class="">Now consider another possibility, consider the following balanced partition shown on the right.</p>
    <p class="line_zh">现在考虑另一种可能性，考虑右侧显示的以下平衡分区。</p>
    <p class="">So assume that we selected 4 as the pivot element.</p>
    <p class="line_zh">因此，假设我们选择4作为枢轴元素。</p>
    <p class="">I claimed that in this case, this partition is much better for us because we saved many subsequent comparisons.</p>
    <p class="line_zh">我声称在这种情况下，这个分区对我们来说要好得多，因为我们保存了许多后续比较。</p>
    <p class="">So look, in this case, in the subsequent trends of the partition precision, we are not going to compare elements 3, 1,
        2 with element 6, 5, 7.</p>
    <p class="line_zh">因此，在这种情况下，在随后的分区精度趋势中，我们不会将元素3,1,2与元素6,5,7进行比较。</p>
    <p class="">Because we already know that all the elements to the left are for a.</p>
    <p class="line_zh">因为我们已经知道左边的所有元素都是a。</p>
    <p class="">As in all the elements to the right are formed.</p>
    <p class="line_zh">正如所有元素都在右边形成。</p>
    <p class="">Well the left part will stay in a separate recursive code and the right part well stay in a separate recursive code.</p>
    <p class="line_zh">那么左边的部分将保留在一个单独的递归代码中，右边的部分将保留在一个单独的递归代码中。</p>
    <p class="">So once again, balanced partitions save us a lot of comparisons that we do not need to make in the subsequent calls to
        partition procedure.</p>
    <p class="line_zh">因此，平衡分区再一次为我们节省了许多比较，我们不需要在后续的分区过程调用中进行比较。</p>
    <p class="">Another thing I would like to discuss with you before growing and know details of the proof is the following.</p>
    <p class="line_zh">在成长之前我想与您讨论另一件事，并且知道证据的细节如下。</p>
    <p class="">Our algorithm is randomized, so its running time and its number of comparisons depends on the random beats used inside
        the algorithm,.</p>
    <p class="line_zh">我们的算法是随机的，因此它的运行时间和比较次数取决于算法中使用的随机节拍。</p>
    <p class="">In particular for any two elements there is some probability that they are going to be compared.</p>
    <p class="line_zh">特别是对于任何两个元素，它们有可能被比较。</p>
    <p class="">And using this toy example shown on the slide, I would like to just build an intuition on how to estimate this probability
        on which factors this probability depends.</p>
    <p class="line_zh">使用幻灯片上显示的这个玩具示例，我想建立一个关于如何估计这个概率所依赖的因素的概率的直觉。</p>
    <p class="">So consider this small example.</p>
    <p class="line_zh">所以考虑这个小例子。</p>
    <p class="">So this is an array of say it's nine containing all the digits.</p>
    <p class="line_zh">所以这是一个包含所有数字的九个数组。</p>
    <p class="">And I would like to estimate the probability that elements 1 and 9 are going to be compared if we call randomized quick
        sort physics already.</p>
    <p class="line_zh">如果我们称之为随机快速排序物理，我想估计元素1和9将被比较的概率。</p>
    <p class="">So, let's see what happens.</p>
    <p class="line_zh">那么，让我们看看会发生什么。</p>
    <p class="">Assume that in the very first quarters of partition procedure, we select the elements 3 for example as the pivot element,
        so what happens? In this case, 1 will go to the left of 3 and 9 will go to the right side.</p>
    <p class="line_zh">假设在分区过程的前几个季度，我们选择元素3作为例如枢轴元素，那么会发生什么？在这种情况下，1将位于3的左侧，9将位于右侧。</p>
    <p class="">To the right of three, I'm sorry.</p>
    <p class="line_zh">在三人的右边，我很抱歉。</p>
    <p class="">So in this case 1 and 9 will be in different parts and they will never be compared in as a partician procedure just because
        they are already in different parts.</p>
    <p class="line_zh">因此，在这种情况下，1和9将处于不同的部分，并且它们永远不会仅仅因为它们已经在不同的部分而作为特定程序进行比较。</p>
    <p class="">Okay, for the ways it means, that we already know that 1 is smaller than 9, because 1 is smaller than 3, and 3 is smaller
        than 9, right? We do not need to compare them.</p>
    <p class="line_zh">好吧，对于它的含义，我们已经知道1小于9，因为1小于3,3小于9，对吧？我们不需要比较它们。</p>
    <p class="">Well then this happens if we select as our pivot element, any of the elements, 2, 3, 4, 5, 6, 7 or 9, 8, I'm sorry.</p>
    <p class="line_zh">那么如果我们选择作为我们的枢轴元素，任何元素，2,3,4,5,6,7或9,8，就会发生这种情况，对不起。</p>
    <p class="">If on the other hand we select 1 and 9 as our first pivot element, then 1 and 9 will become pivot.</p>
    <p class="line_zh">另一方面，如果我们选择1和9作为我们的第一个枢轴元素，则1和9将成为枢轴。</p>
    <p class="">Just because, well, if we select, for example, 9 as the pivot element, we can pivot with all the elements of our array,
        in particular with 1.</p>
    <p class="line_zh">仅仅因为，如果我们选择9作为枢轴元素，我们可以使用数组的所有元素进行旋转，特别是使用1。</p>
    <p class="">So there are two cases when 1 and 9 are compared.</p>
    <p class="line_zh">因此有两种情况比较1和9。</p>
    <p class="">And this is how exactly the case is when either 1 or 9 are selected as a first pivot.</p>
    <p class="line_zh">这就是当选择1或9作为第一个枢轴时的情况。</p>
    <p class="">In all other seven cases there are not compared.</p>
    <p class="line_zh">在所有其他七个案例中都没有进行比较。</p>
    <p class="">This means that the probability that they are compared are 2 over 9.</p>
    <p class="line_zh">这意味着它们被比较的概率是2比9。</p>
    <p class="">Okay, makes sense? Now let's try to estimate the probability that the elements three and four are compared.</p>
    <p class="line_zh">好的，有道理吗？现在让我们尝试估计元素3和4的比较概率。</p>
    <p class="">Well I claimed that in this case this probability is equal to 1.</p>
    <p class="line_zh">我声称在这种情况下，这个概率等于1。</p>
    <p class="">And the explanation is the following, there is no element inside RRE that can help the randomized weak sort algorithm
        to understand that 3 is smaller than 4 without comparing them.</p>
    <p class="line_zh">并且解释如下，RRE中没有可以帮助随机弱排序算法理解3小于4而不进行比较的元素。</p>
    <p class="">I mean for 1 and 9, there are seven such elements.</p>
    <p class="line_zh">我的意思是1和9，有七个这样的元素。</p>
    <p class="">All they are is elements.</p>
    <p class="line_zh">它们都是元素。</p>
    <p class="">I mean, if we partition with respect to any of the elements, we already know that 1 is smaller than 9 because they go
        to other parts.</p>
    <p class="line_zh">我的意思是，如果我们对任何元素进行分区，我们已经知道1小于9，因为它们会转到其他部分。</p>
    <p class="">Different parts with respect to this pivot.</p>
    <p class="line_zh">关于该枢轴的不同部分。</p>
    <p class="">For three and four there is no such element.</p>
    <p class="line_zh">对于三和四，没有这样的元素。</p>
    <p class="">So algorithm just must compare these two elements to be sure that 3 is smaller than 4.</p>
    <p class="line_zh">因此算法必须比较这两个元素以确保3小于4。</p>
    <p class="">So in this case the probability is 1.</p>
    <p class="line_zh">所以在这种情况下概率为1。</p>
    <p class="">Well this shows that the probability of comparing two elements depends on how close they are in the sorted array.</p>
    <p class="line_zh">这表明比较两个元素的概率取决于它们在排序数组中的接近程度。</p>
    <p class="">In particular if they're very far apart of each other than the probability is small and if they are close to each other
        than the probability is high.</p>
    <p class="line_zh">特别是如果它们彼此相距甚远，则概率很小并且如果它们彼此接近而不是概率很高。</p>
    <p class="">We will use this observation in the formal proof of our statement.</p>
    <p class="line_zh">我们将在我们陈述的正式证明中使用这一观察。</p>
    <p class="">We now start to formally prove an upper bound on the running time of the randomized quicksort algorithm.</p>
    <p class="line_zh">我们现在开始正式证明随机快速排序算法的运行时间的上限。</p>
    <p class="">For this, we introduce the following random variable.</p>
    <p class="line_zh">为此，我们引入以下随机变量。</p>
    <p class="">Let i and j be different indices from 1 to m.</p>
    <p class="line_zh">设i和j是从1到m的不同指数。</p>
    <p class="">We define Xi of ij to be equal to 1 if two elements, A'[i] and A'[j] are compared in the [INAUDIBLE] quick sort algorithm
        and to be equal to 0 otherwise.</p>
    <p class="line_zh">如果在[听不清]快速排序算法中比较两个元素A'[i]和A'[j]，则将ij的Xi定义为等于1，否则等于0。</p>
    <p class="">Once again, to estimate the running time of the quick sort algorithm, we would like to estimate the total number of comparisons
        made, so we would like to estimate, for any pair of elements, what is the probability that they are compared? As
        we discussed on the previous slide, the probability that two elements are compared depends on how close they are
        in the sorted version of our array.</p>
    <p class="line_zh">再次，为了估计快速排序算法的运行时间，我们想估计所做的比较总数，因此我们想估计，对于任何一对元素，它们被比较的概率是多少？正如我们在上一张幻灯片中所讨论的那样，比较两个元素的概率取决于它们在数组的排序版本中的接近程度。</p>
    <p class="">For this reason, we define c of ij dependent on the sorted array.</p>
    <p class="line_zh">因此，我们定义依赖于排序数组的i的c。</p>
    <p class="">We do not have this sorted array, right? We are only constructing this in the quick sort algorithm but we use it just
        for the analysis, okay? The next thing to note is the following.</p>
    <p class="line_zh">我们没有这个排序的数组，对吧？我们只是在快速排序算法中构建它，但我们只是用于分析，好吗？接下来要注意的是以下内容。</p>
    <p class="">For any two elements of our initial array assorted array doesn't matter, so for any two elements they are either compared
        just once or they are not compared at all.</p>
    <p class="line_zh">对于我们的初始数组的任何两个元素，各种数组并不重要，因此对于任何两个元素，它们要么只进行一次比较，要么根本不进行比较。</p>
    <p class="">So, why is that? Why just once? Well, if two elements are compared at some point, this means that at this point one of
        these elements is because in the partition procedure we can put a with all of the elements of the current summary.</p>
    <p class="line_zh">那么，为什么呢？为什么只有一次？好吧，如果在某一点比较两个元素，这意味着此时其中一个元素是因为在分区过程中我们可以使用当前摘要的所有元素。</p>
    <p class="">So, if two elements are compared that one of them is a pivot.</p>
    <p class="line_zh">因此，如果比较两个元素，其中一个元素是一个支点。</p>
    <p class="">This also means that right after the call of this partition procedure, we are not going to use this pivot element.</p>
    <p class="line_zh">这也意味着在调用此分区过程之后，我们不会使用此pivot元素。</p>
    <p class="">We will put the pivot element into its final place, and we are not going to touch it in any of the subsequent calls.</p>
    <p class="line_zh">我们将把枢轴元素放到最后的位置，我们不会在任何后续调用中触摸它。</p>
    <p class="">This immediately implies the quadratic upper bound on the worst case right in time with final algorithm.</p>
    <p class="line_zh">这立即意味着最终情况下的最终情况的二次上界与最终算法的正确性。</p>
    <p class="">Once again we have quadratic number of possible pairs of element, and each pair of element is as it compared once or
        not compared at all.</p>
    <p class="line_zh">我们再次具有二次数量的可能元素对，并且每对元素在比较一次或根本不进行比较时。</p>
    <p class="">Right so right in time with the worst case is quadratic.</p>
    <p class="line_zh">在最坏的情况下及时正确是二次的。</p>
    <p class="">Now comes the most important observation of this proof.</p>
    <p class="line_zh">现在来看这个证明是最重要的观察。</p>
    <p class="">I claim that the elements A'[i] and A'[j] are compared if and only if the first pivot selected in the subrange of the
        solitary a prime from either side to index j is either a prime of a, of i, or a prime of j.</p>
    <p class="line_zh">我声称元素A'[i]和A'[j]被比较，当且仅当在从一侧到索引j的孤立的子范围中选择的第一个枢轴是i的一个素数时，i，或j的一个黄金。</p>
    <p class="">Well let's see why.</p>
    <p class="line_zh">好吧，让我们看看为什么。</p>
    <p class="">First of all, when we select it pivot the random pivot which is not in their sub range, and then all the elements from
        this sub range in this sort of element goes either to the left or this to the right.</p>
    <p class="line_zh">首先，当我们选择它时，转动不在其子范围内的随机数据轴，然后此类元素中此子范围内的所有元素将向左或向右移动。</p>
    <p class="">So, they all stay together in the same branch of three, okay.</p>
    <p class="line_zh">所以，他们都在三个人的同一个分支，好吧。</p>
    <p class="">So before we select a pivot which stays inside this range, all these elements stay together in the same sub-array.</p>
    <p class="line_zh">因此，在我们选择一个保持在此范围内的枢轴之前，所有这些元素都保持在同一个子阵列中。</p>
    <p class="">Now, assume that we selected a pivot from this sub-range, and assume that it is not A'[i] or A'[j], for example.</p>
    <p class="line_zh">现在，假设我们从该子范围中选择了一个枢轴，并假设它不是A'[i]或A'[j]，例如。</p>
    <p class="">In this case a prime of A and a prime of J will be splitted apart.</p>
    <p class="line_zh">在这种情况下，A的素数和J的素数将被分开。</p>
    <p class="">They will go into different parts with respect to this pivot, right? At this point I must humor that all the elements
        in my summary are different, and in duality are different, okay? So once again, if the first selected element from
        this subrange is not prime of A or a prime of j then these two elements are not going to be compared.</p>
    <p class="line_zh">关于这个支点，他们将分为不同的部分，对吧？在这一点上，我必须幽默，我的总结中的所有元素都是不同的，并且二元性是不同的，好吗？因此，如果此子范围中的第一个选定元素不是A的素数或j的素数，那么这两个元素将不会被比较。</p>
    <p class="">Because right after the partition procedure uses this pivot from this range A prime of a and A prime of j will go to
        different parts, right? If, on the other hand, the first selected pivot from this subrange is either A prime of a
        or A prime of j, then these two elements are going to become paired, right? So this is the most important observation
        in this proof.</p>
    <p class="line_zh">因为在分区程序之后立即使用此范围中的此枢轴，a的a和a的素数将转到不同的部分，对吧？另一方面，如果来自该子范围的第一个选定的枢轴是a的素数或者是j的素数，那么这两个元素将成为配对，对吧？所以这是这个证明中最重要的观察。</p>
    <p class="">Everything else is just calculations.</p>
    <p class="line_zh">其他一切都只是计算。</p>
    <p class="">So if this is clear, let's then estimate the probability that second respondent to elements are compared.</p>
    <p class="line_zh">因此，如果这一点很清楚，那么让我们估计第二个对元素的响应者进行比较的概率。</p>
    <p class="">So we know that they're compared if and only if the first selected Pivot in this sub range is one of these two elements.</p>
    <p class="line_zh">因此我们知道，当且仅当此子范围中的第一个选定的Pivot是这两个元素中的一个时，才对它们进行比较。</p>
    <p class="">This helps us to estimate the probability of not the fact that c of i j is equal to one.</p>
    <p class="line_zh">这有助于我们估计不是i的c等于1的概率。</p>
    <p class="">Well this is equal to two.</p>
    <p class="line_zh">那么这相当于两个。</p>
    <p class="">I mean because we have only two choices.</p>
    <p class="line_zh">我的意思是因为我们只有两个选择。</p>
    <p class="">I mean either a prime of a, or a prime of j divided by the total number of choices, I mean the total number of elements
        in this subrange.</p>
    <p class="line_zh">我的意思是要么是a的素数，要么是j的素数除以选择的总数，我的意思是这个子范围中的元素总数。</p>
    <p class="">And this is j minus i plus 1.</p>
    <p class="line_zh">这是j减去i加1。</p>
    <p class="">So the probability that Z of ij is equal to 1 equals 2 divided by g minus i plus 1.</p>
    <p class="line_zh">因此，ij的Z等于1的概率等于2除以g减去i加1。</p>
    <p class="">For example, if j and i differ by 1.</p>
    <p class="line_zh">例如，如果j和i相差1。</p>
    <p class="">So j is equal to y plus 1.</p>
    <p class="line_zh">所以j等于y加1。</p>
    <p class="">So neighboring element in the.</p>
    <p class="line_zh">所以邻近的元素。</p>
    <p class="">Then this probability is equal to 2 divided by 1 plus 1.</p>
    <p class="line_zh">那么这个概率等于2除以1加1。</p>
    <p class="">This is 2 by 2, this is 1.</p>
    <p class="line_zh">这是2乘2，这是1。</p>
    <p class="">[INAUDIBLE] Just reflects the fact that if there are two neighboring elements inside.</p>
    <p class="line_zh">[听不清]只是反映了如果内部有两个相邻元素的事实。</p>
    <p class="">This sorted array, then the algorithm just must compare them, to understand that one of them is smaller.</p>
    <p class="line_zh">这个排序的数组，然后算法只需要比较它们，以了解其中一个更小。</p>
    <p class="">There is no other element that can help our algorithm to realize that one of these element is smaller than the other
        one, okay.</p>
    <p class="line_zh">没有其他元素可以帮助我们的算法实现这些元素中的一个比另一个小，好吧。</p>
    <p class="">This in turn helps us to estimate the expected value of this random variable.</p>
    <p class="line_zh">这反过来有助于我们估计这个随机变量的期望值。</p>
    <p class="">So recall that if we have a random variable, which takes only values zero and one, then its expected value is one multiplied
        by the probability that it takes value one plus zero multiplied by the probability that it takes the value zero.</p>
    <p class="line_zh">所以回想一下，如果我们有一个随机变量，它只取值0和1，那么它的期望值就是乘以一个加零的概率乘以它取值为零的概率。</p>
    <p class="">Well zero multiplied by something is zero.</p>
    <p class="line_zh">零点乘以某物为零。</p>
    <p class="">So what is left is just probability.</p>
    <p class="line_zh">所以剩下的只是概率。</p>
    <p class="">That it takes multiplied by one.</p>
    <p class="line_zh">它需要乘以一。</p>
    <p class="">So the expected value of CIJ is equal to 2 divided by g minus i plus one.</p>
    <p class="line_zh">所以CIJ的预期值等于2除以g减去i加1。</p>
    <p class="">The final step in our proof is estimating the sum random variables to see they all possible I and J.</p>
    <p class="">我们证明的最后一步是估计总和随机变量，看看它们都是可能的I和J.</p>
    <p class="">So, once again the expected value of average value of the sum of the number of comparisons made is the expected value
        of the sum of all possible x adjacent, or for all I Js.</p>
    <p class="line_zh">因此，所进行的比较次数之和的平均值的预期值再次是所有可能的x邻近或所有I Js的总和的期望值。</p>
    <p class="">So the expected value of their sum is the sum of their expected values.</p>
    <p class="line_zh">因此，它们的总和的期望值是它们的预期值的总和。</p>
    <p class="">So we can write the following.</p>
    <p class="line_zh">所以我们可以写下面的内容。</p>
    <p class="">The average running time is equal to the sum overall possible different of the expected values cij, and we know this
        expected value already.</p>
    <p class="line_zh">平均运行时间等于预期值cij的总体可能总和，我们已经知道这个预期值。</p>
    <p class="">So this is a some overall possible different ij, in where j is greater than i of 2 divided by g minus i plus one.</p>
    <p class="line_zh">所以这是一个总体可能不同的ij，其中j大于i的2除以g减去i加1。</p>
    <p class="">Well we can take this constant two out, and consider all the possible.</p>
    <p class="line_zh">好吧，我们可以把这两个常数拿出来，并考虑所有可能的。</p>
    <p class="">And consider a fixed i.</p>
    <p class="line_zh">并考虑一个固定的i。</p>
    <p class="">For this i what we have j ranges from i+1 to n.</p>
    <p class="line_zh">为此，我们所拥有的j的范围从i + 1到n。</p>
    <p class="">So what we have for the specified time in this sum is a subset of the following sum, 1/2+1/3+1/4 and so on.</p>
    <p class="line_zh">因此，我们在此总和中指定时间的内容是以下总和的子集，1/2 + 1/3 + 1/4，依此类推。</p>
    <p class="">And this is actually a known sum.</p>
    <p class="line_zh">这实际上是一个已知的总和。</p>
    <p class="">This is called harmonic series and it is known that it grows arithmetically.</p>
    <p class="line_zh">这被称为谐波系列，并且已知它在算术上增长。</p>
    <p class="">Once again, 1 over 2 plus 1 over 3 plus, and so on, 1 over n, is theta of logarithm of n.</p>
    <p class="line_zh">再一次，1比2加1加3加，依此类推，1比n，是n的对数θ。</p>
    <p class="">Well, this means that, for each they correspond in sum, which ranges over all j from i plus 1 through n, grows, at most,
        logarithmically.
    </p>
    <p class="line_zh">嗯，这意味着，对于每个它们总和相对应的范围，从i加1到n的所有j的范围，最多以对数方式增长。</p>
    <p class="">This means since we have m traces for i from one to m that the grows vertically as m.</p>
    <p class="line_zh">这意味着因为我们有一条从i到m的m轨迹，所以m垂直增长为m。</p>
    <p class="">Okay, and this concludes our proof.</p>
    <p class="line_zh">好的，这就是我们的证据。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 47 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_47">第05章 equal elements
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">05相等的元素</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this video we address the issue of equal elements in the.</p>
    <p class="line_zh">在这个视频中，我们解决了相同元素的问题。</p>
    <p class="">So recall that we proved the upper bound on the running time of the render Greek algorithm, in the assumption that all
        the elements inside the given array are prioritized different.</p>
    <p class="line_zh">所以回想一下，我们证明了渲染希腊算法的运行时间的上限，假设给定数组中的所有元素的优先级不同。</p>
    <p class="">And actually, we used essentially these assumptions.</p>
    <p class="line_zh">实际上，我们基本上使用了这些假设。</p>
    <p class="">So, recall that we estimated the probability that two elements, A prime of I and A prime of J are comparative.</p>
    <p class="line_zh">因此，回想一下，我们估计了两个元素的概率，即I的素数和J的素数是比较的。</p>
    <p class="">And we argued that if any element between them is selected, the appearance is that they will not become period.</p>
    <p class="line_zh">我们认为如果选择它们之间的任何元素，那么外观就是它们不会成为句号。</p>
    <p class="">However, if they are equal, so if A prime of A is equal to A prime of J, this means actually that all the elements in
        this range are equal.</p>
    <p class="line_zh">但是，如果它们相等，那么如果A的素数等于J的素数，这实际上意味着该范围内的所有元素都是相等的。</p>
    <p class="">So if we select any element inside this range, in the middle of this range, as a pivot, then it is not true that these
        two elements will go into different parts with respect to this element, this is just because all of the elements
        inside this range are equal, which means that if we partition with respect of this element, all of the elements in
        this range will be [INAUDIBLE] this element.</p>
    <p class="line_zh">因此，如果我们选择此范围内的任何元素，在此范围的中间，作为一个枢轴，那么这两个元素相对于此元素将进入不同的部分并不是真的，这只是因为内部的所有元素这个范围是相等的，这意味着如果我们对这个元素进行分区，这个范围内的所有元素都将是[INAUDIBLE]这个元素。</p>
    <p class="">So, they all will be in the left part with respect to this element, okay? So our analysis doesn't work for equal elements
        but let's see what happens in real life.</p>
    <p class="line_zh">所以，他们都将在这个元素的左边部分，好吗？因此，我们的分析不适用于相同的元素，但让我们看看现实生活中会发生什么。</p>
    <p class="">What happens if we run the greek sort algorithm for the array in which there are equal elements.</p>
    <p class="line_zh">如果我们为具有相同元素的数组运行希腊排序算法会发生什么。</p>
    <p class="">For this, let's use the following online visualization.</p>
    <p class="line_zh">为此，我们使用以下在线可视化。</p>
    <p class="">This visualization shows how different selection, different certain algorithms that are formed on different datasets.</p>
    <p class="line_zh">此可视化显示了不同的选择，不同的特定算法在不同数据集上的形成方式。</p>
    <p class="">So there are eight certain algorithms here where we are now interested in this QuickSort algorithm.</p>
    <p class="line_zh">因此，这里有八种特定算法，我们现在对这种QuickSort算法感兴趣。</p>
    <p class="">And there are four different types of datasets.</p>
    <p class="line_zh">并且有四种不同类型的数据集。</p>
    <p class="">So the field datasets is just random sequence.</p>
    <p class="line_zh">因此，字段数据集只是随机序列。</p>
    <p class="">The next one is in sorted sequence, the next one is a reversed sequence and the next one which is most interesting to
        us at the moment is a sequence that contains a few unique elements.</p>
    <p class="line_zh">下一个是排序顺序，下一个是反向序列，下一个对我们来说最感兴趣的是包含一些独特元素的序列。</p>
    <p class="">So let's see how the greek sort algorithm performs on the last dataset.</p>
    <p class="line_zh">那么让我们看看希腊排序算法如何在最后一个数据集上执行。</p>
    <p class="">So for this let's just run all the algorithms, on all data sets.</p>
    <p class="line_zh">所以为此，我们只需在所有数据集上运行所有算法。</p>
    <p class="">So let's see what happens here.</p>
    <p class="line_zh">那么让我们看看这里发生了什么。</p>
    <p class="">So you, you may notice now that, for example, have already sorted everything.</p>
    <p class="line_zh">那么你，你可能会注意到，例如，已经对所有东西进行了排序。</p>
    <p class="">And while greek sort have just finished to sort the last, the last data set.</p>
    <p class="line_zh">虽然希腊排序刚刚完成排序最后一个，最后一个数据集。</p>
    <p class="">So Greek sort is not, is not so fast on data sets that contains few unique elements and this is why.</p>
    <p class="line_zh">所以希腊排序不是，在包含很少独特元素的数据集上不是那么快，这就是原因。</p>
    <p class="">So just consider a dataset that consists of elements that are all equal to each other.</p>
    <p class="line_zh">因此，只需考虑一个由彼此相等的元素组成的数据集。</p>
    <p class="">So all elements are equal to each.</p>
    <p class="line_zh">所以所有元素都等于每个元素。</p>
    <p class="">This means that the selection, the partition procedure always partitions the array with respect to the element x, right?
        And then in this case, one of the parts, namely the part of the elements that are greater than x, is just empty.</p>
    <p class="line_zh">这意味着选择，分区过程总是相对于元素x对数组进行分区，对吗？然后在这种情况下，其中一个部分，即大于x的元素部分，只是空的。</p>
    <p class="">It has size zero.</p>
    <p class="line_zh">它的大小为零。</p>
    <p class="">And the other part has size n minus one.</p>
    <p class="line_zh">另一部分的大小为n减1。</p>
    <p class="">So the records and equalities, the records equalities on the running time of how a algorithm on such a data set always
        satisfies the following relation, T of n is equal to T of n minus 1 plus a linear term plus T of 0.</p>
    <p class="line_zh">因此，记录和等式，算法在这样的数据集上的运行时间的记录等式总是满足以下关系，n的T等于n减去1加上线性项加T为0。</p>
    <p class="">And we know already, so this is an unbalanced partition.</p>
    <p class="line_zh">我们已经知道了，所以这是一个不平衡的分区。</p>
    <p class="">We know the responds to the quadratic right in time so, which means that the running time of the quick sort algorithm
        a very simple array.</p>
    <p class="line_zh">我们知道响应时间的二次权利，这意味着快速排序算法的运行时间是一个非常简单的数组。</p>
    <p class="">So it contains all the elements of this array are equal.</p>
    <p class="line_zh">所以它包含了这个数组的所有元素是相等的。</p>
    <p class="">Which means that actually this array is already sorted.</p>
    <p class="line_zh">这意味着实际上这个数组已经排序了。</p>
    <p class="">In this array our quick sort algorithm spends a quadratic time to sort it to overcome this difficulty we'll do the following.</p>
    <p class="line_zh">在这个数组中，我们的快速排序算法花费了一个二次时间来对其进行排序以克服这个困难，我们将执行以下操作。</p>
    <p class="">Instead of partitioning our rate into two regions.</p>
    <p class="line_zh">而不是将我们的速率划分为两个区域。</p>
    <p class="">Namely these regions contain all elements that contain all x and all elements that are greater than x.</p>
    <p class="line_zh">即这些区域包含包含所有x的所有元素以及大于x的所有元素。</p>
    <p class="">We are going to partition into three parts.</p>
    <p class="line_zh">我们将分为三个部分。</p>
    <p class="">The corresponding partition procedure is usually called three-way partition.</p>
    <p class="line_zh">相应的分区过程通常称为三向分区。</p>
    <p class="">Formally, it returns two indices.</p>
    <p class="line_zh">形式上，它返回两个指数。</p>
    <p class="">m1 and m2, such that, all the elements inside the region from m1 to m2 are equal to x.</p>
    <p class="line_zh">m1和m2，使得从m1到m2的区域内的所有元素都等于x。</p>
    <p class="">All the elements to the left of this region are smaller than x.</p>
    <p class="line_zh">该区域左侧的所有元素都小于x。</p>
    <p class="">All the elements that are to the right of this region are greater than x.</p>
    <p class="line_zh">该区域右侧的所有元素都大于x。</p>
    <p class="">So this is how it looks pictorially.</p>
    <p class="line_zh">所以这就是它的外观。</p>
    <p class="">We have three regions.</p>
    <p class="line_zh">我们有三个地区。</p>
    <p class="">So, from l to m1 minus 1, we have all elements that are smaller than x.</p>
    <p class="line_zh">因此，从l到m1减1，我们有所有小于x的元素。</p>
    <p class="">In the region from m1 to m2, we have all elements that are equal to x.</p>
    <p class="line_zh">在从m1到m2的区域中，我们拥有等于x的所有元素。</p>
    <p class="">In the region from m2 plus 1 to r, we have all elements that are greater than x.</p>
    <p class="line_zh">在从m2加1到r的区域中，我们拥有大于x的所有元素。</p>
    <p class="">This procedure actually can be implemented in a similar way to their regional partition procedure.</p>
    <p class="line_zh">实际上，此过程可以以与其区域分区过程类似的方式实现。</p>
    <p class="">It can be implemented ties with a single kind of area with maintaing their regions or it can be implemented with two
        counts.
    </p>
    <p class="line_zh">它可以通过维护其区域来实现与单一区域的联系，或者可以通过两个计数来实现。</p>
    <p class="">So we first split our rate into regions which contain elements of most x or greater than x and then we split the region
        into two parts.</p>
    <p class="line_zh">因此，我们首先将我们的速率分成包含大多数x或大于x的元素的区域，然后我们将该区域分成两部分。</p>
    <p class="">Well, this is how the modified randomized quick sort algorithm is going to apply.</p>
    <p class="line_zh">那么，这就是改进的随机快速排序算法将如何应用。</p>
    <p class="">So we just replace it, the cold partition procedure by a cold two partition suite procedure.</p>
    <p class="line_zh">所以我们只需用冷的两个分区套件程序替换它，冷分区程序。</p>
    <p class="">Now we have three regions, and, actually the middle region is in its final place, so we do not touch it after the partition
        procedure.
    </p>
    <p class="line_zh">现在我们有三个区域，实际上中间区域位于最终位置，所以我们在分区程序之后不要触摸它。</p>
    <p class="">We make two recursive calls to the first region and to the last region.</p>
    <p class="line_zh">我们对第一个区域和最后一个区域进行两次递归调用。</p>
    <p class="">So, let's see whether the resulting algorithm is indeed Greek.</p>
    <p class="line_zh">那么，让我们看看生成的算法是否确实是希腊语。</p>
    <p class="">And for this, let's use the same visualization.</p>
    <p class="line_zh">为此，让我们使用相同的可视化。</p>
    <p class="">The resulting algorithm is shown here in the last column.</p>
    <p class="line_zh">最终列中显示了生成的算法。</p>
    <p class="">Let's, once again, run all the algorithms and see what happens in the last column.</p>
    <p class="line_zh">让我们再次运行所有算法，看看最后一列中发生了什么。</p>
    <p class="">Well we see that now, the results in Greek algorithm, is indeed Greek.</p>
    <p class="line_zh">好吧，我们现在看到，希腊算法的结果，确实是希腊语。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 48 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_48">第06章 final remarks
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">06最后的评论</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this last video of the Quicksort lesson, I would like to address two implementation issues.</p>
    <p class="line_zh">在Quicksort课程的最后一个视频中，我想解决两个实现问题。</p>
    <p class="">So the first issue is about space complexity of the QuickSort algorithm.</p>
    <p class="line_zh">所以第一个问题是关于QuickSort算法的空间复杂性。</p>
    <p class="">So on one hand, when sorting an array by a Quicksort algorithm, we do not use any additional space.</p>
    <p class="line_zh">因此，一方面，当使用Quicksort算法对数组进行排序时，我们不会使用任何额外的空间。</p>
    <p class="">We just partition the array and with small elements inside the array.</p>
    <p class="line_zh">我们只是对数组进行分区，并在数组中使用小元素。</p>
    <p class="">On the other hand, the QuickSort algorithm is a recursive algorithm.</p>
    <p class="line_zh">另一方面，QuickSort算法是递归算法。</p>
    <p class="">And when we make a recursive call we store some information on this tech.</p>
    <p class="line_zh">当我们进行递归调用时，我们会存储有关此技术的一些信息。</p>
    <p class="">Right? So on one hand it is possible to show that the average recurrent depths is logarithmic.</p>
    <p class="line_zh">对？因此，一方面可以证明平均复发深度是对数的。</p>
    <p class="">Meaning that we need only a logarithmic additional space.</p>
    <p class="line_zh">这意味着我们只需要一个对数的额外空间。</p>
    <p class="">On the other hand, there is a very nice and elegant trick that allows to re-implement the QuickSort algorithm, such that
        it's worst case space complexity is at most logarithmic.</p>
    <p class="line_zh">另一方面，有一个非常漂亮和优雅的技巧，允许重新实现QuickSort算法，这样它的最坏情况空间复杂度至多是对数。</p>
    <p class="">So for this, let's recall that the QuickSort algorithm contains of the call to the partition procedure and then of two
        recursive calls.</p>
    <p class="line_zh">因此，让我们回想一下，QuickSort算法包含对分区过程的调用，然后是两次递归调用。</p>
    <p class="">So the situation when we have a recursive call is and, if the procedure is called tail recursion.</p>
    <p class="line_zh">因此，当我们进行递归调用时的情况是，如果该过程被称为尾递归。</p>
    <p class="">And there is a known way to eliminate such a recursive call.</p>
    <p class="line_zh">并且有一种已知的方法可以消除这种递归调用。</p>
    <p class="">Namely, instead of making this recursive call, let's just update.</p>
    <p class="line_zh">也就是说，让我们只是更新，而不是进行这种递归调用。</p>
    <p class="">Well, in the second recursive call, we sort the right part of our array.</p>
    <p class="line_zh">好吧，在第二次递归调用中，我们对数组的正确部分进行排序。</p>
    <p class="">I mean, the part from index n+1 to index r.</p>
    <p class="line_zh">我的意思是，从索引n + 1到索引r的部分。</p>
    <p class="">Instead of making this recursive call, let's replace the with a while loop, inside this while loop we call the partition
        procedure as shown on the slide.</p>
    <p class="line_zh">不要进行这种递归调用，而是使用while循环替换，在while循环中我们调用分区过程，如幻灯片所示。</p>
    <p class="">Then we make a recursive call to the left part, but instead of making the recursive call for the right part, we'll just
        update the value of l to be equal to m+1.</p>
    <p class="line_zh">然后我们对左边部分进行递归调用，但是我们只是将l的值更新为等于m + 1，而不是对正确的部分进行递归调用。</p>
    <p class="">And then we go to the beginning of this while loop, and this essentially mimics our recursive call.</p>
    <p class="line_zh">然后我们转到这个while循环的开头，这基本上模仿了我们的递归调用。</p>
    <p class="">So far so good.</p>
    <p class="line_zh">到现在为止还挺好。</p>
    <p class="">We've just realized that we can eliminate the last recursive call.</p>
    <p class="line_zh">我们刚刚意识到我们可以消除最后一次递归调用。</p>
    <p class="">At the same time let's also realize the following thing.</p>
    <p class="line_zh">同时让我们也意识到以下事情。</p>
    <p class="">In our QuickSort algorithm we first call the partition precision, then we make two recursive calls.</p>
    <p class="line_zh">在我们的QuickSort算法中，我们首先调用分区精度，然后我们进行两次递归调用。</p>
    <p class="">And these two recursive calls are in a sense independent.</p>
    <p class="line_zh">而这两个递归调用在某种意义上是独立的。</p>
    <p class="">Well it doesn't matter which comes first, right? So they do not depend on each other.</p>
    <p class="line_zh">嗯先到哪个都没关系，对吧？所以他们不相互依赖。</p>
    <p class="">This means that we can as well eliminate a recursive call through the first part.</p>
    <p class="line_zh">这意味着我们也可以通过第一部分消除递归调用。</p>
    <p class="">Well, and this in turn means that we can always select which one to eliminate.</p>
    <p class="line_zh">好吧，这反过来意味着我们总能选择消除哪一个。</p>
    <p class="">And for us, it is better to remove a recursive call to a longer part.</p>
    <p class="line_zh">对我们来说，最好删除对较长部分的递归调用。</p>
    <p class="">And this is why, if we always make a recursive call during the rate which is shorter, then we make a recursive call during
        the rate which is at least twice shorter than the initial already, right? And this in turn means that the depths
        of our recursion will be at most logarithmic.</p>
    <p class="line_zh">这就是为什么，如果我们总是在较短的速率期间进行递归调用，那么我们在速率期间进行递归调用，该速率至少比初始速率短两倍，对吧？而这反过来意味着我们递归的深度将是最多的对数。</p>
    <p class="">Because well, the first recursive call is made for an array of size of at most n over 2, then at most n over 4 and so
        on.
    </p>
    <p class="line_zh">因为，第一次递归调用是针对一个大小最多n超过2的数组，然后最多n超过4，依此类推。</p>
    <p class="">So the depth is logarithmic, which is good.</p>
    <p class="line_zh">所以深度是对数的，这是好的。</p>
    <p class="">And this can be implemented as follows.</p>
    <p class="line_zh">这可以实现如下。</p>
    <p class="">So we first call the partition procedure.</p>
    <p class="line_zh">所以我们先调用分区程序。</p>
    <p class="">It gives us a value of m.</p>
    <p class="line_zh">它给出了m的值。</p>
    <p class="">At this point, we know the length of two parts.</p>
    <p class="line_zh">在这一点上，我们知道两个部分的长度。</p>
    <p class="">And we just compare them.</p>
    <p class="line_zh">我们只是比较它们。</p>
    <p class="">If, for example, the lengths of the first part is shorter, then we make a recursive call to this part.</p>
    <p class="line_zh">例如，如果第一部分的长度较短，那么我们对该部分进行递归调用。</p>
    <p class="">And instead of making the recursive call for the second part, we just update the value of l.</p>
    <p class="line_zh">而不是对第二部分进行递归调用，我们只更新l的值。</p>
    <p class="">In the other case when the right part is shorter, we make the recursive call for this part, and instead of making the
        recursive call for this part, we'll just update the value of r.</p>
    <p class="line_zh">在另一种情况下，当右边部分较短时，我们对这部分进行递归调用，而不是对这部分进行递归调用，我们只是更新r的值。</p>
    <p class="">Right? So overall this gives us an implementation of the QuickSort algorithm which uses in the worst case an additional
        logarithmic space.</p>
    <p class="line_zh">对？总的来说，这为我们提供了QuickSort算法的实现，该算法在最坏的情况下使用了额外的对数空间。</p>
    <p class="">So the next implementation issue concerns the random bits used by our algorithm.</p>
    <p class="line_zh">因此，下一个实现问题涉及我们的算法使用的随机位。</p>
    <p class="">So I assume that we would like to have a deterministic version of our randomized QuickSort.</p>
    <p class="line_zh">所以我假设我们想要一个随机化QuickSort的确定性版本。</p>
    <p class="">And this is a reasonable thing to want because in practice we would like to have such a thing as reproducibility, which
        is for example essential for debugging.</p>
    <p class="line_zh">这是一个合理的想法，因为在实践中我们希望有一个可重复性的东西，这对于调试来说是必不可少的。</p>
    <p class="">So we would like our program to always output the same, on the same dataset.</p>
    <p class="line_zh">因此，我们希望我们的程序始终在同一数据集上输出相同的内容。</p>
    <p class="">And this is why we would probably not like to use random numbers, okay? Then we can do the following.</p>
    <p class="line_zh">这就是为什么我们可能不想使用随机数，好吗？然后我们可以做到以下几点。</p>
    <p class="">The following algorithm is known as intro sort and is used in many practical implementation of QuickSort.</p>
    <p class="line_zh">以下算法称为简介排序，用于QuickSort的许多实际实现。</p>
    <p class="">So instead of selecting the pivot element randomly, let's select it as follows using, for example, the following simple
        heuristic.
    </p>
    <p class="line_zh">因此，不要随机选择pivot元素，而是使用例如以下简单的启发式方法选择它。</p>
    <p class="">Each time when we're given a summary, and we need to partition it with respect to some pivot.</p>
    <p class="line_zh">每当我们得到摘要时，我们需要根据某个支点对其进行分区。</p>
    <p class="">So for this we need to select pivot, and let's select it as follows.</p>
    <p class="line_zh">因此，我们需要选择pivot，然后按如下方式选择它。</p>
    <p class="">We take the first element of the summary, the last element and the middle element, for example.</p>
    <p class="line_zh">例如，我们采用摘要的第一个元素，最后一个元素和中间元素。</p>
    <p class="">Then we have three elements, and we sort them.</p>
    <p class="line_zh">然后我们有三个元素，我们对它们进行排序。</p>
    <p class="">We just compare them and we select the medium value of these.</p>
    <p class="line_zh">我们只是比较它们，然后选择它们的中值。</p>
    <p class="">And we use this element as our pivot element.</p>
    <p class="line_zh">我们使用这个元素作为我们的枢轴元素。</p>
    <p class="">So this is a very simple heuristic, it can be implemented very efficiently.</p>
    <p class="line_zh">所以这是一个非常简单的启发式方法，它可以非常有效地实现。</p>
    <p class="">We just need three comparisons to select this median.</p>
    <p class="line_zh">我们只需要三次比较来选择这个中位数。</p>
    <p class="">And in many cases this is enough for the QuickSort algorithm to work effectively.</p>
    <p class="line_zh">在许多情况下，这足以使QuickSort算法有效地工作。</p>
    <p class="">However, this is not what we want, right.</p>
    <p class="line_zh">但是，这不是我们想要的，对吧。</p>
    <p class="">We are not happy with the statement that this algorithm works.</p>
    <p class="line_zh">我们对此算法有效的说法不满意。</p>
    <p class="">Works well in many cases.</p>
    <p class="line_zh">在许多情况下效果很好。</p>
    <p class="">We would like our algorithm to works well just on every possible input.</p>
    <p class="line_zh">我们希望我们的算法能够很好地适用于所有可能的输入。</p>
    <p class="">Unfortunately there are pathological cases in which these heuristics works badly.</p>
    <p class="line_zh">不幸的是，存在这些启发式工作严重的病态案例。</p>
    <p class="">But we can overcome this in the following way.</p>
    <p class="line_zh">但我们可以通过以下方式克服这个问题。</p>
    <p class="">While running our QuickSort algorithm, well let's count what is the current depths of our recursion three.</p>
    <p class="line_zh">在运行我们的QuickSort算法时，让我们计算三次递归的当前深度。</p>
    <p class="">And at some point when it exceeds some values here again, for some constant c, then we just stop the current algorithm
        and switch to some other algorithm.</p>
    <p class="line_zh">并且在某些时候，当它再次超过某些值时，对于某些常数c，那么我们只需停止当前算法并切换到其他算法。</p>
    <p class="">For example for the heap sort algorithm.</p>
    <p class="line_zh">例如，对于堆排序算法。</p>
    <p class="">This is another efficient algorithm, which is, asymptotically as good as MergeSort I mean, it has asymptotic again.</p>
    <p class="line_zh">这是另一种有效的算法，它渐渐地和MergeSort一样好，我的意思是它再次渐近。</p>
    <p class="">However Greek sort is usually faster in practice.</p>
    <p class="line_zh">然而，希腊排序通常在实践中更快。</p>
    <p class="">So, at this point, we switch to the quick sort algorithm.</p>
    <p class="line_zh">所以，在这一点上，我们切换到快速排序算法。</p>
    <p class="">Which means that for these pathological bad instances, for the QuickSort with this simple heuristic of selecting the
        pivot element, we still work in the worst case in time n log m.</p>
    <p class="line_zh">这意味着对于这些病态的不良实例，对于使用这种简单的启发式选择枢轴元素的QuickSort，我们仍然在最坏的情况下工作n log m。</p>
    <p class="">Because before we exceeded the depth c log n, we spend time n log m.</p>
    <p class="line_zh">因为在超过深度c log n之前，我们花费时间n log m。</p>
    <p class="">And after this, we'll start this algorithm.</p>
    <p class="line_zh">在此之后，我们将启动此算法。</p>
    <p class="">Immediately and we run the heap sort algorithm.</p>
    <p class="line_zh">我们立即运行堆排序算法。</p>
    <p class="">So overall, we've spent time n log n.</p>
    <p class="line_zh">总的来说，我们花了时间n log n。</p>
    <p class="">So this gives us an algorithm which in many cases performs like the QuickSort algorithm and in any case, just in the
        worst case, its running time is bounded above by n log n.</p>
    <p class="line_zh">因此，这为我们提供了一种算法，在许多情况下，它像QuickSort算法一样执行，在任何情况下，只是在最坏的情况下，它的运行时间超过n log n。</p>
    <p class="">So to conclude, the QuickSort algorithm is a comparison based algorithm whose running time is big O of n log n in the
        average case, and big O of n squared in the worst case.</p>
    <p class="line_zh">总而言之，QuickSort算法是一种基于比较的算法，其运行时间在平均情况下为n log n的大O，在最坏的情况下为n的大O平方。</p>
    <p class="">What is important in this algorithm is that it is very efficient in practice.</p>
    <p class="line_zh">该算法的重要之处在于它在实践中非常有效。</p>
    <p class="">It is more efficient than the north shore algorithim for example.</p>
    <p class="line_zh">例如，它比北岸算法更有效。</p>
    <p class="">For this reason it is commonly used in practice and for this reason it is called QuickSort</p>
    <p class="">出于这个原因，它通常在实践中使用，因此称为QuickSort</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 49 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_49">第01章 change problem
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01改变问题</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Before recording this lecture, I stopped by the coffee shop.</p>
    <p class="line_zh">在录制这个讲座之前，我在咖啡店停了下来。</p>
    <p class="">This cappuccino is good.</p>
    <p class="line_zh">这卡布奇诺很好吃。</p>
    <p class="">And as soon as I gave $5 to the cashier, she faced an algorithmic problem of which coins to select to give me the change.</p>
    <p class="line_zh">当我给收银员5美元时，她遇到了一个算法问题，哪个硬币可以选择给我改变。</p>
    <p class="">And cashiers all over the world use an algorithmic approach called greedy algorithm to solve this problem.</p>
    <p class="line_zh">世界各地的收银员都使用称为贪婪算法的算法来解决这个问题。</p>
    <p class="">Today we will learn how cashiers and computer scientists use greedy algorithm for solving many practical problems.</p>
    <p class="line_zh">今天我们将了解收银员和计算机科学家如何使用贪婪算法来解决许多实际问题。</p>
    <p class="">So the change problem is finding the minimum number of coins needed to make change.</p>
    <p class="line_zh">因此，变化问题是找到进行变更所需的最小硬币数量。</p>
    <p class="">More formally, input to the problem is integer money and positive integers, coin1, coin2, coind, that represents coin
        denominations.
    </p>
    <p class="line_zh">更正式地说，问题的输入是整数货币和正整数，coin1，coin2，coind，它代表硬币面额。</p>
    <p class="">For example in the US, coin1 will be 1 cents, coin2 will be 5 cents, 10 cents, 25 cents, and 50 cents.</p>
    <p class="line_zh">例如在美国，coin1将是1美分，coin2将是5美分，10美分，25美分和50美分。</p>
    <p class="">And the output is the minimum number of coins, with denominations coin1, coin2, coind that changes money exactly.</p>
    <p class="line_zh">并且输出是最小数量的硬币，面值coin1，coin2，coind可以准确地改变金钱。</p>
    <p class="">So today in the morning, when cashier had to return me 40 cents, she most likely used the following algorithm.</p>
    <p class="line_zh">所以今天早上，当收银员不得不给我40美分时，她很可能使用了以下算法。</p>
    <p class="">First, finding the largest coin denomination that is smaller than 40 cents.</p>
    <p class="line_zh">首先，找到小于40美分的最大硬币面额。</p>
    <p class="">It will be 25 cents.</p>
    <p class="line_zh">这将是25美分。</p>
    <p class="">So she gave me 25, 15 cents left and then the next challenge is how to change 15 cents.</p>
    <p class="line_zh">所以她给了我25,15美分，接下来的挑战是如何改变15美分。</p>
    <p class="">The next step is she probably found the largest coin smaller than 15 cents, it is 10 cents.</p>
    <p class="line_zh">下一步是她可能发现小于15美分的最大硬币，它是10美分。</p>
    <p class="">She gave me 10 cents, and finally, she returned 5 cents.</p>
    <p class="line_zh">她给了我10美分，最后，她还给了我5美分。</p>
    <p class="">As a result, she changed 40 cents as 25 plus 10 plus 5.</p>
    <p class="line_zh">结果，她改变了40美分，25加10加5。</p>
    <p class="">Do you think it's the minimum number of coins she could possibly return? It is the minimal number of coins in the United
        States.
    </p>
    <p class="line_zh">你认为这是她可能返回的最小硬币数量吗？这是美国最小的硬币数量。</p>
    <p class="">But if you travel to Tanzania, it won't be the minimum number of coins because there is a 20 cent coin in Tanzania.</p>
    <p class="line_zh">但如果你前往坦桑尼亚，它将不是最低数量的硬币，因为在坦桑尼亚有一个20美分硬币。</p>
    <p class="">And therefore this greedy approach to solving the change problem will fail in Tanzania because there is a better way
        to change 40 cents, simply as 20 cents plus 20 cents, using Tanzanian 20 cents coin.</p>
    <p class="line_zh">因此，这种解决变革问题的贪婪方法将在坦桑尼亚失败，因为使用坦桑尼亚20美分硬币有更好的方法可以改变40美分，简单地换20美分加20美分。</p>
    <p class="">Since the greedy approach to solving the change problem failed, let's try something different.</p>
    <p class="line_zh">由于解决变更问题的贪婪方法失败了，让我们尝试不同的东西。</p>
    <p class="">Let's try the recursive algorithm for solving the same problem.</p>
    <p class="line_zh">让我们尝试使用递归算法来解决同样的问题。</p>
    <p class="">Suppose we want to change 9 cents, and our denominations are 1 cent, 5 cents, and 6 cents.</p>
    <p class="line_zh">假设我们想要改变9美分，我们的面额是1美分，5美分和6美分。</p>
    <p class="">What would be the optimal way to change 9 cents? Well, if we only knew what is the optimal ways to change 9 minus 6 cents,
        9 minus 5 cents and 9 minus 1 cents, then we would know, what is the optimal way to change 9 cents? In other words,
        to change 9 cents, we need to know how to change small number of cents, in our case, 3 cents, 4 cents, and 8 cents.</p>
    <p class="line_zh">改变9美分的最佳方式是什么？好吧，如果我们只知道改变9减6美分，9减5美分和9减1美分的最佳方法是什么，那么我们就知道，改变9美分的最佳方法是什么？换句话说，要改变9美分，我们需要知道如何改变少量美分，在我们的例子中，3美分，4美分和8美分。</p>
    <p class="">And therefore, an approach to solving this problem would be to use this recurrence to write the recursive program.</p>
    <p class="line_zh">因此，解决此问题的方法是使用此重复来编写递归程序。</p>
    <p class="">This idea is implemented in the program RecursiveChange.</p>
    <p class="line_zh">这个想法在程序RecursiveChange中实现。</p>
    <p class="">To change money, cents using coins, coin1, coin2, coind, we do the following.</p>
    <p class="line_zh">要使用硬币，coin1，coin2，coind来换钱，我们会做以下事情。</p>
    <p class="">We first recursively call RecursiveChange with the amount of money, money minus coin1, money minus coin2, and money minus
        coind.
    </p>
    <p class="line_zh">我们首先递归调用RecursiveChange的金额，金钱减去coin1，金钱减去coin2，金钱减去coind。</p>
    <p class="">And find the minimum amount of money for these d choices.</p>
    <p class="line_zh">并找到这些d选择的最低金额。</p>
    <p class="">We have plus 1 because there is one more coin to add and returns this way.</p>
    <p class="line_zh">我们加1，因为还有一个硬币可以添加并以这种方式返回。</p>
    <p class="">This looks like the right approach to solve the problem, but let's check how fast the resulting program is.</p>
    <p class="line_zh">这看起来是解决问题的正确方法，但让我们检查生成的程序的速度。</p>
    <p class="">So, when we're changing 76 coins, there are actually three choices.</p>
    <p class="line_zh">所以，当我们改变76个硬币时，实际上有三种选择。</p>
    <p class="">We need to recursively call RecursiveChange for 70 cents, 71 cents, and 75 cents.</p>
    <p class="line_zh">我们需要递归调用RecursiveChange 70美分，71美分和75美分。</p>
    <p class="">But for each of these values, we need once again to call three choices.</p>
    <p class="line_zh">但是对于这些价值中的每一个，我们都需要再次称之为三个选择。</p>
    <p class="">And we will continue growing this tree and very quickly it will turn into a gigantic tree.</p>
    <p class="line_zh">我们将继续种植这棵树，很快就会变成一棵巨大的树。</p>
    <p class="">Let's check how many times we have already tried to change 70 cents.</p>
    <p class="line_zh">让我们来看看我们已经尝试过多少次改变70美分。</p>
    <p class="">Three times, and we only started expanding this tree.</p>
    <p class="line_zh">三次，我们才开始扩展这棵树。</p>
    <p class="">In fact, if we continue further, we will see that there were six times when we needed to compute RecursiveChange for
        70.
    </p>
    <p class="line_zh">事实上，如果我们继续进一步，我们将看到有六次我们需要计算RecursiveChange为70。</p>
    <p class="">How many times do you think we will need to run recursive calls when we compute the minimal number of coins for 30 cents?
        It turn out that we will need to call it trillions of times, which means that our seemingly very elegant RecursiveChange
        program will not finish before the end of your lifetime.</p>
    <p class="line_zh">当我们计算30美分的最小硬币数量时，您认为我们需要多少次才能运行递归调用？事实证明，我们需要将它称之为数万亿次，这意味着我们看似非常优雅的RecursiveChange程序将无法在您的生命周期结束之前完成。</p>
    <p class="">So as simple as the change problem looks like, neither a greedy approach nor a recursive approach solve it in a reasonable
        time.
    </p>
    <p class="line_zh">因此，就像变化问题一样简单，贪婪方法和递归方法都不能在合理的时间内解决。</p>
    <p class="">60 years ago, a brilliant mathematician, Richard Bellman, had a different idea.</p>
    <p class="line_zh">60年前，一位才华横溢的数学家理查德贝尔曼有一个不同的想法。</p>
    <p class="">Wouldn't it be nice to know all the answers for changing money minus coin i by the time we need to compute an optimal
        way of changing money? And instead of the time consuming calls to RecursiveChange, money minus coin i, that may require
        to be repeated trillions of times, they would simply look up these values.</p>
    <p class="line_zh">在我们需要计算最佳换钱方式的时候，知道改变货币减去硬币的所有答案不是很好吗？而不是耗时调用RecursiveChange，钱减去硬币i，可能需要重复数万亿次，他们只会查找这些值。</p>
    <p class="">This idea resulted in dynamic programming approach that is applied in thousands of diverse, practical applications in
        a myriad of different fields.</p>
    <p class="line_zh">这一想法产生了动态编程方法，该方法应用于无数不同领域的数千种不同的实际应用中。</p>
    <p class="">And the key idea of dynamic programming is to start filling this matrix, not from the right to the left, as we did before
        in the recursive change, but instead, from the left to the right.</p>
    <p class="line_zh">动态编程的关键思想是开始填充这个矩阵，而不是从右到左，就像我们之前在递归变化中所做的那样，而是从左到右。</p>
    <p class="">So, we will first ask the trivial question, what is the minimum number of coins needed to change 0 cents? And, of course,
        it is 0.</p>
    <p class="line_zh">那么，我们首先会问一个微不足道的问题，改变0美分所需的最小硬币数量是多少？当然，它是0。</p>
    <p class="">What is the minimum number of coins to change 1 cents? Obviously it is one, but we can compute this number by finding
        what is the minimum number of coins to change 0 cents and adding one coin.</p>
    <p class="line_zh">改变1美分的最小硬币数量是多少？显然它是一个，但我们可以通过找出改变0美分和增加一枚硬币的最小硬币数来计算这个数字。</p>
    <p class="">We will proceed in a similar fashion to compute the minimum number of coins to change 2 cents, 3 cents, and 4 cents.</p>
    <p class="line_zh">我们将以类似的方式计算最小硬币数量，分别为2美分，3美分和4美分。</p>
    <p class="">There is only one possibility to derive this number from the previous number.</p>
    <p class="line_zh">从前一个数字中推导出这个数字只有一种可能性。</p>
    <p class="">And for 5 cents, actually there are two possibilities, green and blue.</p>
    <p class="line_zh">而对于5美分，实际上有两种可能性，绿色和蓝色。</p>
    <p class="">For green one, you can derive it from 0 cents by adding 5 coins, and for blue possibility, we can derive it from 4 cents
        by adding one penny.</p>
    <p class="line_zh">对于绿色，您可以通过添加5个硬币从0美分得出它，而对于蓝色可能性，我们可以通过添加一美分从4美分得出它。</p>
    <p class="">Well, which possibility would you select? Of course the one that gives you the minimum change for 5 coins.</p>
    <p class="line_zh">那么，你会选择哪种可能性？当然是给你5个硬币最小变化的那个。</p>
    <p class="">And continue further and apply the code to 6 cents and there are three possibilities and once again we select the optimal
        choice that correspond to minimum number of coins.</p>
    <p class="line_zh">并继续进一步并将代码应用于6美分，有三种可能性，我们再次选择对应于最小硬币数量的最佳选择。</p>
    <p class="">Let's say it may be 0 coins plus 6 cents.</p>
    <p class="line_zh">假设它可能是0硬币加6美分。</p>
    <p class="">We continue for 7 cents, continue for 8 cents, and finally, very quickly, we actually found the correct answer for 9
        cents.
    </p>
    <p class="line_zh">我们继续7美分，继续8美分，最后，很快，我们实际上找到了9美分的正确答案。</p>
    <p class="">We need four coins to change 9 cents.</p>
    <p class="line_zh">我们需要四个硬币才能改变9美分。</p>
    <p class="">And this results in DPChange algorithm that simply fills up the table that I just showed you from left to right.</p>
    <p class="line_zh">这导致DPChange算法简单地填满了我从左到右显示的表格。</p>
    <p class="">DP change is the first dynamic programming algorithm that you saw in this course, and there will be thousands more.</p>
    <p class="line_zh">DP更改是您在本课程中看到的第一个动态编程算法，还有数千个。</p>
    <p class="">You may be wondering why is this algorithm called dynamic programming and what does it have to do with programming? Well,
        in fact programming and dynamic programming has nothing to do with programming.</p>
    <p class="line_zh">您可能想知道为什么这个算法称为动态编程，它与编程有什么关系？实际上，编程和动态编程与编程无关。</p>
    <p class="">Amazingly enough, dynamic programming is one of the most practical algorithms computer scientists use.</p>
    <p class="line_zh">令人惊讶的是，动态编程是计算机科学家使用的最实用的算法之一。</p>
    <p class="">But when Richard Bellman was developing this idea for Air Force project he was working on, it looked completely impractical.</p>
    <p class="line_zh">但是当理查德·贝尔曼（Richard Bellman）为他正在研究的空军项目开发这个想法时，它看起来完全不切实际。</p>
    <p class="">And he wanted to hide that he's really doing mathematics from the Secretary of Defense, rather than working on Air Force
        project.
    </p>
    <p class="line_zh">他想隐瞒自己从国防部长那里做数学，而不是从事空军项目。</p>
    <p class="">Therefore he invented a name that basically has nothing to do with what dynamic programming algorithms do.</p>
    <p class="line_zh">因此，他发明了一个基本上与动态编程算法无关的名称。</p>
    <p class="">In his own word, he said, what name could I choose? I was interested in planning but planning is not a good word for
        various reasons.</p>
    <p class="line_zh">他说，用他自己的话说，我可以选择什么名字？我对计划很感兴趣，但由于各种原因，计划并不是一个好词。</p>
    <p class="">I decided therefore to use the word programming, and I wanted to get across the idea that this was dynamic.</p>
    <p class="line_zh">因此我决定使用编程这个词，我想要了解这是动态的想法。</p>
    <p class="">It was something not even a Congressman could object.</p>
    <p class="line_zh">这甚至不是国会议员可以反对的。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 50 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_50">第01章 the alignment game
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01对齐游戏</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Cystic Fibrosis is one of the most common genetic diseases in humans.</p>
    <p class="line_zh">囊性纤维化是人类最常见的遗传性疾病之一。</p>
    <p class="">Approximately one in 25 people carries a cystic fibrosis gene.</p>
    <p class="line_zh">大约每25人中就有一人携带囊性纤维化基因。</p>
    <p class="">And when both parents carry a faulty gene, there is a 25% chance that their child will have cystic fibrosis.</p>
    <p class="line_zh">当父母双方携带有缺陷的基因时，他们的孩子有25％的可能患有囊性纤维化。</p>
    <p class="">In the early 1980s biologists started the hunt for cystic fibrosis genes, one of the first gene hunting projects in the
        framework of the human genome project.</p>
    <p class="line_zh">在20世纪80年代早期，生物学家开始寻找囊性纤维化基因，这是人类基因组计划框架中最早的基因狩猎项目之一。</p>
    <p class="">30 years ago biologists narrowed the search for the cystic fibrosis gene to a million nucleotide-long region on chromosome
        7.
    </p>
    <p class="line_zh">30年前，生物学家将对囊性纤维化基因的研究范围缩小到7号染色体上长达100万个核苷酸的区域。</p>
    <p class="">However, this region contained many genes, and it was not clear which of them is responsible for cystic fibrosis.</p>
    <p class="line_zh">然而，该区域含有许多基因，并且尚不清楚它们中的哪一个是囊性纤维化的原因。</p>
    <p class="">How would you find which of these genes is the cause of cystic fibrosis? I'll give you a hint.</p>
    <p class="line_zh">您如何找到这些基因中的哪一个是囊性纤维化的原因？我会给你一个提示。</p>
    <p class="">Cystic fibrosis in involves sweat secretion with abnormally high sodium levels.</p>
    <p class="line_zh">囊性纤维化涉及汗液分泌，具有异常高的钠水平。</p>
    <p class="">Well, this is a biological hint that does not help us to solve the challenge of finding something in this one million
        nucleotide area that is responsible for cystic fibrosis.</p>
    <p class="line_zh">嗯，这是一种生物学暗示，无法帮助我们解决在这一百万个核苷酸区域中寻找导致囊性纤维化的问题的挑战。</p>
    <p class="">Let me give you hint number two.</p>
    <p class="line_zh">让我给你第二个提示。</p>
    <p class="">By that time when cystic fibrosis hunt was on, biologists already knew the sequences of some genes responsible for secretions.</p>
    <p class="line_zh">到那时，当囊性纤维化狩猎开始时，生物学家已经知道一些负责分泌物的基因的序列。</p>
    <p class="">For example, ATP binding proteins act as transport channels responsible for secretion.</p>
    <p class="line_zh">例如，ATP结合蛋白充当负责分泌的转运通道。</p>
    <p class="">You still may be wondering how these two hints may help you to find the cystic fibrosis gene in the found one million
        nucleotide-long region on chromosome 7.</p>
    <p class="line_zh">您仍然可能想知道这两个提示如何帮助您在7号染色体上找到的100万个核苷酸长区域中找到囊性纤维化基因。</p>
    <p class="">But here's my third hint.</p>
    <p class="line_zh">但这是我的第三个提示。</p>
    <p class="">Should we search for genes in this region that are similar to known genes responsible for secretion? Biologists used
        this third hint and bingo, they found that one of genes in this region was similar to the ATP binding proteins that
        act as transport channels responsible for secretion.</p>
    <p class="line_zh">我们应该在这个区域寻找与已知的分泌基因相似的基因吗？生物学家使用这第三个暗示和宾果游戏，他们发现该区域的一个基因与作为负责分泌的运输通道的ATP结合蛋白相似。</p>
    <p class="">To learn how biologists find similarities between chance, we will first learn how to play a simple game called the alignment
        game.
    </p>
    <p class="line_zh">要了解生物学家如何找到机会之间的相似之处，我们将首先学习如何玩一种称为对齐游戏的简单游戏。</p>
    <p class="">The alignment game is a single person game.</p>
    <p class="line_zh">对齐游戏是单人游戏。</p>
    <p class="">I give you two strings, and your goal is to remove symbol from the strings in such a way that the number of points is
        maximized.
    </p>
    <p class="line_zh">我给你两个字符串，你的目标是从字符串中删除符号，使得点数最大化。</p>
    <p class="">I have to explain to you how you can get points for playing the alignment game.</p>
    <p class="line_zh">我必须向你解释如何获得玩对齐游戏的积分。</p>
    <p class="">You can either remove the first symbol from both strings.</p>
    <p class="line_zh">您可以从两个字符串中删除第一个符号。</p>
    <p class="">And in this case, you get one point if they're the same symbol, you don't get any points if they are different symbol.</p>
    <p class="line_zh">在这种情况下，如果它们是相同的符号，则得到一个点，如果它们是不同的符号，则不会获得任何积分。</p>
    <p class="">Or you can remove first symbol from one of the strings and in this case you also don't get any points.</p>
    <p class="line_zh">或者您可以从其中一个字符串中删除第一个符号，在这种情况下，您也不会获得任何积分。</p>
    <p class="">So let's try to play this game.</p>
    <p class="line_zh">所以让我们尝试玩这个游戏。</p>
    <p class="">In the beginning it makes sense to remove the first symbol from both strings, we'll get plus one.</p>
    <p class="line_zh">在开始时，从两个字符串中删除第一个符号是有意义的，我们将得到加号。</p>
    <p class="">Then another pair of identical symbols, another plus one.</p>
    <p class="line_zh">然后另一对相同的符号，另一个加一。</p>
    <p class="">And now symbols are different so it doesn't make sense to remove them both because we'll get zero point.</p>
    <p class="line_zh">现在符号是不同的，所以删除它们都没有意义，因为我们将获得零点。</p>
    <p class="">Maybe we should only remove C from the second string and after we've done this there is a possibility to remove two Gs
        from both string.</p>
    <p class="line_zh">也许我们只应该从第二个字符串中删除C，在我们完成此操作之后，有可能从两个字符串中删除两个Gs。</p>
    <p class="">We get another point we continue, continue, continue, and finally after playing this game we get score of plus four.</p>
    <p class="line_zh">我们得到另一个点，我们继续，继续，继续，最后在玩这个游戏之后我们得到加4的分数。</p>
    <p class="">Do you think you can get score of plus five playing this game? We also after playing this game have constructed something
        that is called alignment of two strings.</p>
    <p class="line_zh">你认为你可以在这场比赛中得到加五分吗？我们在玩这个游戏之后也构建了一些叫做两个字符串对齐的东西。</p>
    <p class="">Alignment of two strings is a two row matrix such that, that first row consist of symbols of the first string in order,
        possibly interspaced with the space symbol.</p>
    <p class="line_zh">两个串的对齐是两行矩阵，使得第一行按顺序由第一串的符号组成，可能与空间符号间隔开。</p>
    <p class="">And the second row consists of the symbols of the second string once again, possibly interspersed with the space symbol.</p>
    <p class="line_zh">第二行再次由第二个字符串的符号组成，可能散布着空格符号。</p>
    <p class="">After we constructed the alignment, we can classify different columns in the alignment matrix as matches or mismatches
        or insertions.</p>
    <p class="line_zh">在我们构造对齐之后，我们可以将对齐矩阵中的不同列分类为匹配或不匹配或插入。</p>
    <p class="">Insertions corresponds to the case when we selected the symbol from the second string and deletions that correspond to
        the case when we selected the symbol from the first string.</p>
    <p class="line_zh">插入对应于我们从第二个字符串中选择符号的情况以及与从第一个字符串中选择符号时的情况相对应的删除。</p>
    <p class="">And more over we can score this alignment by giving premium for every match, we'll give premium plus one and penalty
        for every mismatch and every insertion and deletion that we denote as indel.</p>
    <p class="line_zh">而且我们可以通过为每场比赛提供溢价来获得这种对齐，我们将为每个不匹配以及我们表示为插入的每个插入和删除提供高级加1和罚分。</p>
    <p class="">In our case we will use penalty minus mu for mismatches and penalty minus sigma for insertions and deletions or indels.</p>
    <p class="line_zh">在我们的例子中，我们将使用惩罚减去mu用于错配和惩罚减去sigma用于插入和删除或indel。</p>
    <p class="">For example in our case if mu equals zero and sigma equal to one, then we get alignment score equal to one.</p>
    <p class="line_zh">例如，在我们的情况下，如果mu等于零且sigma等于1，那么我们将对齐得分等于1。</p>
    <p class="">So we define the alignment score as number of matches minus mu number of mismatches and minus sigma number of indels.</p>
    <p class="line_zh">因此，我们将对齐分数定义为匹配数减去不匹配的mu数和减去indels的sigma数。</p>
    <p class="">And the optimal alignment problem is given two strings mismatch penalty mu, and indel penalty sigma find an alignment
        of two strings maximizing the score.</p>
    <p class="line_zh">并且最优对齐问题给出了两个字符串不匹配惩罚mu，而indel惩罚sigma找到两个字符串的对齐最大化得分。</p>
    <p class="">We will be particularly interested in one particular score of alignment.</p>
    <p class="line_zh">我们将特别感兴趣的是一个特定的对齐得分。</p>
    <p class="">We will define common subsequence as simply matches in an alignment of two strands.</p>
    <p class="line_zh">我们将公共子序列定义为两条线对齐的简单匹配。</p>
    <p class="">In this case, common subsequence is represented by ATGT, and the longest common subsequence problems that we will be
        interested in is the following.</p>
    <p class="line_zh">在这种情况下，公共子序列由ATGT表示，我们将感兴趣的最长的常见子序列问题如下。</p>
    <p class="">Given two strings we want to find the longest common subsequence of these strings.</p>
    <p class="line_zh">给定两个字符串，我们希望找到这些字符串的最长公共子序列。</p>
    <p class="">And of course, you have already recognized that to find longest common subsequence we simply need to find maximum score
        alignment with the parameters mu equals zero and sigma equals zero.</p>
    <p class="line_zh">当然，你已经认识到要找到最长的共同子序列，我们只需要找到最大分数对齐，参数mu等于零，sigma等于零。</p>
    <p class="">Another classical problem in computer science is the edit distance problem.</p>
    <p class="line_zh">计算机科学中的另一个经典问题是编辑距离问题。</p>
    <p class="">Given two strings, find the minimum number of elementary operations, insertions, deletions, or substitutions of symbols.</p>
    <p class="line_zh">给定两个字符串，找到符号的基本操作，插入，删除或替换的最小数量。</p>
    <p class="">That transform one string into another.</p>
    <p class="">这会将一个字符串转换为另一个</p>
    <p class="">And of course the minimum number of insertions, deletions, and mismatches in an alignment of two strings, represents
        the edit distance.</p>
    <p class="line_zh">当然，两个字符串对齐中的最小插入，删除和不匹配数表示编辑距离。</p>
    <p class="">For example, if you want to find the editing distance between the strings, editing and distance, they can construct optimal
        alignment of the string with appropriate scores.</p>
    <p class="line_zh">例如，如果要查找字符串，编辑和距离之间的编辑距离，可以使用适当的分数构建字符串的最佳对齐方式。</p>
    <p class="">Here I show matches, mismatches,insertions, deletions.</p>
    <p class="line_zh">在这里，我显示匹配，不匹配，插入，删除。</p>
    <p class="">And to see that the edit distance problem is equivalent to the alignment problem let's consider this alignment between
        editing and distance.</p>
    <p class="line_zh">要看到编辑距离问题等同于对齐问题，让我们考虑编辑和距离之间的这种对齐。</p>
    <p class="">And let's compute the total number of symbols in the two strings.</p>
    <p class="line_zh">让我们计算两个字符串中的符号总数。</p>
    <p class="">Obviously the total number of symbol in two strings is equal to twice number of matches, plus twice number of mismatches
        plus number of insertions plus number of deletions.</p>
    <p class="line_zh">显然，两个字符串中的符号总数等于两次匹配次数，加上两次错配次数加上插入次数加上删除次数。</p>
    <p class="">I will take the liberty to derive this expression and after I rewrote it you will see that the first three terms corresponds
        to the alignment score, and the last three terms corresponds to the edit distance.</p>
    <p class="line_zh">我将冒昧地推导出这个表达式，在我重写之后你会发现前三个术语对应于对齐分数，后三个术语对应于编辑距离。</p>
    <p class="">Therefore, minimizing edit distance is the same as maximizing the alignment score.</p>
    <p class="line_zh">因此，最小化编辑距离与最大化对齐分数相同。</p>
    <p class="">Which means the edit distance problem is just one particular version of the alignment problem.</p>
    <p class="line_zh">这意味着编辑距离问题只是对齐问题的一个特定版本。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 51 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_51">第02章 computing edit distance
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02计算编辑距离</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Let's now see how dynamic programming algorithm solves the edit distance problem.</p>
    <p class="line_zh">现在让我们看看动态编程算法如何解决编辑距离问题。</p>
    <p class="">We start by considering two strings, A of length n and B of length m and we will ask the question question what is an
        optimal alignment of an i-prefix of A, which is the first i symbols of A, and the j-prefix of B which are the first
        j symbols only.</p>
    <p class="line_zh">我们首先考虑两个字符串，长度为n的A和长度为m的B，我们将问问题是什么是A的i前缀的最佳对齐，这是A的前i符号和j前缀B只是前j个符号。</p>
    <p class="">The last column of an optimal alignment is either an insertion or a deletion or a mismatch, or a match.</p>
    <p class="line_zh">最佳比对的最后一列是插入或删除或不匹配，或匹配。</p>
    <p class="">And please notice that if we remove the last column from the optimal alignment of the strings, what is left is an optimal
        alignment of the corresponding two prefixes.</p>
    <p class="line_zh">请注意，如果我们从字符串的最佳对齐中删除最后一列，剩下的就是相应两个前缀的最佳对齐方式。</p>
    <p class="">And we can adjust the score of the optimal alignment for i prefix and j prefix by adding plus 1 in the case of insertion,
        plus 1 in the case of deletion, plus 1 in the case of mismatch and adding nothing in the case of match.</p>
    <p class="line_zh">我们可以通过在插入的情况下加1来调整i前缀和j前缀的最佳对齐的分数，在删除的情况下加1，在不匹配的情况下加1，在匹配的情况下不添加任何内容。</p>
    <p class="">Let's denote D (i, j) to be the edit distance between an i-prefix and a j-prefix.</p>
    <p class="line_zh">让我们将D（i，j）表示为i前缀和j前缀之间的编辑距离。</p>
    <p class="">And in this case, this figure at the top of the slide illustrates the following recurrency.</p>
    <p class="line_zh">在这种情况下，幻灯片顶部的这个数字说明了以下的重复性。</p>
    <p class="">D(i,j) equal to the minimum of the following four values: D(i,j-1)+1, D(i-1,j)+1, D(i-1,j-1)+1, in the case the last
        two symbols in the i prefix of A and j prefix of B are different.</p>
    <p class="line_zh">D（i，j）等于以下四个值的最小值：D（i，j-1）+ 1，D（i-1，j）+ 1，D（i-1，j-1）+1 ，在A的前缀和前缀为B的前缀中的最后两个符号不同的情况下。</p>
    <p class="">And D(i- 1, j- 1), if the last symbols in i and j prefix are the same.</p>
    <p class="line_zh">并且D（i-1，j-1），如果i和j前缀中的最后一个符号相同。</p>
    <p class="">Our goal now is to compute the edit distance D, i, j between all i prefixes of string A and all j prefixes of string
        B.
    </p>
    <p class="line_zh">我们现在的目标是计算字符串A的所有i前缀和字符串B的所有j前缀之间的编辑距离D，i，j。</p>
    <p class="">In the case of string editing and distance we will construct eight by nine grid and our goal is to compute all edit distances
        D(i, j) corresponding to all nodes in this grid.</p>
    <p class="line_zh">在字符串编辑和距离的情况下，我们将构建8乘9的网格，并且我们的目标是计算与该网格中的所有节点相对应的所有编辑距离D（i，j）。</p>
    <p class="">For example, for i and j equal to four and four.</p>
    <p class="line_zh">例如，对于i和j等于四和四。</p>
    <p class="">How will we compute the corresponding distance D(i, j)? Let's start by filling distances D(i, 0) in the first column
        of this matrix.</p>
    <p class="line_zh">我们如何计算相应的距离D（i，j）？让我们从填充该矩阵的第一列中的距离D（i，0）开始。</p>
    <p class="">It is easy because indeed we are comparing an i-prefix of string A against a 0-prefix of string D and therefore this
        edit distance for i-prefix will be equal to i.</p>
    <p class="line_zh">这很简单，因为我们确实将字符串A的i前缀与字符串D的0前缀进行比较，因此i-prefix的编辑距离将等于i。</p>
    <p class="">That's what's shown here, similarly we can easily fill the first row in this matrix.</p>
    <p class="line_zh">这就是这里显示的内容，类似地，我们可以轻松填充此矩阵中的第一行。</p>
    <p class="">And now let's try to compute what will be the distance D(1,1) corresponding to comparison of string consisting of single
        symbol E, with a string consisting of single symbol D, there are three possible ways to arrive to the node (1, 1):
        from the nodes (0, 0), (0, 1), and (1, 0).</p>
    <p class="line_zh">现在让我们尝试计算与单个符号E组成的字符串的比较相对应的距离D（1,1），以及由单个符号D组成的字符串，有三种可能的方式到达节点（1， 1）：来自节点（0,0），（0,1）和（1,0）。</p>
    <p class="">Which one should be the way we will select to find the optimal edit distance.</p>
    <p class="line_zh">哪一个应该是我们选择找到最佳编辑距离的方式。</p>
    <p class="">According to the previous recurrency, we should select the one of three directions that gives minimal value for D(i,
        j), which is minimum of 2, 2, and 1 and therefore we arrive to node (1, 1) by diagonal edge.</p>
    <p class="line_zh">根据之前的重复性，我们应该选择三个方向中的一个给出D（i，j）的最小值，其中最小值为2,2和1，因此我们通过对角线边缘到达节点（1,1） 。</p>
    <p class="">Let's keep this in memory that the right direction to arrive at node (1, 1) was the diagonal direction.</p>
    <p class="line_zh">让我们在记忆中保持这一点，即到达节点（1,1）的正确方向是对角线方向。</p>
    <p class="">We will now try to compute the edit distance for the next node in the matrix.</p>
    <p class="line_zh">我们现在将尝试计算矩阵中下一个节点的编辑距离。</p>
    <p class="">And in this case D(2,1) is equal to minimum D(2,0) + 1, D(1,1) + 1 and D(1,0) of each tells us that's the optimal way
        to arrive to this node would be again, by diagonal edge.</p>
    <p class="line_zh">在这种情况下，D（2,1）等于最小D（2,0）+ 1，D（1,1）+ 1和D（1,0）每个告诉我们这是到达这个的最佳方式通过对角线边缘，节点将再次出现。</p>
    <p class="">You continue further, once again compare three values and it turn out that the best way to arrive to this node will be
        by vertical edge.</p>
    <p class="line_zh">您继续进一步，再次比较三个值，结果表明到达此节点的最佳方式是垂直边缘。</p>
    <p class="">We'll continue further and we'll fill the whole second column in the matrix.</p>
    <p class="line_zh">我们将继续进一步，我们将填充矩阵中的第二列。</p>
    <p class="">Now let's continue with the circle, what about this node? For this node D(1,2) = minimum {D(1,1) + 1, D (0,2) + 1, and
        D (0,1) + 1}.</p>
    <p class="line_zh">现在让我们继续讨论这个节点吧？对于该节点D（1,2）=最小{D（1,1）+ 1，D（0,2）+ 1和D（0,1）+ 1}。</p>
    <p class="">And it is minimum of 2, 3, and 2.</p>
    <p class="line_zh">它至少为2,3和2。</p>
    <p class="">In fact, there are two optimal ways to arrive to this node and in this case we show both of them by diagonal edge into
        this vertex and by horizontal edge of this vertex.</p>
    <p class="line_zh">实际上，到达此节点有两种最佳方式，在这种情况下，我们通过对角线边缘到这个顶点以及该顶点的水平边缘显示它们。</p>
    <p class="">You'll continue further and slowly but surely we will fill the whole matrix.</p>
    <p class="line_zh">你会继续慢慢地继续，但我们肯定会填满整个矩阵。</p>
    <p class="">The edit distance pseudocode implements the algorithm we just discussed.</p>
    <p class="line_zh">编辑距离伪代码实现了我们刚才讨论的算法。</p>
    <p class="">It first fills in the first column and the first row of the dynamic programming matrix and then it continues filling
        it up by computing the cost of moving to vertex (i, j) using insertion, deletion, or mismatch or match or in other
        words, exploring all possibility.</p>
    <p class="line_zh">它首先填充动态编程矩阵的第一列和第一行，然后通过计算使用插入，删除或不匹配或匹配移动到顶点（i，j）的成本来继续填充它，换句话说，探索所有可能性。</p>
    <p class="">Moving to the vertex i, j using vertical edge, horizontal edge, and diagonal edge.</p>
    <p class="line_zh">使用垂直边缘，水平边缘和对角线边缘移动到顶点i，j。</p>
    <p class="">And then it finds out which of these possibilities results in the minimum edit distance.</p>
    <p class="line_zh">然后它找出哪些可能性导致最小编辑距离。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 52 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_52">第03章 reconstructing an optimal alignment
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">03重建最佳对齐</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">We now know how to compute the edit distance or to compute the optimal alignment by filling in the entries in the dynamic
        programming matrix.</p>
    <p class="line_zh">我们现在知道如何通过填充动态编程矩阵中的条目来计算编辑距离或计算最佳对齐。</p>
    <p class="">But it doesn't tell us yet how to construct the alignment two rows with the first row representing the first sequence
        and the second row representing the second sequence.</p>
    <p class="line_zh">但它还没有告诉我们如何构造对齐两行，第一行代表第一个序列，第二行代表第二个序列。</p>
    <p class="">Here's an idea.</p>
    <p class="line_zh">这是一个想法。</p>
    <p class="">Let's use the backtracking pointers that we constructed while filling in the dynamic programming matrix to reconstruct
        optimal alignment between strings.</p>
    <p class="line_zh">让我们使用我们在填充动态编程矩阵时构建的回溯指针来重建字符串之间的最佳对齐。</p>
    <p class="">We can start by noting that any path from (0, 0) to (i, j) in the dynamic programming matrix spell an alignment of an
        i prefix of A with a j prefix of B.</p>
    <p class="line_zh">我们可以从注意到动态编程矩阵中从（0,0）到（i，j）的任何路径拼写出一个i的前缀与a前缀B的对齐。</p>
    <p class="">For example let's start the line in the sequences, which means let's start traveling from the point 0, 0 to the point
        n, m in our dynamic programming matrix.</p>
    <p class="line_zh">例如，让我们在序列中开始行，这意味着让我们开始从动态编程矩阵中的点0,0到点n，m行进。</p>
    <p class="">As soon as we move along diagonal left it will correspond to either mismatch or match, then we'll continue using horizontal
        or vertical edges and it will correspond to insertions or deletions.</p>
    <p class="line_zh">一旦我们沿对角线向左移动它将对应于不匹配或匹配，然后我们将继续使用水平或垂直边缘，它将对应于插入或删除。</p>
    <p class="">Then we will use once again diagonal edge.</p>
    <p class="line_zh">然后我们将再次使用对角线边缘。</p>
    <p class="">In this case it is a match, and you'll continue by constructing the n-alignment of two strings.</p>
    <p class="line_zh">在这种情况下，它是匹配，您将继续构造两个字符串的n对齐。</p>
    <p class="">Please note that the constructed path corresponds to distance A and is not an optimal alignment because we know that
        an optimal alignment distance is 5.</p>
    <p class="line_zh">请注意，构造的路径对应于距离A并且不是最佳对齐，因为我们知道最佳对齐距离是5。</p>
    <p class="">To construct an optimal alignment we will use the backtracking pointers by starting from the last vertex in this matrix
        particularly from this vertex where the added distance is recorded as 5.</p>
    <p class="line_zh">为了构造最佳对齐，我们将使用回溯指针，从该矩阵中的最后一个顶点开始，特别是从该顶点开始，其中添加的距离记录为5。</p>
    <p class="">Using backtracking pointers we see that there are two possible ways to arrive to this last vertex.</p>
    <p class="line_zh">使用回溯指针，我们看到有两种可能的方法到达最后一个顶点。</p>
    <p class="">Let's arbitrarily choose one of them.</p>
    <p class="line_zh">让我们任意选择其中一个。</p>
    <p class="">One of them corresponds to a mismatch and another corresponds to insertion.</p>
    <p class="line_zh">其中一个对应于不匹配，另一个对应于插入。</p>
    <p class="">So let's arbitrarily choose a mismatch edge that will correspond to mismatch between j and i, then from the previous
        point there is only one way to move into this point and it will correspond to an indel that will continue further,
        match, further, further, further, further, and we will finally arrive to the initial point at the same time constructing
        the optimal alignment between two strings.</p>
    <p class="line_zh">因此，让我们随意选择一个与j和i不匹配的不匹配边缘，然后从前一点开始，只有一种方法可以进入这一点，并且它将对应一个将继续进一步继续的插入，进一步，进一步，此外，我们将最终到达初始点，同时构建两个字符串之间的最佳对齐。</p>
    <p class="">The output alignment pseudoode implement's this idea.</p>
    <p class="line_zh">输出对齐伪代码实现了这个想法。</p>
    <p class="">We simply look at the backtracking pointers that enters in the node (i, j).</p>
    <p class="line_zh">我们只看一下进入节点（i，j）的回溯指针。</p>
    <p class="">If they arrive to node (i, j) by using a vertical edge that we will simply output one column of the alignment with a
        of i in the first row.</p>
    <p class="line_zh">如果它们通过使用垂直边缘到达节点（i，j），我们将简单地输出第一行中的一个对齐的一列。</p>
    <p class="">If on the other hand it corresponds to horizontal edge we output column with b of j in the second row, and if it corresponds
        to a diagonal edge we output a column of alignment with a of i in the first row and v of j in the second row.</p>
    <p class="line_zh">另一方面，如果它对应于水平边缘，我们在第二行输出b为b的j，如果它对应于对角线边缘，则输出一列对齐，第一行为i，j为j第二排。</p>
    <p class="">It appears that we actually need to store all backtracking pointers to output alignment, but this slightly modified pseudocode
        tells you that you can compute backtracking pointers by analyzing entries in the dynamic programming matrix and thus
        saving a little space.</p>
    <p class="line_zh">看起来我们实际上需要将所有回溯指针存储到输出对齐，但是这个稍微修改的伪代码告诉您可以通过分析动态编程矩阵中的条目来计算回溯指针，从而节省一点空间。</p>
    <p class="">Edit distance is just one many applications of string comparisons in various disciplines that range from analyzing internet
        pages to finding similar genes.</p>
    <p class="line_zh">编辑距离只是字符串比较的一个应用，从分析网页到寻找相似基因的各个学科。</p>
    <p class="">We started this lecture from the example of gene hunt for cystic fibrosis: one of the first successes of the human genome
        project.
    </p>
    <p class="line_zh">我们从基因寻找囊性纤维化的例子开始这个讲座：这是人类基因组计划的第一个成功之一。</p>
    <p class="">If you want to learn more about comparing genes, protein, and genomes you may enroll in the Coursera specialization called
        Bioinformatics or you can read the book Bioinformatics Algorithms: the Active Learning Approach.</p>
    <p class="line_zh">如果您想了解有关比较基因，蛋白质和基因组的更多信息，您可以参加名为Bioinformatics的Coursera专业，或者您可以阅读“生物信息学算法：主动学习方法”一书。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 53 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_53">第01章 problem overview
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01问题概述</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hi, today we are going to revisit the Knapsack problem, the problem that we already discussed in the Greedy Algorithms
        module.
    </p>
    <p class="line_zh">嗨，今天我们将重新讨论背包问题，我们已经在Greedy Algorithms模块中讨论过这个问题。</p>
    <p class="">In this very first segment of this lesson, we will recall the definition of this problem, as well as motivate its study
        by providing a few examples of applying this problem in real life.</p>
    <p class="line_zh">在本课程的第一部分中，我们将回顾这个问题的定义，并通过提供一些在现实生活中应用这个问题的例子来激励它的研究。</p>
    <p class="">Our first example is the following.</p>
    <p class="line_zh">我们的第一个例子如下。</p>
    <p class="">Assume that you are given a time slot, say two or three minutes, and together with this time slot, you are given a set
        of TV commercials.</p>
    <p class="line_zh">假设您有一个时间段，例如两三分钟，并且与此时段一起，您将获得一组电视广​​告。</p>
    <p class="">For each commercial, you know its revenue and you know its duration, that is length in minutes, and your goal is to maximize
        the revenue.</p>
    <p class="line_zh">对于每个广告，您知道其收入，并且您知道其持续时间，即以分钟为单位的长度，您的目标是最大化收入。</p>
    <p class="">That is, you would like to select some subset of your available TV commercials, so that the total revenue is as large
        as possible while the total length does not exceed the length of your available time slot.</p>
    <p class="line_zh">也就是说，您希望选择可用电视广告的某些子集，以便总收入尽可能大，而总长度不超过可用时段的长度。</p>
    <p class="">In our second example, you are given a fixed budget and your goal is to purchase a number of computers so that to maximize
        the total performance.</p>
    <p class="line_zh">在我们的第二个示例中，您将获得固定预算，并且您的目标是购买多台计算机，以便最大限度地提高总体性能。</p>
    <p class="">Again, we assume that the part of your input in this case is a set of available computers or machine and for each machine
        you know its price and its performance.</p>
    <p class="line_zh">同样，我们假设在这种情况下输入的部分是一组可用的计算机或机器，并且对于每台机器，您知道它的价格和性能。</p>
    <p class="">Both the considerated problems can be easily seen to be special cases of the following general problem known as the Knapsack
        Problem.
    </p>
    <p class="line_zh">这两个问题都可以很容易地被认为是以下一般问题的特殊情况，称为背包问题。</p>
    <p class="">In this problem, you are given a set of items together with the total capacity of the knapsack.</p>
    <p class="line_zh">在这个问题中，您将获得一组项目以及背包的总容量。</p>
    <p class="">For each item you know its value and its weight.</p>
    <p class="line_zh">对于每个项目，您都知道它的价值和重量。</p>
    <p class="">For example, the value of the green item here is four, while its weight is 12.</p>
    <p class="line_zh">例如，此处绿色项目的值为4，而其权重为12。</p>
    <p class="">And your goal is to select the subset of items such that the total value is as large as possible while the total weight
        is at most, the capacity of the knapsack.</p>
    <p class="line_zh">您的目标是选择项目子集，使总价值尽可能大，而总重量最多为背包的容量。</p>
    <p class="">In our case, the total capacity of the knapsack is equal to 15.</p>
    <p class="line_zh">在我们的例子中，背包的总容量等于15。</p>
    <p class="">There are two versions of the knapsack problem.</p>
    <p class="line_zh">背包问题有两个版本。</p>
    <p class="">Fractional knapsack and discrete knapsack.So, for the fractional version, which you are already familiar with, you can
        take any fraction off of any item, while in the discrete version, for each item, you either take the whole item in
        your knapsack or you do not take it at all.</p>
    <p class="line_zh">分数背包和离散背包。因此，对于您已经熟悉的分数版本，您可以从任何项目中取出任何分数，而在离散版本中，对于每个项目，您可以将整个项目放在背包中或你根本不接受它。</p>
    <p class="">So, in turn, the discrete version has two variants also.</p>
    <p class="line_zh">因此，反过来，离散版本也有两种变体。</p>
    <p class="">So, the first variant is knapsack with repetitions.</p>
    <p class="line_zh">所以，第一个变种是带有重复的背包。</p>
    <p class="">So in this case, you are given an unlimited quantity of each item.</p>
    <p class="line_zh">因此，在这种情况下，每个项目的数量不受限制。</p>
    <p class="">While in the knapsack without repetitions, you are given just a single copy of each item.</p>
    <p class="line_zh">在没有重复的背包中，您只需获得每个项目的一个副本。</p>
    <p class="">So we know already that the fractional knapsack problem can be solved by a simple greedy algorithm.</p>
    <p class="line_zh">所以我们已经知道分数背包问题可以通过一个简单的贪婪算法来解决。</p>
    <p class="">Such an algorithm at each iteration just picks an element, an item with the currently maximal value per unit of weight.</p>
    <p class="line_zh">每次迭代时的这种算法只选择一个元素，即每单位重量具有当前最大值的项目。</p>
    <p class="">This strategy, however, doesn't work for the discrete version of the knapsack problem.</p>
    <p class="line_zh">然而，这种策略不适用于背包问题的离散版本。</p>
    <p class="">So instead of using greedy strategy, we will design a dynamic programming solution to find an optimal value.</p>
    <p class="line_zh">因此，我们将设计一个动态编程解决方案来寻找最佳值，而不是使用贪心策略。</p>
    <p class="">Now let me give you a toy example.</p>
    <p class="line_zh">现在让我给你一个玩具示例。</p>
    <p class="">Assume that our input consists of a knapsack of total capacity of ten and four items shown on the slide.</p>
    <p class="line_zh">假设我们的输入包含一个总容量为10的背包和幻灯片上显示的四个项目。</p>
    <p class="">Then the optimal value for the knapsack without repetitions problem is equal to 46 and it can be obtained by taking the
        first item and the third item into your knapsack.</p>
    <p class="line_zh">然后没有重复问题的背包的最佳值等于46，并且可以通过将第一项和第三项放入背包中来获得。</p>
    <p class="">At the same time for the knapsack with repetitions problem.</p>
    <p class="line_zh">同时为背包带有重复问题。</p>
    <p class="">The optimal value in this case is equal to 48 and it can be obtained by taking one copy of the first item and two copies
        of the last item.</p>
    <p class="line_zh">在这种情况下，最佳值等于48，并且可以通过获取第一项的一个副本和最后一项的两个副本来获得。</p>
    <p class="">Finally, for the fractional knapsack problem, the optimal value is equal to 48 and a half and can be obtained by taking
        the first item, the second item, and half of the last item.</p>
    <p class="line_zh">最后，对于分数背包问题，最佳值等于48，并且可以通过取第一项，第二项和最后一项的一半来获得。</p>
    <p class="">Let's also use this example to show that greedy algorithm fails for the discrete version of the knapsack problem.</p>
    <p class="line_zh">让我们也用这个例子来说明贪婪算法对于背包问题的离散版本是失败的。</p>
    <p class="">Recall that the greedy strategy for this problem is to first compute the value per unit of weight for each item.</p>
    <p class="line_zh">回想一下，这个问题的贪婪策略是首先计算每个项目的每单位重量的值。</p>
    <p class="">In our case, the value per unit of weight for the first item is equal to five, for the second item it is equal to four
        and two thirds, for the third item it is equal to four, and for the last item it is equal to four and one half.</p>
    <p class="line_zh">在我们的例子中，第一项的每单位重量的值等于五，第二项的重量等于四和三分之二，第三项等于四，最后一项等于四到四点一半。</p>
    <p class="">So the first item has maximal value per unit of weight so we take it into our solution.</p>
    <p class="line_zh">因此，第一项具有每单位重量的最大值，因此我们将其纳入我们的解决方案。</p>
    <p class="">The next available item with the maximal value per unit of weight is the second one, so we take it also into the solution.</p>
    <p class="line_zh">具有每单位重量最大值的下一个可用项目是第二个，因此我们也将其纳入解决方案。</p>
    <p class="">Now the remaining capacity is too small to add any other element.</p>
    <p class="line_zh">现在剩余容量太小，无法添加任何其他元素。</p>
    <p class="">So this is our constructed solution, and it has weight, it has value 44 which is not optimal, we know it already.</p>
    <p class="line_zh">所以这是我们构建的解决方案，并且它具有重量，它具有非最佳值44，我们已经知道了。</p>
    <p class="">For example here, by replacing the second item by the third item, we will increase the total value.</p>
    <p class="line_zh">例如，在这里，通过用第三项替换第二项，我们将增加总值。</p>
    <p class="">This actually means that taking an element with a maximal value per unit of weight is not a safe step.</p>
    <p class="line_zh">这实际上意味着每单位重量采用一个具有最大值的元素并不是一个安全的步骤。</p>
    <p class="">Just by doing this we can lose a possibility to construct an optimal solution.</p>
    <p class="line_zh">通过这样做，我们可能失去构建最佳解决方案的可能性。</p>
    <p class="">Right, so this means actually that we need some other algorithm to solve this problem optimally.</p>
    <p class="line_zh">是的，所以这实际上意味着我们需要一些其他算法来最佳地解决这个问题。</p>
    <p class="">And we will design such an algorithm based on the dynamic programming technique in the next video.</p>
    <p class="line_zh">我们将在下一个视频中设计基于动态编程技术的算法。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 54 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_54">第02章 knapsack with repetitions
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02背包重复</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this video, we will design a dynamic programming solution for the Knapsack with repetitions problem.</p>
    <p class="line_zh">在本视频中，我们将针对具有重复问题的背包设计动态编程解决方案。</p>
    <p class="">Recall that in this problem, we are given an unlimited quantity of each item.</p>
    <p class="line_zh">回想一下，在这个问题中，每个项目的数量不受限制。</p>
    <p class="">This is a formal statement of the problem.</p>
    <p class="line_zh">这是对问题的正式陈述。</p>
    <p class="">We're given n items with weights w1, w2 and so on, wn.</p>
    <p class="line_zh">我们给了n个权重为w1，w2等的项目，wn。</p>
    <p class="">And its values are v1, v2 and so on, Vn.</p>
    <p class="line_zh">它的值是v1，v2等等，Vn。</p>
    <p class="">By capital W we denote the total capacity or the total weight of the knapsack.</p>
    <p class="line_zh">通过资本W，我们表示背包的总容量或总重量。</p>
    <p class="">And our goal is to select the subset of items where each item can be taken any number of times such that the total weight
        is at most capital W while the total value is as large as possible.</p>
    <p class="line_zh">我们的目标是选择项目的子集，其中每个项目可以被采取任意次数，使得总权重最多为大写W，而总值尽可能大。</p>
    <p class="">To come up with a dynamic programing algorithm, let's analyze the structure of an optimal solution.</p>
    <p class="line_zh">为了提出动态编程算法，让我们分析一下最优解的结构。</p>
    <p class="">For this consider some subset of items, of total weight, at most capital W, whose total value is maximal.</p>
    <p class="line_zh">为此，考虑总重量的一些子集，最多为大写字母W，其总值最大。</p>
    <p class="">And let's consider some element i in it, let's see what happens if we take this element out of this solution.</p>
    <p class="line_zh">让我们考虑其中的一些元素，让我们看看如果我们从这个解决方案中取出这个元素会发生什么。</p>
    <p class="">So what remains is some subset of items whose total weight is at most capital W minus wi.</p>
    <p class="line_zh">剩下的是一些项目的子集，其总权重最多为大写W减去wi。</p>
    <p class="">Right? So this is easy.</p>
    <p class="line_zh">对？所以这很容易。</p>
    <p class="">What is crucial for us is that the total value of this remaining subset of items must be optimal.</p>
    <p class="line_zh">对我们来说至关重要的是，这个剩余项目子集的总价值必须是最优的。</p>
    <p class="">I mean it must be maximal amount all subset of items whose total weight is at most capital w minus w i.</p>
    <p class="line_zh">我的意思是它必须是最大数量的所有项目的子集，其总权重最多为大写w减去w i。</p>
    <p class="">Why is that? Well, assume that there is some other subset of items whose total weight is at most, capital W- wi, but
        whose total value is higher? Let's then take the highest item and put it back to this subset of items.</p>
    <p class="line_zh">这是为什么？那么，假设还有一些其他项目的子集，其总权重最多，是资本W-wi，但其总值更高？然后让我们拿出最高的项目并将其放回到这个项目的子集中。</p>
    <p class="">What we get, actually, is the solution to our initial problem of higher value.</p>
    <p class="line_zh">实际上，我们得到的是解决我们最初价值更高的问题。</p>
    <p class="">I mean, its total weight is at most capital W, and its value is higher than the value of our initial solution.</p>
    <p class="line_zh">我的意思是，它的总重量最多为大写W，其值高于我们初始解的值。</p>
    <p class="">But these contradicts to the fact that we started with an optimal solution.</p>
    <p class="line_zh">但这些与我们从最佳解决方案开始的事实相矛盾。</p>
    <p class="">So, such trick is known as cut and paste trick.</p>
    <p class="line_zh">所以，这种技巧被称为剪切和粘贴技巧。</p>
    <p class="">And it is frequently used in designing dynamic programming algorithms.</p>
    <p class="line_zh">它经常用于设计动态编程算法。</p>
    <p class="">So, let me repeat what we just proved.</p>
    <p class="line_zh">所以，让我重复一下我们刚刚证明的内容。</p>
    <p class="">If we take an optimal solution for a knapsack of total weight W and take some item i out of it, then what remains must
        be an optimal solution for a knapsack of smaller weight.</p>
    <p class="line_zh">如果我们为总重量为W的背包采取最佳解决方案并从中取出一些物品，那么剩下的必须是重量较轻的背包的最佳解决方案。</p>
    <p class="">So this suggests that we have a separate subproblem for each possible total weight from zero to capital W.</p>
    <p class="line_zh">所以这表明我们对于从零到大写W的每个可能的总权重都有一个单独的子问题。</p>
    <p class="">Namely, let's define value of w as a optimal total value of items whose total weight is, at most w.</p>
    <p class="line_zh">也就是说，让我们将w的值定义为总权重最多为w的项目的最佳总值。</p>
    <p class="">This allows us to express value of w using the values for a smaller weight knapsack.</p>
    <p class="line_zh">这允许我们使用较小重量背包的值来表达w的值。</p>
    <p class="">Namely to get an optimal solution for a knapsack of total weight w we first take some smaller knapsack and an optimal
        solution for it and add an item i to it.</p>
    <p class="line_zh">即为了获得总重量w的背包的最佳解决方案，我们首先采用一些较小的背包和最佳解决方案，然后添加一个项目i。</p>
    <p class="">So first of all to be able to add an item i to it and get a knapsack of total weight W we need this smaller knapsack
        to be of total weight at most W minus wi, also when adding i'th item to it we increase its value by vi, and the final
        thing is we do not know which element to add exactly.</p>
    <p class="line_zh">所以首先要能够添加一件物品并获得总重量W的背包我们需要这个较小的背包总重量最多W减去wi，同时当我添加第i个物品时我们增加它vi的值，最后一点是我们不知道要添加哪个元素。</p>
    <p class="">For this reason, we just go through all possible elements, n items, and select the maximal value.</p>
    <p class="line_zh">因此，我们只需浏览所有可能的元素，n个项目，然后选择最大值。</p>
    <p class="">The maximal value of the following thing: Value of W minus wi, plus vi.</p>
    <p class="line_zh">以下事物的最大值：W的值减去wi，再加上vi。</p>
    <p class="">Having a recurrent formula for value of w as we just discussed, it is not so difficult to implement an algorithm solving
        the knapsack problem with repetitions.</p>
    <p class="line_zh">正如我们刚刚讨论过的那样，对于w的值有一个循环公式，实现一个用重复来解决背包问题的算法并不困难。</p>
    <p class="">Recall that we expressed the solution for a knapsack, through solutions from knapsacks of smaller weight.</p>
    <p class="line_zh">回想一下，我们通过较小重量背包的解决方案表达了背包的解决方案。</p>
    <p class="">This means that it makes sense to solve our subproblems in the order of increasing weight.</p>
    <p class="line_zh">这意味着按重量增加的顺序解决我们的子问题是有意义的。</p>
    <p class="">So we do this in the pseudocode.</p>
    <p class="line_zh">所以我们在伪代码中这样做。</p>
    <p class="">Initially we set value of 0 to 0 just to reflect that fact that the maximal possible total value of a Knapsack of weight
        0, clearly equals 0.</p>
    <p class="line_zh">最初我们将值0设置为0只是为了反映重量为0的背包的最大可能总值，显然等于0。</p>
    <p class="">Then we go in a loop from w=1 to W.</p>
    <p class="line_zh">然后我们进入从w = 1到W的循环。</p>
    <p class="">And for each such w we just compute the corresponding maximum as follows.</p>
    <p class="line_zh">对于每个这样的w，我们只计算相应的最大值，如下所示。</p>
    <p class="">We go through all items i such that wi is at most w.</p>
    <p class="line_zh">我们经历了所有项目，使得wi最多w。</p>
    <p class="">And for each such item i, we see what happens if we take an optimal solution of for a knapsack of size W minus wi, and
        add an item i into it.</p>
    <p class="line_zh">对于每个这样的项目我，我们​​看到如果我们采用尺寸为W减去wi的背包的最佳解决方案会发生什么，并在其中添加项目i。</p>
    <p class="">Clearly in this case, the total value is value(w minus wi) plus vi, and the total weight is at most W.</p>
    <p class="">显然，在这种情况下，总值是值（w减去wi）加上vi，总重量最多是W.</p>
    <p class="">So this is a feasible solution for a Knapsack of total weight W.</p>
    <p class="line_zh">所以这是一个总重量为W的背包的可行解决方案。</p>
    <p class="">So we check whether the result in value is larger and what we currently have and if it is we update value of w.</p>
    <p class="line_zh">因此，我们检查值的结果是否更大以及我们当前有什么，如果是，我们更新w的值。</p>
    <p class="">In the end, we just return value of capital W.</p>
    <p class="line_zh">最后，我们只返回资本W的值。</p>
    <p class="">So this algorithm is clearly correct because it just implements our recurrent formula, right? So in particular this loop
        just computes the maximum from the previous slide.</p>
    <p class="line_zh">所以这个算法显然是正确的，因为它只是实现了我们的循环公式，对吗？所以特别是这个循环只计算上一张幻灯片的最大值。</p>
    <p class="">Now let's estimate the running time of this algorithm.</p>
    <p class="line_zh">现在让我们估算一下这个算法的运行时间。</p>
    <p class="">It is not difficult to see that the running time is of n multiplied by capital W.</p>
    <p class="">不难看出运行时间是n乘以大写字母W.</p>
    <p class="">Why is that? Well just because we have two nested loops here.</p>
    <p class="line_zh">这是为什么？好吧，因为我们这里有两个嵌套循环。</p>
    <p class="">So this is the first loop, and this is the second loop.</p>
    <p class="line_zh">所以这是第一个循环，这是第二个循环。</p>
    <p class="">The first one has capital W on it, capital W iterations.</p>
    <p class="line_zh">第一个有大写字母W，大写字母W迭代。</p>
    <p class="">And the second one has n iterations.</p>
    <p class="line_zh">第二个有n次迭代。</p>
    <p class="">N iterations.</p>
    <p class="line_zh">N次迭代。</p>
    <p class="">What happens inside in the loop here it takes just constant time.</p>
    <p class="line_zh">在循环内部发生的事情只需要恒定的时间。</p>
    <p class="">We conclude this video by applying our algorithm to the example considered a few minutes before.</p>
    <p class="line_zh">我们通过将算法应用于几分钟前考虑的示例来结束本视频。</p>
    <p class="">So in this case we are given four items and a knapsack of total capacity 10.</p>
    <p class="line_zh">所以在这种情况下，我们给了四件物品和一个总容量10的背包。</p>
    <p class="">We are going to compute the optimal value for all knapsacks of total weight from zero to ten.</p>
    <p class="line_zh">我们将计算从0到10的总重量的所有背包的最佳值。</p>
    <p class="">So, which means that it makes sense to store all these values just in an array.</p>
    <p class="line_zh">因此，这意味着将所有这些值存储在数组中是有意义的。</p>
    <p class="">So, shown here on the slide.</p>
    <p class="line_zh">所以，在幻灯片上显示。</p>
    <p class="">Initially this array is filled by zero's and we're going to fill it in with values from left to right.</p>
    <p class="line_zh">最初这个数组用零填充，我们将用从左到右的值填充它。</p>
    <p class="">So the first non-obvious cell is two.</p>
    <p class="line_zh">所以第一个非显而易见的细胞是两个。</p>
    <p class="">So this is the first weight for which we can add any item.</p>
    <p class="line_zh">所以这是我们可以添加任何项目的第一个重量。</p>
    <p class="">So in this case we can actually say that to get a solution for knapsack of total weight two we can get a solution for
        knapsack of total weight 0 and add the last element to it.</p>
    <p class="line_zh">因此，在这种情况下，我们实际上可以说，为了获得总重量为2的背包的解决方案，我们可以获得总重量为0的背包的解决方案并添加最后一个元素。</p>
    <p class="">This will also give us plus nine to the value.</p>
    <p class="line_zh">这也将给我们加上9倍的价值。</p>
    <p class="">So this is the only possible solution for this cell, so we do not even need to compute the maximum.</p>
    <p class="line_zh">所以这是这个单元的唯一可行解决方案，所以我们甚至不需要计算最大值。</p>
    <p class="">So in this case, the value is equal to nine.</p>
    <p class="line_zh">所以在这种情况下，该值等于9。</p>
    <p class="">So what about value of three? So in this case, we already have a choice.</p>
    <p class="line_zh">三个价值怎么样？所以在这种情况下，我们已经有了选择。</p>
    <p class="">We can either get an optimal solution for total weight one, and add the fourth element to it, or we can get an optimal
        solution for a knapsack of total weight zero and add the second element to it, whose value is 14.</p>
    <p class="line_zh">我们可以获得总重量为1的最优解，并将第四个元素添加到其中，或者我们可以获得总重量为零的背包的最佳解决方案，并将第二个元素添加到其中，其值为14。</p>
    <p class="">So among these two values, the second choice is better.</p>
    <p class="line_zh">因此，在这两个值中，第二个选择更好。</p>
    <p class="">It gives us a solution of value 14, so we'll write it in this cell.</p>
    <p class="line_zh">它为我们提供了值14的解决方案，因此我们将在此单元格中编写它。</p>
    <p class="">Now, for value of 4, there are already three choices.</p>
    <p class="line_zh">现在，对于4的值，已经有三种选择。</p>
    <p class="">Let's consider them.</p>
    <p class="line_zh">让我们考虑一下。</p>
    <p class="">So also we can take an optimal solution for a knapsack of total weight two and add the last to it.</p>
    <p class="line_zh">因此，我们也可以为总重量为2的背包采用最佳解决方案，并添加最后一个。</p>
    <p class="">So this is plus 9 or we can take an optimal solution for a knapsack of total weight one and add the second item to it
        so plus 14 or we can take an optimal solution for a knapsack of total weight 0 and add the third item.</p>
    <p class="line_zh">所以这是加9或者我们可以为总重量1的背包采取最佳解决方案并将第二项添加到其中加上14或者我们可以为总重量0的背包采用最佳解决方案并添加第三项。</p>
    <p class="">This is plus 16.</p>
    <p class="line_zh">这是加16。</p>
    <p class="">Right? So in this case, we need to select the maximum amount 16, 14 and 9 plus 9 which is 18.</p>
    <p class="line_zh">对？所以在这种情况下，我们需要选择最大量16,14和9加9，即18。</p>
    <p class="">In this case, 18 is the maximum value.</p>
    <p class="line_zh">在这种情况下，18是最大值。</p>
    <p class="">So we'll write it in this cell.</p>
    <p class="line_zh">所以我们将在这个单元格中编写它。</p>
    <p class="">So by continuing in the same manner, we can fill in the whole array and see that the last element is equal to 48, we
        just devise that the optimal value for this knapsack with repetitions problem is equal to 48.</p>
    <p class="line_zh">因此，通过以相同的方式继续，我们可以填充整个数组并看到最后一个元素等于48，我们只是设计这个带有重复问题的背包的最佳值等于48。</p>
    <p class="">And also, let me remind you that this optimal value can be updated by taking one copy of this item, and 2 copies of the
        last item.</p>
    <p class="line_zh">而且，让我提醒您，可以通过获取此项目的一个副本和最后一个项目的2个副本来更新此最佳值。</p>
    <p class="">In the next video, we will learn how to solve this problem when repetitions are not allowed.</p>
    <p class="line_zh">在下一个视频中，我们将学习如何在不允许重复时解决此问题。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 55 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_55">第03章 knapsack without repetitions
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">03背包没有重复</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this video we will be designing a dynamic formatting solution for the Knapsack without Repetitions problem.</p>
    <p class="line_zh">在本视频中，我们将为没有重复问题的背包设计动态格式化解决方案。</p>
    <p class="">Recall that in this problem we're give a single copy of each item.</p>
    <p class="line_zh">回想一下，在这个问题中，我们给出了每个项目的单个副本。</p>
    <p class="">So this is also to remind you the formal statement of the problem, so we emphasize once again that we are not allowed
        to take more than a single copy of each item.</p>
    <p class="line_zh">因此，这也是为了提醒您正式声明问题，因此我们再次强调，我们不允许每个项目获得多个副本。</p>
    <p class="">Well, we already know that our previous same reason cannot produce the right answer for our new very namely for the Knapsack
        without repetitions problems.</p>
    <p class="line_zh">好吧，我们已经知道我们以前的同样理由无法为我们的新产品做出正确的答案，即背包没有重复问题。</p>
    <p class="">Well this is simply because in our toy example is that optimal value for the Knapsack with repetitions was 48 while the
        optimal value for the Knapsack without repetitions was 46.</p>
    <p class="line_zh">嗯，这只是因为在我们的玩具示例中，带有重复的背包的最佳值是48，而没有重复的背包的最佳值是46。</p>
    <p class="">So this means that if we just run our previous algorithm, it will produce an incorrect result.</p>
    <p class="line_zh">所以这意味着如果我们只运行我们之前的算法，它将产生不正确的结果。</p>
    <p class="">Still it is important to understand where our algorithms, where our reasoning more generally fails for this problem.</p>
    <p class="line_zh">仍然重要的是要了解我们的算法在哪里，我们的推理更普遍地解决了这个问题。</p>
    <p class="">So once again, let's consider an optimal subset of items for a knapsack of total weight capital W.</p>
    <p class="line_zh">所以再一次，让我们考虑一个总重量资本W背包的最佳项目子集。</p>
    <p class="">And assume for the moment that we know that it contains the nth element.</p>
    <p class="line_zh">并假设我们知道它包含第n个元素。</p>
    <p class="">That is the last item.</p>
    <p class="line_zh">那是最后一项。</p>
    <p class="">So we argue, well similarly to the previous case that if we take this item out of the current knapsack, then what we
        get must be an optimal solution for a knapsack of smaller weight, namely of total weight W- wn.</p>
    <p class="line_zh">因此，我们认为，与之前的情况类似，如果我们从目前的背包中取出这个项目，那么我们得到的必须是一个较小重量的背包的最佳解决方案，即总重量W- wn。</p>
    <p class="">So if we take we the smaller solution and we add the nth item to it, we get an optimal solution for the initial knapsack
        of total weight, W.</p>
    <p class="line_zh">因此，如果我们采用较小的解决方案并将第n个项目添加到其中，我们将获得总重量的初始背包W的最佳解决方案。</p>
    <p class="">I assume however, that the optimal solution for the smaller knapsack, already contains the nth item.</p>
    <p class="line_zh">然而，我认为，较小的背包的最佳解决方案已经包含第n项。</p>
    <p class="">This means that we cannot add another copy of the nth element to it, right, because then the resulting solution will
        contain two copies of the nth element which is now forbidden by the problem formulation.</p>
    <p class="line_zh">这意味着我们不能向其添加第n个元素的另一个副本，因为这样生成的解决方案将包含第n个元素的两个副本，现在问题公式禁止这两个副本。</p>
    <p class="">So this is why we need to come up with a different notion of a subproblem.</p>
    <p class="line_zh">所以这就是为什么我们需要提出一个不同的子问题概念。</p>
    <p class="">So still, let's take a closer look at our optimal solution.</p>
    <p class="line_zh">那么，让我们仔细看看我们的最佳解决方案。</p>
    <p class="">It is not difficult to see that there are only two cases, either it contains the lost item, or it doesn't contain it.</p>
    <p class="line_zh">不难看出只有两种情况，要么它包含丢失的项目，要么它不包含它。</p>
    <p class="">I assume that it contains, and let's again take this nth item out of our current solution.</p>
    <p class="line_zh">我假设它包含，让我们再次从我们当前的解决方案中取出第n个项目。</p>
    <p class="">So what is left? First of all, it is some solution for a knapsack of total weight, capital W- wn, and it also uses only
        items from 1 to n- 1, because, well, we just took out the nth item, right? If, on the other hand, the initial optimal
        solution for the knapsack of total weight W does not contain the nth item, well, then it contains only items from
        1 to n minus 1.</p>
    <p class="line_zh">还剩下什么？首先，它是一个总重量的背包，资本W-wn的解决方案，它也只使用从1到n-1的项目，因为，好吧，我们刚拿出第n项，对吧？另一方面，如果总重量W的背包的初始最佳解决方案不包含第n项，那么它仅包含从1到n减去1的项目。</p>
    <p class="">Right? Well this simple observation will help us to get the right definition of a subproblem for this version of the
        knapsack problem.</p>
    <p class="line_zh">对？那么这个简单的观察将帮助我们为这个版本的背包问题得到正确的子问题定义。</p>
    <p class="">Well on the previous slide we argued as follows.</p>
    <p class="line_zh">在上一张幻灯片上，我们认为如下。</p>
    <p class="">Consider an optimal solution for a knapsack of total weight capital W.</p>
    <p class="line_zh">考虑总重量资本W的背包的最佳解决方案。</p>
    <p class="">And there are two cases.</p>
    <p class="line_zh">有两种情况。</p>
    <p class="">Either it can contain the last item or it doesn't contain.</p>
    <p class="line_zh">它可以包含最后一项，也可以不包含。</p>
    <p class="">If it contains we can take it out, and reduce the problem for small knapsack using only items from one to n minus one.</p>
    <p class="line_zh">如果它包含我们可以把它拿出来，并减少小背包的问题，​​只使用从1到n减1的项目。</p>
    <p class="">On the other hand, if it doesn't contain the nth item, then we'll reduce it to another case when the knapsack only uses
        items from 1 to n-1.</p>
    <p class="line_zh">另一方面，如果它不包含第n个项目，那么当背包仅使用1到n-1的项目时，我们会将其减少到另一个案例。</p>
    <p class="">In any case, we reduce the number of items and in the first case, we also reduce the size of the knapsack, the total
        weight of the knapsack.</p>
    <p class="line_zh">无论如何，我们减少了物品的数量，在第一种情况下，我们还减少了背包的尺寸，即背包的总重量。</p>
    <p class="">We might continue this process, and express the solution for all sub-problems through solutions to force up subproblems.</p>
    <p class="line_zh">我们可以继续这个过程，并通过强制解决子问题的解决方案来表达所有子问题的解决方案。</p>
    <p class="">If we continue in the same fashion what we get somewhere in the middle is a solution for a knapsack of some weight that
        uses some first i items.</p>
    <p class="line_zh">如果我们以同样的方式继续我们在中间的某个地方是一个使用一些第一件物品的一些重量的背包的解决方案。</p>
    <p class="">Well let's just use this as a definition of our subproblem.</p>
    <p class="line_zh">好吧，让我们把它作为我们子问题的定义。</p>
    <p class="">Namely, for any w, from 0 to W, and for any i, from 0 to n, let's denote by value of w and i the maximum value that can
        be achieved by using only items from 1 to i, and whose total weight is at most w.</p>
    <p class="line_zh">即，对于任何w，从0到W，对于任何i，从0到n，让我们用w和i的值表示通过仅使用从1到i的项目可以实现的最大值，并且其总权重是至多w。</p>
    <p class="">Right, then it is easy to express it through solutions for smaller such problems.</p>
    <p class="line_zh">是的，那么很容易通过针对较小的此类问题的解决方案来表达它。</p>
    <p class="">Once again, value of w and i, is a subset, is an optimal value of a subset, of the first items who stole the weight is
        utmost w.</p>
    <p class="line_zh">再一次，w和i的值是子集，是一个子集的最佳值，其中最重要的是偷走权重的物品。</p>
    <p class="">So we know that in this optimal subset, either there is the i-th item or the i-th item is not contained in it.</p>
    <p class="line_zh">所以我们知道在这个最佳子集中，要么存在第i个项目，要么第i个项目不包含在其中。</p>
    <p class="">So there are two cases.</p>
    <p class="line_zh">所以有两种情况。</p>
    <p class="">So we need to select the maximum out of two cases.</p>
    <p class="line_zh">所以我们需要选择两种情况中的最大值。</p>
    <p class="">And the first case if we take the i-th item out what is left is an optimal solution for the following problem.</p>
    <p class="line_zh">第一种情况是，如果我们将剩下的第i个项目拿出来，则是针对以下问题的最佳解决方案。</p>
    <p class="">We are allowed only to use the first i-1 items and the total weight should be no more than w-wi, so this is the first
        term under the maximum.</p>
    <p class="line_zh">我们只允许使用第一个i-1项目，总重量不应超过w-wi，所以这是最大值下的第一个项目。</p>
    <p class="">In the second case, if the i-th item is not used in an optimal solution, then we just know that the optimal solution
        is the same as for the knapsack of total weight, W, using only the first i- 1 items.</p>
    <p class="line_zh">在第二种情况下，如果第i个项目未在最佳解决方案中使用，那么我们只知道最佳解决方案与仅使用第一个i-1项目的总重量W的背包相同。</p>
    <p class="">So we managed to express the solution for our problems through solutions for smaller sub-problems.</p>
    <p class="line_zh">因此，我们通过针对较小子问题的解决方案设法为我们的问题表达了解决方案。</p>
    <p class="">And this is probably the most important thing in designing dynamic problem in algorithms.</p>
    <p class="line_zh">这可能是设计算法中动态问题最重要的事情。</p>
    <p class="">We now done our recurrent formula into a dynamic problem in algorithm.</p>
    <p class="line_zh">我们现在将我们的循环公式变成算法中的动态问题。</p>
    <p class="">As usual, we start from initialization namely with your set all the values of 0, j to 0 for all j and all the values
        of w, 0 to 0.</p>
    <p class="line_zh">像往常一样，我们从初始化开始，即设置所有j的所有值，j为0，所有j和w的所有值，0到0。</p>
    <p class="">Well, this just expresses the fact that if we have no items, well, then the value is zero.</p>
    <p class="line_zh">嗯，这只是表达了这样一个事实，即如果我们没有项目，那么该值为零。</p>
    <p class="">If we have the knapsack of total weight zero, then the total value's also zero, of course.</p>
    <p class="line_zh">如果我们有总重量为零的背包，那么当然总值也为零。</p>
    <p class="">Then recall, now, we need to somehow compute, all other values of w, i.</p>
    <p class="line_zh">然后回想一下，现在，我们需要以某种方式计算w，i的所有其他值。</p>
    <p class="">Recall that we expressed value Wi of Wi through values of W, smaller w and i- 1 and W and i- 1.</p>
    <p class="line_zh">回想一下，我们通过W，更小的w和i-1以及W和i-1的值表示Wi的Wi值。</p>
    <p class="">This means that we always reduce the problem from Wi to something with smaller number of items, to i- 1.</p>
    <p class="line_zh">这意味着我们总是将问题从Wi减少到项目数量较少的东西到i-1。</p>
    <p class="">This actually helps us to understand that it makes sense to gradually increase the number of allowable items.</p>
    <p class="line_zh">这实际上有助于我们理解逐渐增加可允许项目的数量是有意义的。</p>
    <p class="">And this is why we have in this pseudocode an outer loop where i goes from 1 to n.</p>
    <p class="line_zh">这就是为什么我们在这个伪代码中有一个外环，我从1到n。</p>
    <p class="">When i is fixed, we will compute all the values of W, i.</p>
    <p class="line_zh">当我修复时，我们将计算W，i的所有值。</p>
    <p class="">So for this, we also go from W equal to 1 to capital W and do the following.</p>
    <p class="line_zh">所以为此，我们也从W等于1到大写W并执行以下操作。</p>
    <p class="">So now, i and W are fixed, we need to compute value of W, i.</p>
    <p class="line_zh">所以现在，我和W是固定的，我们需要计算W的值，i。</p>
    <p class="">First, we just check what is the value of, what is the solution for the subproblem when we use the knapsack of the same
        weight w but we only use the first i-1 items.</p>
    <p class="line_zh">首先，我们只检查当我们使用相同重量w的背包时，子问题的价值是什么，但我们只使用第一个i-1项目。</p>
    <p class="">This is implemented as follows.</p>
    <p class="line_zh">这实现如下。</p>
    <p class="">We first just assign value of w, i to value of w, i-1.</p>
    <p class="line_zh">我们首先将w，i的值赋给w，i-1的值。</p>
    <p class="">Then we need to check whether we can improve this value by using the i-th item.</p>
    <p class="line_zh">然后我们需要检查是否可以使用第i个项目来改善此值。</p>
    <p class="">First of all we can only do this if the weight of the ice item does not exceed the weight of the current knapsack which
        is just W.</p>
    <p class="line_zh">首先，如果冰块的重量不超过当前背包的重量，我们只能做到这一点。</p>
    <p class="">So, if it doesn't exceed we see what happens if we take an optimal value for the knapsack of the total weight w minus
        wi.
    </p>
    <p class="line_zh">因此，如果它没有超过，我们会看到如果我们为总重量减去wi的背包取最佳值会发生什么。</p>
    <p class="">That is filled only by elements from 1 to i minus 1, and add the i-th element to it.</p>
    <p class="line_zh">仅由1到i减去1的元素填充，并将第i个元素添加到其中。</p>
    <p class="">If it gives a larger value than we currently have, we will update the value of wi, so in the end we just return the value
        of capital w and n.</p>
    <p class="line_zh">如果它给出的值大于我们现在的值，我们将更新wi的值，所以最后我们只返回大写w和n的值。</p>
    <p class="">Because this is the solution to our initial problem.</p>
    <p class="line_zh">因为这是我们最初问题的解决方案。</p>
    <p class="">So this a solution for a knapsack of size capital w that uses just all the n items, right? Now so it is clear that this
        algorithm is correct just because it directly implements the recurrent formula that we already discussed.</p>
    <p class="line_zh">所以这是一个大小资本w的背包解决方案，只使用所有n个项目，对吗？现在很清楚，这个算法是正确的，因为它直接实现了我们已经讨论过的循环公式。</p>
    <p class="">So let's analyze its running time.</p>
    <p class="line_zh">那么让我们分析一下它的运行时间。</p>
    <p class="">It is not difficult to show, again, that its running time is actually the same.</p>
    <p class="line_zh">再次表明它的运行时间实际上是相同的并不难。</p>
    <p class="">It is again n multiplied by W.</p>
    <p class="">再次乘以W乘以W.</p>
    <p class="">Well, this is again just because we have two loops here.</p>
    <p class="line_zh">嗯，这又是因为我们这里有两个循环。</p>
    <p class="">So this is the first loop with n iterations, and this is the inner loop with W iterations.</p>
    <p class="line_zh">所以这是第一个具有n次迭代的循环，这是具有W次迭代的内部循环。</p>
    <p class="">And what is going on inside only takes some constant time.</p>
    <p class="line_zh">内部发生的事情只需要一些时间。</p>
    <p class="">Now let's apply the algorithm that we've just designed to our toy example.</p>
    <p class="line_zh">现在让我们将我们刚刚设计的算法应用到我们的玩具示例中。</p>
    <p class="">Recall that we need to store the values of all subproblems for Wi, for all W from zero to ten, and all i from zero to
        four, in our case.</p>
    <p class="line_zh">回想一下，在我们的例子中，我们需要存储Wi的所有子问题的值，对于从0到10的所有W，以及从0到4的所有i。</p>
    <p class="">For these purposes, it is natural to use a two-dimensional table, or two-dimensional array.</p>
    <p class="line_zh">出于这些目的，使用二维表或二维阵列是很自然的。</p>
    <p class="">You can see such a two-dimensional array on the slide already filled in.</p>
    <p class="line_zh">您可以在已填充的幻灯片上看到这样的二维数组。</p>
    <p class="">So here we have i, so all the rows of our columns are by all possible way of i, and all the columns in this set by all
        possible values of W.</p>
    <p class="line_zh">所以这里有i，所以我们列的所有行都是i的所有可能的方式，并且这个集合中的所有列都是W的所有可能值。</p>
    <p class="">Right, we start by initializing the first row, and the first column of this table by zero.</p>
    <p class="line_zh">是的，我们首先初始化第一行，并将该表的第一列归零。</p>
    <p class="">That is, we fill this row by zeroes and we fill this column by zeroes also.</p>
    <p class="line_zh">也就是说，我们用零填充这一行，我们也用零填充这一列。</p>
    <p class="">Then we start filling in this table row by row.</p>
    <p class="line_zh">然后我们开始逐行填写此表。</p>
    <p class="">That is, we first fill in this cell, then this cell, then this cell, then this cell, and so on.</p>
    <p class="line_zh">也就是说，我们首先填充此单元格，然后填充此单元格，然后填充此单元格，然后填充此单元格，依此类推。</p>
    <p class="">So we go like this.</p>
    <p class="line_zh">所以我们这样做。</p>
    <p class="">So we first fill in this row, then fill in this row, then fill in this row and then fill in this row.</p>
    <p class="line_zh">所以我们首先填写这一行，然后填写这一行，然后填写这一行，然后填写这一行。</p>
    <p class="">So the results in value 46 is actually the answer to our initial problem.</p>
    <p class="line_zh">因此，值46的结果实际上是我们最初问题的答案。</p>
    <p class="">Now, let me show you how some particular value, just through this trait, let me show you how some particular value in
        this table was computed.</p>
    <p class="line_zh">现在，让我告诉你一些特殊的价值，通过这个特性，让我告诉你如何计算这个表中的某个特定值。</p>
    <p class="">For example, consider this cell.</p>
    <p class="line_zh">例如，考虑这个单元格。</p>
    <p class="">So formally, this is value, value(10, 2).</p>
    <p class="line_zh">正式地说，这就是价值，价值（10,2）。</p>
    <p class="">Which means that this is an optimal value of a knapsack of total weight 10 that only uses the first two items.</p>
    <p class="line_zh">这意味着这是仅使用前两个项目的总重量10的背包的最佳值。</p>
    <p class="">So assume that we don't know what to put here.</p>
    <p class="line_zh">所以假设我们不知道该放什么。</p>
    <p class="">So we just need to compute it right now.</p>
    <p class="line_zh">所以我们现在只需要计算它。</p>
    <p class="">So let's argue as we did before.</p>
    <p class="line_zh">所以让我们像以前一样争论。</p>
    <p class="">So this is a knapsack of total weight 10 that uses only the first two items.</p>
    <p class="line_zh">所以这是一个总重量10的背包，只使用前两个项目。</p>
    <p class="">Well, we then say that the second item is either used or not.</p>
    <p class="line_zh">那么，我们说第二个项目是否使用。</p>
    <p class="">So if it is not used, then this is the same as filling in the Knapsack of total weight ten just using the first item.</p>
    <p class="line_zh">因此，如果没有使用，那么这与使用第一项填写总重量十的背包相同。</p>
    <p class="">And we already know this value because it is in the previous row.</p>
    <p class="line_zh">我们已经知道这个值，因为它在前一行。</p>
    <p class="">So this is value 10, 1, right? So the value in this case is 30.</p>
    <p class="line_zh">所以这是值10,1，对吗？所以这个案子的价值是30。</p>
    <p class="">On the other hand, if the second item is used, then if we take it out, what is left is an optimal solution for a knapsack
        of total weight 10 minus 3.</p>
    <p class="line_zh">另一方面，如果使用第二项，那么如果我们拿出它，剩下的是总重量减去3的背包的最佳解决方案。</p>
    <p class="">Because 3 is the weight of the second item, which means that it is an optimal solution for a knapsack of size 7.</p>
    <p class="line_zh">因为3是第二项的重量，这意味着它是尺寸为7的背包的最佳解决方案。</p>
    <p class="">Of total weight 7 that only uses the first, that is only allowed to use the first item.</p>
    <p class="line_zh">在仅使用第一个的总重量7中，仅允许使用第一个项目。</p>
    <p class="">Also, if we add this item to, if we add the second item to the solution, we get 30 plus 14.</p>
    <p class="line_zh">另外，如果我们将此项添加到，如果我们将第二项添加到解决方案中，我们会得到30加14。</p>
    <p class="">Which is much better than without using the second item, right? So that's why we have 44 here.</p>
    <p class="line_zh">哪个比不使用第二个项目好得多，对吧？这就是为什么我们这里有44个。</p>
    <p class="">And also for this reason we fill this matrix row by row.</p>
    <p class="line_zh">而且由于这个原因，我们逐行填充这个矩阵。</p>
    <p class="">So now that when we need to compute the value of this cell, we already have computed the value of these two cells.</p>
    <p class="line_zh">所以现在当我们需要计算这个单元格的值时，我们已经计算了这两个单元格的值。</p>
    <p class="">So that's why we fill our metrics exactly row by row.</p>
    <p class="line_zh">这就是为什么我们要逐行填写我们的指标。</p>
    <p class="">Now let me use the same example to illustrate an important technique in dynamic programming.</p>
    <p class="line_zh">现在让我用相同的例子来说明动态编程中的一项重要技术。</p>
    <p class="">Namely reconstructing an optimal solution.</p>
    <p class="line_zh">即重建最佳解决方案。</p>
    <p class="">Reconstructing an optimal solution in this particular problem I mean finding not only the optimal value for the knapsack
        of size of total weight.</p>
    <p class="line_zh">在这个特定问题中重建最优解决方案我的意思是不仅要找到总重量大小的背包的最佳值。</p>
    <p class="">But the subset of items that lead to this optimal value itself.</p>
    <p class="line_zh">但是导致这种最佳价值的物品子集本身。</p>
    <p class="">For this we first create a boolean array of size four.</p>
    <p class="line_zh">为此，我们首先创建一个大小为4的布尔数组。</p>
    <p class="">In this array, we will mark, for each item, whether it is used in an optimal solution or not.</p>
    <p class="line_zh">在这个数组中，我们将为每个项目标记它是否用于最佳解决方案。</p>
    <p class="">Now what we're going to do is to back trace the path that led us to the optimal value, 46.</p>
    <p class="line_zh">现在我们要做的是回溯追踪导致我们达到最佳值的路径，46。</p>
    <p class="">In particular, let's try to understand how this value of 46 was computed.</p>
    <p class="line_zh">特别是，让我们试着理解如何计算46的这个值。</p>
    <p class="">Well, first of all, 46 is formally value of 10, 4, that is is an optimal value for a knapsack of total weight ten using
        the first four items.</p>
    <p class="line_zh">嗯，首先，46正式值为10,4，这是使用前四项的总重量十的背包的最佳值。</p>
    <p class="">We argued that the fourth item is either used or not.</p>
    <p class="line_zh">我们认为第四项是否使用。</p>
    <p class="">If it is not used, then this value is the same as the value 10, 3, which is shown here.</p>
    <p class="line_zh">如果未使用，则此值与值10,3相同，此处显示。</p>
    <p class="">That is the value of the knapsack of the same weight, using the first three items.</p>
    <p class="line_zh">这是使用前三项相同重量的背包的价值。</p>
    <p class="">If on the other hand it is used, then what is left must be an optimal solution for a knapsack of size 10 minus 2 which
        is 8, that uses also the first three items.</p>
    <p class="line_zh">另一方面，如果使用它，那么留下的东西必须是尺寸10减去2的背包的最佳解决方案，其为8，其也使用前三个项目。</p>
    <p class="">Well this value is already computed, it is 30, so we need to compute the maximum among 30 plus 9, because, well the value
        of the last item is 9 and 46.</p>
    <p class="line_zh">那么这个值已经计算好了，它是30，所以我们需要计算30加9之间的最大值，因为最后一项的值是9和46。</p>
    <p class="">In this particular case there, the maximum is equal to 46 which means that we decided at this point not to use the last
        item, right? So we put 0 into our boolean array to indicate this, and we move to this cell.</p>
    <p class="line_zh">在这种特殊情况下，最大值等于46，这意味着我们此时决定不使用最后一项，对吧？所以我们将0放入我们的布尔数组中以表明这一点，然后我们移动到这个单元格。</p>
    <p class="">Again, let's try to understand how this value was computed.</p>
    <p class="line_zh">再次，让我们试着理解这个值是如何计算的。</p>
    <p class="">It was computed as the maximum value of two numbers which depend on the following values.</p>
    <p class="line_zh">它被计算为两个数的最大值，它取决于以下值。</p>
    <p class="">So either we do not use the third item, then it is the same, has the value of this cell or we use the third item.</p>
    <p class="line_zh">所以要么我们不使用第三个项目，那么它是相同的，具有此单元格的值或我们使用第三个项目。</p>
    <p class="">In this case, what remains is an knapsack of size, of total weight 6, and using the first two items and its value is
        30.
    </p>
    <p class="line_zh">在这种情况下，剩下的是一个大小的背包，总重量为6，并且使用前两个项目，其值为30。</p>
    <p class="">Plus the weight of the third item, which is 16.</p>
    <p class="line_zh">再加上第三项的重量，即16。</p>
    <p class="">In this particular case, 30 plus 16 is larger than 44, which means that this value of 46 was computed using this value.</p>
    <p class="line_zh">在这种特殊情况下，30加16大于44，这意味着使用该值计算该值46。</p>
    <p class="">This, in turn, means that we decided to use the third item.</p>
    <p class="line_zh">反过来，这意味着我们决定使用第三个项目。</p>
    <p class="">Let's mark it by putting 1 into our boolean array.</p>
    <p class="line_zh">让我们通过将1放入我们的布尔数组来标记它。</p>
    <p class="">Now we stay in this cell and we try to understand how it was computed.</p>
    <p class="line_zh">现在我们留在这个单元格中，我们试着了解它是如何计算的。</p>
    <p class="">It was computed as a maximum over this 30 and this 0, plus fourteen.</p>
    <p class="line_zh">它被计算为这个30和0的最大值加上十四。</p>
    <p class="">Right, in this case, the first value is larger so we move to this cell and we mark that we decided not to use the second
        item.
    </p>
    <p class="line_zh">是的，在这种情况下，第一个值更大，所以我们移动到这个单元格，我们标记我们决定不使用第二个项目。</p>
    <p class="">Okay and finally, we realize that we arrived at this value 30 from the right, from the left upper corner.</p>
    <p class="line_zh">好的，最后，我们意识到我们从右上角到左上角达到了这个值30。</p>
    <p class="">Right? So, this way we reconstructed the wall optimal solution.</p>
    <p class="line_zh">对？因此，我们通过这种方式重建了墙体最优解。</p>
    <p class="">Once again, we backtraced the path that led us to the optimal value.</p>
    <p class="line_zh">我们再一次回溯了导致我们达到最佳价值的道路。</p>
    <p class="">Here, what is shown here, is that we decided to use the first item and the third item.</p>
    <p class="line_zh">这里显示的是，我们决定使用第一项和第三项。</p>
    <p class="">So let's check that it indeed gives us the optimal value of 46.</p>
    <p class="line_zh">所以让我们检查它确实给了我们46的最佳值。</p>
    <p class="">So indeed if we compute the sum of the weight of the first and the third item, it is 10.</p>
    <p class="line_zh">所以如果我们计算第一个和第三个项目的权重之和，那么它确实是10。</p>
    <p class="">And while the total value is 30 plus 16 which is 46 indeed.</p>
    <p class="line_zh">而总值是30加16，实际上是46。</p>
    <p class="">And as I said before this technique is usually used in dynamic programming algorithms to reconstruct the optimal solution.</p>
    <p class="line_zh">正如我之前所说，这种技术通常用于动态编程算法中，以重建最优解。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 56 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_56">第04章 final remarks
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">04最后的评论</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">We conclude this lesson with a few important remarks.</p>
    <p class="line_zh">我们以一些重要的评论结束本课。</p>
    <p class="">The first remark is about a trick called memoization.</p>
    <p class="line_zh">第一个评论是关于一个叫做memoization的技巧。</p>
    <p class="">Usually when designing a dynamic program and algorithm, you start with analyzing the structure of an optimal solution
        for your computational problem.</p>
    <p class="line_zh">通常在设计动态程序和算法时，首先要分析计算问题的最佳解决方案的结构。</p>
    <p class="">You do this to come up with the right definition of a sub-problem that will allow you to express the solution for a sub-problem
        through solutions for smaller sub-sub-problems.</p>
    <p class="line_zh">您这样做是为了提出一个子问题的正确定义，它允许您通过解决较小子问题的解决方案来表达子问题的解决方案。</p>
    <p class="">So, when you write down this recurrence relation you can actually transform it to an ISA alternative algorithm or a recursive
        algorithm.
    </p>
    <p class="line_zh">因此，当您记下此递归关系时，您实际上可以将其转换为ISA替代算法或递归算法。</p>
    <p class="">The corresponding i 20 algorithm just solves all sub-problems, going from smaller ones to larger ones.</p>
    <p class="line_zh">相应的i 20算法只解决了所有子问题，从较小的问题到较大的问题。</p>
    <p class="">And for this reason it is also sometimes called a bottom up algorithm.</p>
    <p class="line_zh">因此，它有时也称为自下而上算法。</p>
    <p class="">On the other hand, the recursive algorithm to solve a sub-problem makes recursive calls to smaller sub-sub-problems.</p>
    <p class="line_zh">另一方面，解决子问题的递归算法会对较小的子子问题进行递归调用。</p>
    <p class="">And for this reason it is sometimes called the top down approach.</p>
    <p class="line_zh">因此，它有时被称为自上而下的方法。</p>
    <p class="">Well if you implement a recursive algorithms straightforwardly it might turn out to be very slow because it will recompute
        some radius many, many, many times.</p>
    <p class="line_zh">好吧，如果你直接实现一个递归算法，它可能会变得非常慢，因为它将重新计算许多，很多次的半径。</p>
    <p class="">Like with three-dimensional numbers for example.</p>
    <p class="line_zh">例如，与三维数字一样。</p>
    <p class="">However, there is a simple trick, and it is called memorization, that allows you to avoid re-computing many times the
        same thing.</p>
    <p class="line_zh">然而，有一个简单的技巧，它被称为记忆，它允许你避免重复计算多次相同的事情。</p>
    <p class="">Namely, you can do the following, when solving sub-problems, right after solving it you store its solution into a table,
        for example.</p>
    <p class="line_zh">也就是说，在解决子问题时，您可以执行以下操作，解决后立即将解决方案存储到表中。</p>
    <p class="">And when you make a recursive call to solve some sub-problem, before trying to solve it, you check in a table whether
        its solution is already stored.</p>
    <p class="line_zh">当您进行递归调用以解决某些子问题时，在尝试解决之前，您可以在表中检查其解决方案是否已存储。</p>
    <p class="">And if its solution is already in the table which means that it was already computed then you just return it immediately.</p>
    <p class="line_zh">如果它的解决方案已经在表中，这意味着它已经计算过，那么你只需立即返回它。</p>
    <p class="">So this recursive call, turns out to be just a table look up.</p>
    <p class="line_zh">所以这个递归调用，结果只是一个表查找。</p>
    <p class="">So this is how a recursive algorithm with memoization works.</p>
    <p class="line_zh">这就是具有memoization的递归算法的工作原理。</p>
    <p class="">Let's see how a recursive algorithm with memoization for the Knapsack problem looks like.</p>
    <p class="line_zh">让我们看一下带背包问题的记忆的递归算法是怎样的。</p>
    <p class="">For simplicity let's assume that we're talking about the Knapsack we use repetitions.</p>
    <p class="line_zh">为简单起见，我们假设我们正在谈论我们使用重复的背包。</p>
    <p class="">In this case, we need to compute our sub-problem for a Knapsack of size w, is just the optimal rate of a Knapsack of
        total weight w.</p>
    <p class="line_zh">在这种情况下，我们需要为大小为w的背包计算我们的子问题，这只是总重量w的背包的最佳速率。</p>
    <p class="">So we computed as follows, we computed by recursive procedure.</p>
    <p class="line_zh">所以我们计算如下，我们通过递归程序计算。</p>
    <p class="">First of all, we check whether its solution is already in a hash table.</p>
    <p class="line_zh">首先，我们检查其解决方案是否已经在哈希表中。</p>
    <p class="">We use hash table to store pairs of objects.</p>
    <p class="line_zh">我们使用哈希表来存储对象对。</p>
    <p class="">So, for weight w, we store value of w if it is already computed.</p>
    <p class="line_zh">因此，对于权重w，如果已经计算了w，则存储w的值。</p>
    <p class="">If it is already in the table, we return it immediately, otherwise we just compute it and we make recursive calls to
        compute the values for the sub-problem on w minus wi, okay? And when the value is computed, we just store it in our
        hash table.</p>
    <p class="line_zh">如果它已经在表中，我们立即返回它，否则我们只是计算它并且我们进行递归调用来计算w减去wi上的子问题的值，好吗？当计算值时，我们只将它存储在哈希表中。</p>
    <p class="">So this way, we use memoization by storing this in the hash table to avoid recomputing the same thing once again.</p>
    <p class="line_zh">所以这样，我们通过将它存储在哈希表中来使用memoization，以避免再次重新计算同一个东西。</p>
    <p class="">So once again, an iterative algorithm solves all sub-problems going from smaller ones to larger ones, right? And eventually
        solves the initial problem.</p>
    <p class="line_zh">再一次，迭代算法解决了从较小的问题到较大的子问题，对吧？并最终解决了最初的问题。</p>
    <p class="">On the other hand the recursive algorithm goes as follows.</p>
    <p class="line_zh">另一方面，递归算法如下。</p>
    <p class="">So it stars from the initial problem and it makes recursive calls to smaller sub-sub-problems, right? So in some sense
        an iterative algorithm and the recursive algorithm are doing the same job, especially if we need to solve just old
        range of sub-problems.</p>
    <p class="line_zh">所以它从最初的问题出发，它会对较小的子子问题进行递归调用，对吧？所以在某种意义上，迭代算法和递归算法正在做同样的工作，特别是如果我们需要解决旧范围的子问题。</p>
    <p class="">However, a recursive algorithm might turn to be slightly slower because it solves the same sub-problems on one hand.</p>
    <p class="line_zh">但是，递归算法可能会稍微变慢，因为它一方面解决了相同的子问题。</p>
    <p class="">On the other hand, when making a recursive call you also need to put the return address on stamp, for example.</p>
    <p class="line_zh">另一方面，在进行递归调用时，您还需要将返回地址放在戳记上。</p>
    <p class="">So, the recursive algorithm has some overhead.</p>
    <p class="line_zh">因此，递归算法有一些开销。</p>
    <p class="">There are however cases when you do not need to solve all the sub-problems and the Knapsack problem is nice illustration
        of this situation.</p>
    <p class="line_zh">但是有些情况下你不需要解决所有子问题，而背包问题很好地说明了这种情况。</p>
    <p class="">So, imagine that we are given an input to the Knapsack problem where all the weight of n items together with total weight
        of the Knapsack are divisible by 100, for example.</p>
    <p class="line_zh">因此，假设我们得到了背包问题的输入，例如，n个物品的所有重量以及背包的总重量可以被100整除。</p>
    <p class="">This means that we are actually not interested in sub-problems where the weight of the knapsack is not divisible by 100,
        why is that? Well just because for any subset of items since all the weight of items is divisible by 100 their total
        weight is also divisible by 100.</p>
    <p class="line_zh">这意味着我们实际上对背包的重量不能被100整除的子问题不感兴趣，为什么呢？好吧，因为对于任何项目的子集，因为项目的所有权重都可以被100整除，所以它们的总权重也可以被100整除。</p>
    <p class="">So in this case an iterative algorithm still will solve just whole range of sub-problems.</p>
    <p class="line_zh">因此，在这种情况下，迭代算法仍将解决整个范围的子问题。</p>
    <p class="">While a recursive algorithm will make only those recursive calls that I actually needed to compute the final solution.</p>
    <p class="line_zh">虽然递归算法只会产生我实际需要计算最终解决方案的递归调用。</p>
    <p class="">So, it will make only recursive course through sub-problems whose weight are divisible by 100.</p>
    <p class="line_zh">因此，它只会通过子问题进行递归过程，子问题的权重可以被100整除。</p>
    <p class="">The final remark of this lesson is about the running time.</p>
    <p class="line_zh">本课的最后一点是关于运行时间。</p>
    <p class="">So if you remember the running time of words that we recently designed in this lesson was the log of n multiplied by
        w.
    </p>
    <p class="line_zh">因此，如果您还记得我们最近在本课程中设计的单词的运行时间是n的对数乘以w。</p>
    <p class="">And this running time looks like polynomial, however it is not.</p>
    <p class="line_zh">而这个运行时间看起来像多项式，但事实并非如此。</p>
    <p class="">And this is why, so consider for example, the following input.</p>
    <p class="line_zh">这就是为什么，例如，考虑以下输入。</p>
    <p class="">I mean, I assume that the total weight of the knapsack is as shown on this slide.</p>
    <p class="line_zh">我的意思是，我认为背包的总重量如此幻灯片所示。</p>
    <p class="">This is a very huge number, roughly ten to the 20, I mean 20 digits of decimal representation.</p>
    <p class="line_zh">这是一个非常庞大的数字，大约十到二十，我的意思是20位数的十进制表示。</p>
    <p class="">At the same time, the input size is really tiny, just 20 digits, right? So this is not gigabytes of data, just 20 digits
        but on this input already our algorithm will need to perform roughly ten to the 20 operations.</p>
    <p class="line_zh">同时，输入尺寸非常小，只有20位数，对吗？所以这不是千兆字节的数据，只有20位，但在这个输入上我们的算法需要执行大约10到20次操作。</p>
    <p class="">This is really huge, for example we can't do this on our laptops, and this is because to represent the value of W, we
        only need log W digits.</p>
    <p class="line_zh">这真的很大，例如我们不能在我们的笔记本电脑上执行此操作，这是因为要表示W的值，我们只需要日志W数字。</p>
    <p class="">So, in case of the Knapsack problem, our input is proportional not to n plus W, but to n plus log W.</p>
    <p class="">因此，在背包问题的情况下，我们的输入与n加W成比例，但是对n加上log W.</p>
    <p class="">Okay, and if you represent the running time in terms of n and log W, then you get the following expression, n multiplied
        by 2 to the log W, which means that our algorithm is in fact exponential time algorithm.</p>
    <p class="line_zh">好的，如果你用n和log W表示运行时间，那么你得到以下表达式，n乘以2到log W，这意味着我们的算法实际上是指数时间算法。</p>
    <p class="">Put it otherwise, it can only process inputs where W is not large enough, it's roughly less than 1 billion, for example.</p>
    <p class="line_zh">换句话说，它只能处理W不够大的输入，例如，它大约不到10亿。</p>
    <p class="">Okay, and in fact, we believe that it is very difficult to construct an algorithm that will solve this problem in polynomial
        time, in truly polynomial time.</p>
    <p class="line_zh">好的，事实上，我们认为在真正的多项式时间内构造一个能在多项式时间内解决这个问题的算法是非常困难的。</p>
    <p class="">In particular, we will learn later in this presentation that this problem is considered to be so difficult that for solving
        the Knapsack problem for example, in polynomial time, one gets $1 million.</p>
    <p class="line_zh">特别是，我们将在本演示文稿的后面部分了解到，这个问题被认为是如此困难，以至于解决背包问题，例如，在多项式时间内，人们得到100万美元。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 57 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_57">第01章 problem overview
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">01问题概述</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">Hello, and welcome to the next lesson in the dynamic programming module.</p>
    <p class="line_zh">您好，欢迎来到动态编程模块的下一课。</p>
    <p class="">In this lesson, we will be applying the dynamic programming technique for solving a wide range of problems where your
        goal is to find an optimal order of something.</p>
    <p class="line_zh">在本课中，我们将应用动态编程技术来解决各种问题，您的目标是找到最佳的某种顺序。</p>
    <p class="">We will illustrate this technique by solving the so-called placing parentheses problem.</p>
    <p class="line_zh">我们将通过解决所谓的放置括号问题来说明这种技术。</p>
    <p class="">In this problem, your input is an arithmetic expression consisting of numbers or digits and arithmetic operations, and
        your goal is to find an order of applying these arithmetic operations that maximizes the radian.</p>
    <p class="line_zh">在这个问题中，您的输入是一个由数字或数字和算术运算组成的算术表达式，您的目标是找到应用这些最大化弧度的算术运算的顺序。</p>
    <p class="">You specify this order by placing parentheses, and that's why the problem is called placing parentheses.</p>
    <p class="line_zh">您可以通过放置括号来指定此顺序，这就是问题被称为放置括号的原因。</p>
    <p class="">As usual we start with problem overview.</p>
    <p class="line_zh">像往常一样，我们从问题概述开始。</p>
    <p class="">Consider the following toy arithmetic expression.</p>
    <p class="line_zh">考虑以下玩具算术表达式。</p>
    <p class="">1 + 2- 3 x 4- 5.</p>
    <p class="line_zh">1 + 2- 3 x 4-5。</p>
    <p class="">In this case we have five digits and four arithmetic operations.</p>
    <p class="line_zh">在这种情况下，我们有五个数字和四个算术运算。</p>
    <p class="">And we would like to find an order of applying these four arithmetic operations to maximize the value of this expression.</p>
    <p class="line_zh">我们希望找到应用这四个算术运算的顺序，以最大化此表达式的值。</p>
    <p class="">So when the order of operation is fixed, you do the following.</p>
    <p class="line_zh">因此，当操作顺序修复时，您将执行以下操作。</p>
    <p class="">You take the first operation.</p>
    <p class="line_zh">你进行了第一次操作。</p>
    <p class="">You take two adjusting digits, and you apply these operations.</p>
    <p class="line_zh">您可以使用两个调整数字，然后应用这些操作。</p>
    <p class="">For example, if the operation is multiplication, in this case, so then two digits are 3 and 4.</p>
    <p class="line_zh">例如，如果操作是乘法，在这种情况下，那么两个数字是3和4。</p>
    <p class="">So you multiply 3 and 4, you get 12, and you just replace 3 times 4 by 12.</p>
    <p class="line_zh">所以你乘以3和4，得到12，你只需要将4乘以3乘以12。</p>
    <p class="">You then take the next operation, apply it also, and replace two numbers and the arithmetic sign by this result, until
        you proceed in a similar fashion.</p>
    <p class="line_zh">然后，您接下来的操作，也应用它，并用此结果替换两个数字和算术符号，直到您以类似的方式继续。</p>
    <p class="">In the end here, you get a single number.</p>
    <p class="line_zh">最后，你得到一个号码。</p>
    <p class="">And your goal is to find an order that guarantees that this number is as large as possible.</p>
    <p class="line_zh">您的目标是找到一个保证这个数字尽可能大的订单。</p>
    <p class="">You can specify an order just by placing a set of parentheses in your expression.</p>
    <p class="line_zh">您只需在表达式中放置一组括号即可指定顺序。</p>
    <p class="">For example, if you would like to apply all your four operations just from left to right, you place the parentheses as
        follows.
    </p>
    <p class="line_zh">例如，如果您想从左到右应用所有四个操作，请按如下方式放置括号。</p>
    <p class="">In this particular case, we compute the results as follows.</p>
    <p class="line_zh">在这种特殊情况下，我们计算结果如下。</p>
    <p class="">So we first compute 1 + 2, this is 3.</p>
    <p class="line_zh">所以我们先计算1 + 2，这是3。</p>
    <p class="">We then subtract 3 from the results.</p>
    <p class="line_zh">然后我们从结果中减去3。</p>
    <p class="">This gives us 0.</p>
    <p class="line_zh">这给了我们0。</p>
    <p class="">We then multiply the result by 4.</p>
    <p class="line_zh">然后我们将结果乘以4。</p>
    <p class="">This is still 0.</p>
    <p class="line_zh">这仍然是0。</p>
    <p class="">And finally, we subtract 5.</p>
    <p class="line_zh">最后，我们减去5。</p>
    <p class="">So this gives us -5.</p>
    <p class="line_zh">所以这给了我们-5。</p>
    <p class="">And this is actually non-optimal, because for example, there is a better order.</p>
    <p class="line_zh">这实际上并非非最佳，因为例如，订单更好。</p>
    <p class="">In this case, we first multiply 3 and 4, this gives us 12.</p>
    <p class="line_zh">在这种情况下，我们首先乘以3和4，这给我们12。</p>
    <p class="">We then subtract 5, this gives us 7.</p>
    <p class="line_zh">然后我们减去5，这给了我们7。</p>
    <p class="">Then we go to compute the sum of 1 and 2, this gives us 3.</p>
    <p class="line_zh">然后我们去计算1和2之和，这给了我们3。</p>
    <p class="">So when the final operation is subtraction, we subtract 7 from 3.</p>
    <p class="line_zh">所以当最后的操作是减法时，我们从3中减去7。</p>
    <p class="">This gives us -4.</p>
    <p class="line_zh">这给了我们-4。</p>
    <p class="">So in this case the order of applying operations was the following.</p>
    <p class="line_zh">因此，在这种情况下，应用操作的顺序如下。</p>
    <p class="">So we first compute the product of 3 and 4, so this is the first operation.</p>
    <p class="line_zh">所以我们首先计算3和4的乘积，所以这是第一次操作。</p>
    <p class="">We then subtract 5.</p>
    <p class="line_zh">然后我们减去5。</p>
    <p class="">This is the second operation.</p>
    <p class="line_zh">这是第二次操作。</p>
    <p class="">We then compute the result of 1 + 2.</p>
    <p class="line_zh">然后我们计算1 + 2的结果。</p>
    <p class="">So this plus is the third operation, and this minus is the fourth operation, the last one.</p>
    <p class="line_zh">所以这个加号是第三个操作，这个减号是第四个操作，最后一个操作。</p>
    <p class="">It is not difficult to see that the optimal value in this case is equal to 6.</p>
    <p class="line_zh">在这种情况下，不难看出最佳值等于6。</p>
    <p class="">And it can be obtained as follows.</p>
    <p class="line_zh">它可以如下获得。</p>
    <p class="">You first subtract 5 from 4.</p>
    <p class="line_zh">你首先从4中减去5。</p>
    <p class="">This gives you -1.</p>
    <p class="line_zh">这给你-1。</p>
    <p class="">You then multiply it by 3, and you get -3.</p>
    <p class="line_zh">然后你将它乘以3，你得到-3。</p>
    <p class="">You then compute the sum of the first two digits.</p>
    <p class="line_zh">然后计算前两位数的总和。</p>
    <p class="">This is 1 + 2, and that is equal to 3.</p>
    <p class="line_zh">这是1 + 2，等于3。</p>
    <p class="">Finally you subtract -3 from 3.</p>
    <p class="line_zh">最后你从3中减去-3。</p>
    <p class="">This is the same as 3 + 3, it is equal to 6.</p>
    <p class="line_zh">这与3 + 3相同，等于6。</p>
    <p class="">Well, you might find the result as follows, you just go through all possible orders.</p>
    <p class="line_zh">好吧，你可能会发现如下结果，你只需要完成所有可能的订单。</p>
    <p class="">Let's see how many different orders are there.</p>
    <p class="line_zh">让我们看看有多少不同的订单。</p>
    <p class="">Well, there are four arithmetic operations in this case, so you can choose any of the four possible arithmetic operations
        to be the first one.</p>
    <p class="line_zh">那么，在这种情况下有四种算术运算，因此您可以选择四种可能的算术运算中的任何一种作为第一种算术运算。</p>
    <p class="">You can choose any of these three remaining operations to be the second one, and you can select any of the two remaining
        operations to be the third one.</p>
    <p class="line_zh">您可以选择这三个剩余操作中的任何一个作为第二个操作，并且您可以选择剩下的两个操作中的任何一个作为第三个操作。</p>
    <p class="">And the last one is unique, it is the only remaining operations.</p>
    <p class="line_zh">最后一个是独一无二的，它是唯一剩下的操作。</p>
    <p class="">So, in total, there are 4 by 3 by 2 by 1 different orders.</p>
    <p class="line_zh">因此，总共有4乘3乘2乘1的不同订单。</p>
    <p class="">This is equal to 24, and you can just enumerate all of them, write them down, compute an answer for each of these orderings
        and select the maximal value.</p>
    <p class="line_zh">这等于24，您可以枚举所有这些，将它们写下来，计算每个排序的答案并选择最大值。</p>
    <p class="">However, our method of going through all possible orderings does not scale well.</p>
    <p class="line_zh">但是，我们通过所有可能的排序的方法不能很好地扩展。</p>
    <p class="">And this is why.</p>
    <p class="line_zh">这就是原因。</p>
    <p class="">Consider the toy example shown on the slide.</p>
    <p class="line_zh">考虑幻灯片上显示的玩具示例。</p>
    <p class="">In this case we have six digits and five arithmetic operations.</p>
    <p class="line_zh">在这种情况下，我们有六位数和五个算术运算。</p>
    <p class="">This example will require us to go through all possible 120 orderings.</p>
    <p class="line_zh">这个例子将要求我们完成所有可能的120次排序。</p>
    <p class="">So just because there are five iterations, so any of five of them can be the first one, any of the remaining four of
        them can be the second one, and so on.</p>
    <p class="line_zh">因为有五次迭代，所以其中五个中的任何一个都可以是第一个，剩下的四个中的任何一个都可以是第二个，依此类推。</p>
    <p class="">So this is 5 by 4 by 3 by 2 by 1, which is equal to 120.</p>
    <p class="line_zh">所以这是5乘4乘3乘2乘以等于120。</p>
    <p class="">This is already not so easy to do this by hand.</p>
    <p class="line_zh">手动这已经不是那么容易了。</p>
    <p class="">I mean, to go through all possible such orderings.</p>
    <p class="line_zh">我的意思是，要经历所有可能的这样的排序。</p>
    <p class="">Well, this is not easy, but we can teach a computer to do this, right? So we can implement an algorithm that goes through
        all possible orderings.</p>
    <p class="line_zh">嗯，这并不容易，但我们可以教电脑来做这件事，对吗？因此，我们可以实现一个贯穿所有可能排序的算法。</p>
    <p class="">However, in general, this algorithm will perform roughly n factorial steps, where n is the number of arithmetic operations,
        for exactly the same reason.</p>
    <p class="line_zh">但是，通常，该算法将执行大致n个阶乘步骤，其中n是算术运算的数量，原因完全相同。</p>
    <p class="">If you have n arithmetic operations, then any of them can be the first one.</p>
    <p class="line_zh">如果你有n个算术运算，那么它们中的任何一个都可以是第一个。</p>
    <p class="">Any of the remaining n minus 1 operations can be the second one, and so on.</p>
    <p class="line_zh">任何剩余的n减1操作可以是第二个操作，依此类推。</p>
    <p class="">So this is n times n minus 1, times n minus 2, and so on.</p>
    <p class="line_zh">所以这是n次n减1，乘以n减2，依此类推。</p>
    <p class="">This is equal n factorial, and n factorial is an extremely fastly growing function.</p>
    <p class="line_zh">这与n因子相等，并且n阶乘是一种极其快速增长的函数。</p>
    <p class="">For example, 20 factorial already equals roughly 2 times 10 to the 18.</p>
    <p class="line_zh">例如，20阶乘已经等于18的10倍大约2倍。</p>
    <p class="">This means that if you implement such an algorithm, it will not be able to compute the maximum value of an expression
        consisting of just 20 digits in a reasonable time, even in one year, not to say about one second.</p>
    <p class="line_zh">这意味着如果您实现这样的算法，它将无法计算在合理时间内仅包含20位数的表达式的最大值，即使在一年内，也就是说大约一秒钟。</p>
    <p class="">Which means, as usual, that we need another algorithm, as you might well have guessed.</p>
    <p class="line_zh">像往常一样，这意味着我们需要另一种算法，您可能已经猜到了。</p>
    <p class="">We will use dynamic programming to find, to design a more efficient algorithm.</p>
    <p class="line_zh">我们将使用动态编程来查找，设计更高效的算法。</p>
    <p class="">In the meantime, you might want to check your intuition by trying a few possible orderings to perform in this small expression,
        and by using our in video quiz.</p>
    <p class="line_zh">与此同时，您可能希望通过尝试在这个小表达式中执行一些可能的排序来检查您的直觉，并使用我们的视频测验。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 58 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_58">第02章 subproblems
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">02子问题</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">As usual, we start designing our dynamic program in algorithm by defining a subproblem in a way that allows us to solve
        a subproblem by solving smaller sub subproblem.</p>
    <p class="line_zh">像往常一样，我们开始在算法中设计动态程序，方法是通过定义子问题，使我们能够通过求解较小的子子问题来解决子问题。</p>
    <p class="">As we said already, this is probably the most important step in designing dynamic programming solutions.</p>
    <p class="line_zh">正如我们已经说过的，这可能是设计动态编程解决方案中最重要的一步。</p>
    <p class="">So before doing this, we define our problem formally.</p>
    <p class="line_zh">所以在此之前，我们正式定义了我们的问题。</p>
    <p class="">So the input consists of n digits.</p>
    <p class="line_zh">所以输入由n个数字组成。</p>
    <p class="">d1, d2, and so on, dn.</p>
    <p class="line_zh">d1，d2等，dn。</p>
    <p class="">And then -1 operations between them, which we call op1, op2, and so on, opn.</p>
    <p class="line_zh">然后在它们之间进行-1操作，我们称之为op1，op2等，opn。</p>
    <p class="">Each operation is either summation, subtraction, or multiplication.</p>
    <p class="line_zh">每个操作都是求和，减法或乘法。</p>
    <p class="">And our goal is to find an order of applying these operations so that the value of the resulting expression is maximized.</p>
    <p class="line_zh">我们的目标是找到应用这些操作的顺序，以便最大化结果表达式的值。</p>
    <p class="">As we discussed already, we can specify this order just by placing parentheses into our expression.</p>
    <p class="line_zh">正如我们已经讨论的那样，我们可以通过将括号放入表达式来指定此顺序。</p>
    <p class="">We start building our intuition by reconsidering our toy example.</p>
    <p class="line_zh">我们通过重新考虑我们的玩具示例开始建立我们的直觉。</p>
    <p class="">So assume that the multiplication is the last operation in some optimal ordering in an ordering leading to an optimal
        value in this toy example.</p>
    <p class="line_zh">因此，假设乘法是在该玩具示例中导致最佳值的排序中的某个最佳排序中的最后一个操作。</p>
    <p class="">Well this means that in this expression we already have to pairs of parentheses.</p>
    <p class="line_zh">嗯，这意味着在这个表达式中我们已经有了成对的括号。</p>
    <p class="">And our goal is to parenthesize the initial sub-expression and the second sub-expression, so as to maximize the value.</p>
    <p class="line_zh">我们的目标是将初始子表达式和第二个子表达式括起来，以便最大化该值。</p>
    <p class="">This means that it would be good for us to know what is an optimal value for the first subexpression and the second subexpression,
        right? And in general if you have an expression and if you select a realistic operation, which is the last one, then
        it splits your initial expression into two subexpressions, right? And for both of them it would be good to know an
        optimal value.</p>
    <p class="line_zh">这意味着我们知道第一个子表达式和第二个子表达式的最佳值是对的，对吧？一般来说，如果你有一个表达式，如果你选择一个真实的操作，这是最后一个，那么它将你的初始表达式分成两个子表达式，对吧？对于他们两个人来说，了解最佳价值会很好。</p>
    <p class="">And, in turn, each of these two subexpressions are split into two sub subexpressions by the last arithmetic operations,
        and so on.</p>
    <p class="line_zh">反过来，这两个子表达式中的每一个都通过最后的算术运算分成两个子子表达式，依此类推。</p>
    <p class="">So this suggests Very good problem in our case would be find an optimal value for any subexpression or former initial
        expression.
    </p>
    <p class="line_zh">所以这表明在我们的案例中非常好的问题是找到任何子表达式或前初始表达式的最佳值。</p>
    <p class="">So we've just realized that it would be good to know the optimal values for all subexpressions of our initial expression.</p>
    <p class="line_zh">所以我们刚刚意识到，了解初始表达式的所有子表达式的最佳值会很好。</p>
    <p class="">What do we mean however, by saying optimal values for all subexpressions? Assume for example that we need to compute
        the optimal, the maximal value for the sum of two subexpressions, subexpression one and subexpression two.</p>
    <p class="line_zh">但是，通过说出所有子表达式的最佳值，我们的意思是什么？例如，假设我们需要计算两个子表达式，子表达式1和子表达式2之和的最优值，最大值。</p>
    <p class="">Well this obviously means that we would like this subexpression to be as large as possible and this subexpression to
        be as large as possible.</p>
    <p class="line_zh">嗯，这显然意味着我们希望这个子表达式尽可能大，并且这个子表达式尽可能大。</p>
    <p class="">If on the other hand we would like to compute the maximum value of subexpression one minus subexpression two.</p>
    <p class="line_zh">另一方面，如果我们想计算子表达式的最大值减去子表达式2。</p>
    <p class="">Well this means that we would like subexpression one to be as large as possible while we would like the value of subexpression
        two to be as small as possible, right? Just because we compute subexpression one minus subexpression two.</p>
    <p class="line_zh">嗯，这意味着我们希望子表达式尽可能大，而我们希望子表达式2的值尽可能小，对吧？仅仅因为我们计算子表达式一减去子表达式二。</p>
    <p class="">This suggests that knowing just the maximal value for each subexpression would not be enough.</p>
    <p class="line_zh">这表明只知道每个子表达式的最大值是不够的。</p>
    <p class="">And this usually happens when designing a dynamic programming solution.</p>
    <p class="line_zh">这通常发生在设计动态编程解决方案时。</p>
    <p class="">This also suggests that, instead of computing just maximal, we will maintain what is the maximum value and the minimum
        possible value for each subexpression.</p>
    <p class="line_zh">这也表明，我们将维持每个子表达式的最大值和最小可能值，而不是仅计算最大值。</p>
    <p class="">Let's illustrate this reasoning once again with our previous toy example.</p>
    <p class="line_zh">让我们再次用我们之前的玩具示例来说明这种推理。</p>
    <p class="">So in this case we are maximizing the product of two small subexpressions.</p>
    <p class="line_zh">所以在这种情况下，我们正在最大化两个小子表达式的乘积。</p>
    <p class="">In this case these two subexpressions, so small, that it is not difficult to compute their minimal and maximal values.</p>
    <p class="line_zh">在这种情况下，这两个子表达式如此之小，以至于计算它们的最小值和最大值并不困难。</p>
    <p class="">For example, for subexpression 5- 8 + 7, the minimum value is- 10 and the maximal value is 4, right? At the same time,
        for the second subexpression, (4-(8+9)), the minimum value is- 13, while the maximum value is 5, right? Now we would
        like to parenthesis both subexpressions, so that their product is maximal.</p>
    <p class="line_zh">例如，对于子表达式5-8 + 7，最小值为-10，最大值为4，对吧？同时，对于第二个子表达式（4-（8 + 9）），最小值为-13，而最大值为5，对吧？现在我们想要括号表示两个子表达式，以便它们的产品是最大的。</p>
    <p class="">Well it is not difficult to see, that in this case the optimal way to do this is to take the minimal values of both sub
        expressions, right? So this will give us- 10 multiplied by -13, which is equal to 130.</p>
    <p class="line_zh">嗯，不难看出，在这种情况下，最好的方法是采用两个子表达式的最小值，对吧？所以这将给我们-10乘以-13，等于130。</p>
    <p class="">Right? Which is much larger than the product of the maximum values of these two sub expressions which is 4 by 5, which
        is 20 in turn.</p>
    <p class="line_zh">对？这远远大于这两个子表达式的最大值的乘积，即4乘5，其依次为20。</p>
    <p class="">Okay, we are now ready to write down the recurrent relation for our subproblems.</p>
    <p class="line_zh">好的，我们现在准备写下我们子问题的循环关系。</p>
    <p class="">Before this, let's formally define E of ij to be the subexpression of our initial expression resulting by taking digits
        from i to j and all operations between them.</p>
    <p class="line_zh">在此之前，让我们正式定义i的E是我们初始表达式的子表达式，这是通过从i到j以及它们之间的所有操作获取数字。</p>
    <p class="">Then our goal is to compute the maximum value of the subexpression which we denote by capital M(i,j) and the minimum
        value of the sub expression denoted by m(i,j).</p>
    <p class="line_zh">然后我们的目标是计算子表达式的最大值，我们用大写M（i，j）表示子表达式的最大值，用m（i，j）表示子表达式的最小值。</p>
    <p class="">Okay, can you see that our initial subexpression from I to J and assumes that we would like to compute one of the extreme
        values of the subexpression and implies there is a minimum or the maximum.</p>
    <p class="line_zh">好的，你能看到我们从I到J的初始子表达式并假设我们想要计算子表达式的一个极值并暗示存在最小值或最大值。</p>
    <p class="">Well we know that in many ordering for this subexpression there is some last operation, say okay so this separation splits
        our initial subexpression into two sub subexpression namely, subexpression i, k and subexpression k plus 1j.</p>
    <p class="line_zh">我们知道在这个子表达式的许多顺序中有一些最后的操作，说好吧所以这个分离将我们的初始子表达式分成两个子子表达式，即子表达式i，k和子表达式k加1j。</p>
    <p class="">Right? To compute the maximum value, we just go through all possible such case, from i to j- 1, and through all possible
        extreme values for two subexpressions.</p>
    <p class="line_zh">对？为了计算最大值，我们只需要经历所有可能的情况，从i到j-1，以及两个子表达式的所有可能的极值。</p>
    <p class="">I mean, either we apply operation k to the maximum values of these two subexpressions or we apply operation K to minimum
        value, the minimum values of these two subexpressions.</p>
    <p class="line_zh">我的意思是，要么将操作k应用于这两个子表达式的最大值，要么将操作K应用于最小值，即这两个子表达式的最小值。</p>
    <p class="">Or we apply it to the maximum value of one subexpression and the minimum value of another or vice versa.</p>
    <p class="line_zh">或者我们将其应用于一个子表达式的最大值和另一个子表达式的最小值，反之亦然。</p>
    <p class="">To compute the maximum value of sub expression i j, we just select the maximum among all these possibilities.</p>
    <p class="line_zh">为了计算子表达式ij的最大值，我们只选择所有这些可能性中的最大值。</p>
    <p class="">While to compute it's minimum value, we simply select the minimum among all such possibilities.</p>
    <p class="line_zh">在计算它的最小值时，我们只需在所有这些可能性中选择最小值。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 59 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_59">第03章 algorithm
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">03算法</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">We now convert our recurrence relation into a dynamic programming algorithm.</p>
    <p class="line_zh">我们现在将递归关系转换为动态编程算法。</p>
    <p class="">We start by implementing a procedure that computes the minimum and maximum value of the subexpression (i,j) through optimal
        values for smaller sub subexpressions.</p>
    <p class="line_zh">我们首先实现一个过程，该过程通过较小子子表达式的最佳值来计算子表达式（i，j）的最小值和最大值。</p>
    <p class="">So the procedure is called MinAndMax(i,j).</p>
    <p class="line_zh">因此，该过程称为MinAndMax（i，j）。</p>
    <p class="">So we first declared two intervals, max and min.</p>
    <p class="line_zh">所以我们首先声明了两个区间，最大值和最小值。</p>
    <p class="">Initially min is equal to plus infinity, max is equal to minus infinity, or to a very large number, or to very small
        number.
    </p>
    <p class="line_zh">最初min等于正无穷大，max等于负无穷大，或等于非常大的数，或者非常小的数。</p>
    <p class="">Then we go through all possible values of k between i and j- 1.</p>
    <p class="line_zh">然后我们遍历i和j-1之间k的所有可能值。</p>
    <p class="">I mean between, we just go through all possibilities of splitting our subexpression (i, j) into two sub subexpressions
        from i to k and from k plus 1 to j.</p>
    <p class="line_zh">我的意思是，我们只是经历了将子表达式（i，j）分成从i到k和从k加1到j的两个子子表达式的所有可能性。</p>
    <p class="">When such a splitting is fixed, we compute four possible values, applying opk to either two maximum values of this subexpression
        or two minimum values or two maximum and minimum value or two minimum and maximum value.</p>
    <p class="line_zh">当这样的分裂是固定的时，我们计算四个可能的值，将opk应用于该子表达式的两个最大值或两个最小值或两个最大值和最小值或两个最小值和最大值。</p>
    <p class="">When such two values are computed, we just check whether one of them can improve our minimum or maximum values.</p>
    <p class="line_zh">当计算这两个值时，我们只检查其中一个值是否可以改善我们的最小值或最大值。</p>
    <p class="">If it improves we update the min or max variable.</p>
    <p class="line_zh">如果它改进了，我们更新min或max变量。</p>
    <p class="">Finally we return the minimum value and the maximum value for our subexpression.</p>
    <p class="line_zh">最后，我们返回子表达式的最小值和最大值。</p>
    <p class="">Our current relation expresses the solution for an expression (i,j) for a solution for smaller sub subexpressions.</p>
    <p class="line_zh">我们当前的关系表达了​​用于较小子子表达式的解的表达式（i，j）的解。</p>
    <p class="">What do we mean by saying smaller? Well, we mean just that they are shorter, right? So once again when we compute the
        value for a subexpression (i,j) we rely on the fact that those are values for shorter subexpressions are already
        computed.
    </p>
    <p class="line_zh">说小一点是什么意思？嗯，我们的意思是它们更短，对吧？因此，当我们计算子表达式（i，j）的值时，我们再次依赖于这些事实，即已经计算了较短子表达式的值。</p>
    <p class="">This means that our algorithm needs to compute the solutions for all subproblems in order of increasing length.</p>
    <p class="line_zh">这意味着我们的算法需要按照增加的长度计算所有子问题的解。</p>
    <p class="">Namely, in order of increasing value of j minus i, right? So for this problem we have roughly quadratic number of subproblems.</p>
    <p class="line_zh">即，按j减i的值增加的顺序，对吧？因此，对于这个问题，我们有大约二次数的子问题。</p>
    <p class="">Namely our subproblem, i, i, j, is parameterized by the value of i and j which in turn range from 1 to n.</p>
    <p class="line_zh">也就是说，我们的子问题i，i，j由i和j的值参数化，而i和j的值又从1到n。</p>
    <p class="">Right, so it makes sense in this case to store the values for all subproblems in a two dimensional table of size n by
        n.
    </p>
    <p class="line_zh">是的，所以在这种情况下将所有子问题的值存储在大小为n乘n的二维表中是有意义的。</p>
    <p class="">Recall also that we need to recall our subproblems in the order of increasing value of j- 1.</p>
    <p class="line_zh">还记得我们需要按照增加j-1值的顺序回顾我们的子问题。</p>
    <p class="">We can do this just by going through all subproblems in an order shown on the slide.</p>
    <p class="line_zh">我们只需按照幻灯片上显示的顺序浏览所有子问题即可。</p>
    <p class="">So, why this order? Well this is simply because it goes through all possible values of i, j in order of increasing j
        minus y as required.</p>
    <p class="line_zh">那么，为什么这个订单呢？那么这只是因为它按照j减去y的顺序遍历i，j的所有可能值。</p>
    <p class="">So lets take a look.</p>
    <p class="line_zh">所以我们来看看吧。</p>
    <p class="">On this diagonal we have all the cells where I, where j- i is equal to 0, right? So the first cell here is 1, 1.</p>
    <p class="line_zh">在这个对角线上我们有所有的单元格，其中j- i等于0，对吗？所以这里的第一个单元格是1,1。</p>
    <p class="">The second cell is 2, 2.</p>
    <p class="line_zh">第二个细胞是2,2。</p>
    <p class="">The third cell is 3, 3 and so on.</p>
    <p class="line_zh">第三个单元格是3,3等等。</p>
    <p class="">We then proceed to this cell here i is equal to 1, j is equal to 2, so the difference is 1.</p>
    <p class="line_zh">然后我们进入这个单元格，我等于1，j等于2，所以差值为1。</p>
    <p class="">We then proceed to this cell.</p>
    <p class="line_zh">然后我们进入这个细胞。</p>
    <p class="">This is the cell 2, 3 with the difference 1 again.</p>
    <p class="line_zh">这是单元格2,3，区别为1。</p>
    <p class="">We then proceed to this cell which is 3, 4 and so on.</p>
    <p class="line_zh">然后我们进入这个3,4等的细胞。</p>
    <p class="">So on this cell we have on this diagonal we have all the cells i, j where i- j = 0.</p>
    <p class="line_zh">所以在这个细胞上，我们在这个对角线上有所有的细胞i，j，其中i-j = 0。</p>
    <p class="">On this diagonal we have all cells i, j where j- i = 1.</p>
    <p class="line_zh">在这个对角线上，我们有所有的单元格i，j，其中j-i = 1。</p>
    <p class="">For this diagonal, this difference is equal to two.</p>
    <p class="line_zh">对于这个对角线，这个差异等于2。</p>
    <p class="">For this diagonal, this difference is equal to three and so on.</p>
    <p class="line_zh">对于这个对角线，这个差异等于三，依此类推。</p>
    <p class="">The resulting value for our initial subproblem will be computed as the value of the last cell.</p>
    <p class="line_zh">我们的初始子问题的结果值将被计算为最后一个单元格的值。</p>
    <p class="">Right, because of this cell responds to the initial subexpression from one to n.</p>
    <p class="line_zh">是的，因为这个单元格响应从1到n的初始子表达式。</p>
    <p class="">Now everything is ready to write down an algorithm.</p>
    <p class="line_zh">现在一切都准备好写下算法了。</p>
    <p class="">In the algorithm we will maintain two tables, m and capital M.</p>
    <p class="">在算法中，我们将维护两个表，m和大写M.</p>
    <p class="">The first one for storing the minimum values for all subexpressions, and the second one for storing the maximum values
        for all subexpressions.</p>
    <p class="line_zh">第一个用于存储所有子表达式的最小值，第二个用于存储所有子表达式的最大值。</p>
    <p class="">We start by initializing these tables as follows.</p>
    <p class="line_zh">我们首先按如下方式初始化这些表。</p>
    <p class="">So when subexpression contains just one digit, which means that when j = i, then there is nothing, actually to minimize
        or maximize because there are no operations.</p>
    <p class="line_zh">因此，当子表达式只包含一个数字时，这意味着当j = i时，则没有任何内容，实际上是最小化或最大化，因为没有操作。</p>
    <p class="">So there is no order on operations.</p>
    <p class="line_zh">所以没有关于操作的订单。</p>
    <p class="">So, because of that we just initialize the main diagonals of this table with the most current point in digits.</p>
    <p class="line_zh">因此，我们只是使用最新的数字点来初始化此表的主对角线。</p>
    <p class="">This is with the following loop.</p>
    <p class="line_zh">这是通过以下循环。</p>
    <p class="">So m(i,i) and M(i,i) = di.</p>
    <p class="line_zh">所以m（i，i）和M（i，i）= di。</p>
    <p class="">Then we go through all possible subproblems in order of increasing size.</p>
    <p class="line_zh">然后我们按照增加的大小顺序查看所有可能的子问题。</p>
    <p class="">And this is done as follows.</p>
    <p class="line_zh">这样做如下。</p>
    <p class="">We gradually increase the parameter s from 1 to n- 1.</p>
    <p class="line_zh">我们逐渐将参数s从1增加到n-1。</p>
    <p class="">This is done in the following loop.</p>
    <p class="line_zh">这在以下循环中完成。</p>
    <p class="">When s is fixed, i goes from 1 to n- s.</p>
    <p class="line_zh">当s被修复时，我从1变为n-s。</p>
    <p class="">And j is computed as i + s.</p>
    <p class="line_zh">并且j被计算为i + s。</p>
    <p class="">This is done to go through all possible payers (i,j) such that j- i = s.</p>
    <p class="line_zh">这样做是为了通过所有可能的付款人（i，j），使得j-i = s。</p>
    <p class="">Right when i and j are fixed we call the procedure min and max to compute the minimum and maximum value of the subexpression
        (i,j).
    </p>
    <p class="line_zh">当i和j固定时，我们调用过程min和max来计算子表达式（i，j）的最小值和最大值。</p>
    <p class="">All right.</p>
    <p class="line_zh">好吧。</p>
    <p class="">So finally we return the value of capital M of 1,n as the result for our initial problem because this subexpression,
        1 n corresponds to our initial problem.</p>
    <p class="line_zh">所以最后我们返回大写M的值1，n作为我们初始问题的结果，因为这个子表达式1 n对应于我们的初始问题。</p>
    <p class="">Containing all digits from 1 to n.</p>
    <p class="line_zh">包含从1到n的所有数字。</p>
    <p class="">Okay so the running time of this algorithm is cubic.</p>
    <p class="line_zh">好的，这个算法的运行时间是立方的。</p>
    <p class="">Namely, big O of nq.</p>
    <p class="">即，nq的大O.</p>
    <p class="">And these can be seen by noting that we have two nested loops.</p>
    <p class="line_zh">通过注意我们有两个嵌套循环可以看出这些。</p>
    <p class="">The first one with n-1 iterations, the inner one is with n-s iterations, which is at most n.</p>
    <p class="line_zh">第一个是n-1次迭代，内部是n次迭代，最多为n次。</p>
    <p class="">Also, inside these two loops we have a call to min and max procedure.</p>
    <p class="line_zh">此外，在这两个循环中，我们调用了min和max过程。</p>
    <p class="">The running time of min and max procedure is proportional to j-i which is also at most n.</p>
    <p class="line_zh">最小和最大程序的运行时间与ji成比例，ji也最多为n。</p>
    <p class="">So the right end time however algorithm is it must O and n times n time n, which is n cubed.</p>
    <p class="line_zh">因此，正确的结束时间算法是必须O和n乘n次n，即n立方。</p>
    <p class="">This slide shows an example on how a table's m and capital M look like if we ran a well reason on our toy example, namely
        expression 5- 8 + 7 x 4- 8 + 9.</p>
    <p class="line_zh">这张幻灯片展示了一个例子，说明如果我们在玩具示例中运行了一个很好的理由，即表达式为5 8 + 7 x 4- 8 + 9，那么表m和大写M的外观如何。</p>
    <p class="">Let's just go through this example step by step.</p>
    <p class="line_zh">让我们一步一步地完成这个例子。</p>
    <p class="">So we start by filling in the values on the main diagonal in both matrices.</p>
    <p class="line_zh">因此，我们首先填写两个矩阵中主对角线上的值。</p>
    <p class="">So this is 5, this is 8, this is 7, this is 4, 8, 9.</p>
    <p class="line_zh">所以这是5，这是8，这是7，这是4,8,9。</p>
    <p class="">So this response to subexpression consisted of just one digit.</p>
    <p class="line_zh">因此，对子表达式的响应只包含一位数。</p>
    <p class="">So there is nothing to maximize or minimize.</p>
    <p class="line_zh">所以没有什么可以最大化或最小化。</p>
    <p class="">So we do the same for capital M matrix.</p>
    <p class="line_zh">所以我们对大写M矩阵做同样的事情。</p>
    <p class="">We then proceed to the second diagonal.</p>
    <p class="line_zh">然后我们进入第二个对角线。</p>
    <p class="">Well with -3 here and this corresponds to this subexpression again in this case there is just one operation.</p>
    <p class="line_zh">这里有-3，这对应于这个子表达式，在这种情况下只有一个操作。</p>
    <p class="">So there is nothing to minimize or maximize here, because there will just be one other when we have Just one sign.</p>
    <p class="line_zh">因此，没有什么可以在这里最小化或最大化，因为当我们只有一个符号时，只会有另一个。</p>
    <p class="">So we put -3 here this corresponds to the problem, to the subproblem one, two.</p>
    <p class="line_zh">所以我们把-3放在这里对应问题，给子问题一，二。</p>
    <p class="">Let me put all the indices here by the way.</p>
    <p class="line_zh">让我把所有指数放在这里。</p>
    <p class="">Then we proceed through the cell to 3, which corresponds to this subproblem.</p>
    <p class="line_zh">然后我们通过单元格前进到3，这对应于这个子问题。</p>
    <p class="">Again, there is nothing to maximize or minimize so we continue in the same way.</p>
    <p class="line_zh">同样，没有什么可以最大化或最小化，所以我们继续以相同的方式。</p>
    <p class="">In this case it is not so interesting and then we proceed to the third day namely to this cell.</p>
    <p class="line_zh">在这种情况下它不是那么有趣，然后我们进入第三天即到这个单元格。</p>
    <p class="">So this can respond to the subexpression 1,3 which consists of three digits and two operations, minus and plus.</p>
    <p class="line_zh">因此，这可以响应子表达式1,3，它包含三个数字和两个操作，减号和加号。</p>
    <p class="">So we know that one of them is the last operation in the optimal order when computing minimal value for example.</p>
    <p class="line_zh">因此，我们知道其中一个是计算最小值时最优顺序中的最后一个操作。</p>
    <p class="">So as soon as this is minus.</p>
    <p class="line_zh">所以一旦这是减去。</p>
    <p class="">This will split the subexpression into two sub subexpression, 5 and 8 + 7.</p>
    <p class="line_zh">这会将子表达式拆分为两个子子表达式，即5和8 + 7。</p>
    <p class="">So for both the subexpressions we already know their maximum and minimum values.</p>
    <p class="line_zh">因此，对于两个子表达式，我们已经知道它们的最大值和最小值。</p>
    <p class="">So once again, this subexpression corresponds to (1, 1), this subexpression corresponds to (2, 3).</p>
    <p class="line_zh">所以再一次，这个子表达式对应于（1,1），这个子表达式对应于（2,3）。</p>
    <p class="">Sort of from second to third digits, and third digit from first to first digit.</p>
    <p class="line_zh">从第二个到第三个数字的排序，从第一个到第一个数字的第三个数字。</p>
    <p class="">So we know that for the first subexpression we know already it's minimum value it is here, and it's maximum value, it
        is here.</p>
    <p class="line_zh">所以我们知道，对于第一个子表达式，我们已经知道它在这里的最小值，并且它是最大值，它就在这里。</p>
    <p class="">So for the second subexpression, we already know it's minimum value, it is here.</p>
    <p class="line_zh">所以对于第二个子表达式，我们已经知道它的最小值，就在这里。</p>
    <p class="">It is 15, and then its maximum value.</p>
    <p class="line_zh">它是15，然后是它的最大值。</p>
    <p class="">It is also 15.</p>
    <p class="line_zh">这也是15。</p>
    <p class="">So by going through all possible pairs of obviously maximum and minimum values, in this case, they're all the same.</p>
    <p class="line_zh">因此，通过遍历所有可能的明显最大值和最小值对，在这种情况下，它们都是相同的。</p>
    <p class="">We compute the minimum value, which is just 5- 15.</p>
    <p class="line_zh">我们计算出最小值，即5-15。</p>
    <p class="">It is minus ten.</p>
    <p class="line_zh">它是零下十。</p>
    <p class="">However, this was only the first case of splitting this sub expression into two sub expressions.</p>
    <p class="line_zh">但是，这只是将此子表达式拆分为两个子表达式的第一种情况。</p>
    <p class="">And as a possibility would be the following so we can split it into the following two subexpressions.</p>
    <p class="line_zh">并且有可能是以下因此我们可以将它分成以下两个子表达式。</p>
    <p class="">So this corresponds to 1, 2 and this corresponds to 3,3.</p>
    <p class="line_zh">所以这对应于1,2，这相当于3,3。</p>
    <p class="">Right? So, for one two we know its minimum value, it is minus three, and its maximum value, it is also minus three.</p>
    <p class="line_zh">对？所以，对于一两个，我们知道它的最小值，它是负三，它的最大值，它也是减三。</p>
    <p class="">For 3, 3 we know its maximum value.</p>
    <p class="line_zh">对于3,3，我们知道它的最大值。</p>
    <p class="">It is here, seven.</p>
    <p class="line_zh">就在这里，七点。</p>
    <p class="">Its minimum value and its maximum value.</p>
    <p class="line_zh">它的最小值和最大值。</p>
    <p class="">So then we can compute- 3 + 7, which gives us just 4.</p>
    <p class="line_zh">那么我们可以计算-3 + 7，这给我们只有4。</p>
    <p class="">So for the maximum value of the subexpression (1,3) we select 4.</p>
    <p class="line_zh">因此，对于子表达式（1,3）的最大值，我们选择4。</p>
    <p class="">For the minimum value we select -10.</p>
    <p class="line_zh">对于最小值，我们选择-10。</p>
    <p class="">So we proceed filling in this table in a similar fashion.</p>
    <p class="line_zh">所以我们以类似的方式填写此表。</p>
    <p class="">So we then put 36 here in this cell, then -20 in this cell, and then parallel we put 60 here, 20 here, and so on.</p>
    <p class="line_zh">所以我们在这个单元格中放置36，然后在这个单元格中放置-20，然后我们在这里放置60，在这里放置20，依此类推。</p>
    <p class="">So, in the end we see the value 200 here.</p>
    <p class="line_zh">所以，最后我们在这里看到值200。</p>
    <p class="">And this is the maximum value of our initial expression.</p>
    <p class="line_zh">这是我们初始表达式的最大值。</p>
    <p class="">This still doesn't give us the optimal load rate itself, but we will be able to reconstruct it from these two tables.</p>
    <p class="line_zh">这仍然没有给我们最佳的负载率本身，但我们将能够从这两个表重建它。</p>
    <p class="">Now we are sure that the maximum value of our initial expression is 200, and we will find out the optimal ordering, or
        the optimal sizing in a minute.</p>
    <p class="line_zh">现在我们确定初始表达式的最大值是200，我们将在一分钟内找到最佳排序或最佳尺寸。</p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class=""></p>
    <p class="line_aplit">------------- 60 -------------</p>
    <p class=""></p>
    <p class=""></p>
    <h3 id="chapter_60">第04章 reconstructing a solution
        <a href="./algorithmic_toolbox.html" class="to_top">#</a>
    </h3>
    <p class="">04重建解决方案</p>
    <p class=""></p>
    <p class=""></p>
    <p class="">In this last video of this lesson, we show a method of reconstructing an actual solution from two tables computed by
        our dynamic programming algorithm.</p>
    <p class="line_zh">在本课程的最后一个视频中，我们展示了一种从我们的动态编程算法计算的两个表中重建实际解决方案的方法。</p>
    <p class="">Okay, here on this slide we see two tables, m and capital M.</p>
    <p class="">好的，在这张幻灯片上我们看到两个表，m和大写M.</p>
    <p class="">Computed by our dynamic program and algorithm which contain minimal and maximal values respectively for all possible
        subexpressions of our initial expression.</p>
    <p class="line_zh">由我们的动态程序和算法计算，它们分别包含初始表达式的所有可能子表达式的最小值和最大值。</p>
    <p class="">Let me first put in this for all the rows and columns of these two matrices, as well as numbers for our initial digits.</p>
    <p class="line_zh">让我首先为这两个矩阵的所有行和列加上这个，以及我们的初始数字的数字。</p>
    <p class="">Well, in particular, we see by reading the contents of this cell capital M of (1,6) that the maximal value of our initial
        expression is equal to 200, and our goal is to unwind the whole solution, I mean, parenthesizing of the initial expression,
        from these two tables.</p>
    <p class="line_zh">好吧，特别是，我们通过读取（1,6）这个单元格大写M的内容看到我们的初始表达式的最大值等于200，我们的目标是解开整个解决方案，我的意思是，括号内的初始表达式，来自这两个表。</p>
    <p class="">So our first goal on this way is to understand from which two subexpressions of the initial expression the value 200
        was computed.</p>
    <p class="line_zh">因此，我们这样做的第一个目标是理解初始表达式的两个子表达式，即计算值200。</p>
    <p class="">Well, let's see, when computing the value for the maximal value for subexpression (1,6), we tried all possible splittings
        of the expression (1,6) into two subexpressions.</p>
    <p class="line_zh">好吧，让我们看一下，当计算子表达式（1.6）的最大值的值时，我们尝试将表达式（1,6）的所有可能的分裂分成两个子表达式。</p>
    <p class="">Well, let's just go through all of them.</p>
    <p class="line_zh">好吧，让我们来看看所有这些。</p>
    <p class="">The first possibility is to split it into two subexpressions (1,1), which corresponds just to the first digit which is
        just 5, and subexpression (2,6), with a minus sign between them, right.</p>
    <p class="line_zh">第一种可能性是将其分成两个子表达式（1,1），它们仅对应于仅为5的第一个数字，以及子表达式（2,6），它们之间带有减号，右。</p>
    <p class="">So for both these two subexpressions we already know minimal values and maximal values.</p>
    <p class="line_zh">因此，对于这两个子表达式，我们已经知道最小值和最大值。</p>
    <p class="">Well, let me mark them.</p>
    <p class="line_zh">好吧，让我标记它们。</p>
    <p class="">So this is the minimal value for the subexpression (1,1).</p>
    <p class="line_zh">所以这是子表达式（1,1）的最小值。</p>
    <p class="">This is the maximal value for subexpression (1,1).</p>
    <p class="line_zh">这是子表达式（1,1）的最大值。</p>
    <p class="">For (2,6), this is the minimal value, -195, and this is a maximal value, 75.</p>
    <p class="line_zh">对于（2,6），这是最小值，-195，这是最大值，75。</p>
    <p class="">So we would like to maximize this subexpression one minus subexpression two, which means that we would like the first
        subexpression to be as large as possible and the second subexpression to be as small as possible.</p>
    <p class="line_zh">所以我们希望最大化这个子表达式减去子表达式二，这意味着我们希望第一个子表达式尽可能大，第二个子表达式尽可能小。</p>
    <p class="">Well, this means that we need to try to take the maximal value of the first subexpression which is five and the minimal
        value of the second subexpression which is -195.</p>
    <p class="line_zh">嗯，这意味着我们需要尝试获取第一个子表达式的最大值，即第五个子表达式的最小值，即第二个子表达式的最小值，即-195。</p>
    <p class="">Well, we see that in this case, 5 minus -195 is the same as 5 plus 195, which equals exactly 200, right, which allows
        us to conclude, actually, that the value 200 can be obtained as follows.</p>
    <p class="line_zh">好吧，我们看到在这种情况下，5减去-195与5加195相同，恰好等于200，右，这使我们可以得出结论，实际上，可以如下获得值200。</p>
    <p class="">So, we subtract the minimum value which is -195 over the second subexpression from 5, right.</p>
    <p class="line_zh">因此，我们从5，右边减去第二个子表达式上的最小值-195。</p>
    <p class="">So we restored the last operation in an optimal parenthesizing of the initial expression.</p>
    <p class="line_zh">因此，我们在初始表达式的最佳括号中恢复了最后一个操作。</p>
    <p class="">However, we still need to find out how to obtain -195 out of the second subexpression.</p>
    <p class="line_zh">但是，我们仍然需要找出如何从第二个子表达式中获得-195。</p>
    <p class="">Well, let's do this.</p>
    <p class="line_zh">好吧，让我们这样做。</p>
    <p class="">Okay, so we need to find how the minimum value of the subexpression (2,6) was obtained.</p>
    <p class="line_zh">好的，我们需要找到子表达式（2,6）的最小值是如何获得的。</p>
    <p class="">Well, there are several possible splittings, once again, of the subexpression (2,6) into two smaller sub-subexpressions.</p>
    <p class="line_zh">好吧，有几种可能的子表达式（2,6）分裂成两个较小的子子表达式。</p>
    <p class="">The first of them is to split (2,6) into (2,2), which just corresponds to the digit 8 plus (3,6).</p>
    <p class="line_zh">第一个是将（2,6）分成（2,2），它恰好对应于数字8加（3,6）。</p>
    <p class="">Well, in this case, we would like the value to be as small as possible and our sign is plus in this case, which means
        that we would like the value of subexpression (2,2) to be as small as possible and the value of subexpression (3,6)
        also to be as small as possible.</p>
    <p class="line_zh">好吧，在这种情况下，我们希望值尽可能小，在这种情况下我们的符号是加号，这意味着我们希望子表达式（2,2）的值尽可能小并且值子表达式（3,6）也尽可能小。</p>
    <p class="">And you already know these values, they are in our tables, so the minimal value of subexpression (2,2) is 8, while the
        minimum value of subexpression (3, 6) is minus 91, right.</p>
    <p class="line_zh">并且您已经知道这些值，它们在我们的表中，因此子表达式（2,2）的最小值为8，而子表达式（3,6）的最小值为负91，右。</p>
    <p class="">So we see that the sum of these two values is not equal to -195, right, which means that plus is not the last operation
        in the optimal parenthesizing that gives the minimum value of subexpression (2, 6), right.</p>
    <p class="line_zh">所以我们看到这两个值的总和不等于-195，右边，这意味着plus不是最佳括号中的最后一个操作，它给出了子表达式的最小值（2,6），对。</p>
    <p class="">So let's check the next one.</p>
    <p class="line_zh">那么让我们检查下一个。</p>
    <p class="">Another possibility to split the subexpression (2, 6) is the following.</p>
    <p class="line_zh">分割子表达式（2,6）的另一种可能性如下。</p>
    <p class="">We split it into subexpression (2, 3) times subexpression (4, 6), right.</p>
    <p class="line_zh">我们将它分为次表达式（2,3）次表达式（4,6），右。</p>
    <p class="">So once again, we would like to find the minimum value of subexpression (2, 6).</p>
    <p class="line_zh">所以再一次，我们想找到子表达式的最小值（2,6）。</p>
    <p class="">Well, let's see just all possibilities.</p>
    <p class="line_zh">好吧，让我们看看所有可能性。</p>
    <p class="">The minimum value of subexpression (2, 3) is 15.</p>
    <p class="line_zh">子表达式（2,3）的最小值为15。</p>
    <p class="">It's maximal value is also 15.</p>
    <p class="line_zh">它的最大值也是15。</p>
    <p class="">As to subexpression (4,6), its minimum value is -13.</p>
    <p class="line_zh">对于子表达式（4,6），其最小值为-13。</p>
    <p class="">It's maximal value is 5.</p>
    <p class="line_zh">它的最大值是5。</p>
    <p class="">And we would like the product of these two values to be as small as possible.</p>
    <p class="line_zh">我们希望这两个值的乘积尽可能小。</p>
    <p class="">Well, it is not difficult to see that if we take just 15 and multiply it, which is a minimum value of subexpression (2,3),
        and multiply it by the minimum value of the subexpression (4,6), which is -13, then we get exactly -195.</p>
    <p class="line_zh">好吧，不难看出，如果我们只取15并乘以它，这是子表达式（2,3）的最小值，并乘以子表达式的最小值（4,6），即 - 13，然后我们得到-195。</p>
    <p class="">And this, in turn, allows us to get -195 from the subexpression (2,6).</p>
    <p class="line_zh">而这反过来又允许我们从子表达式（2,6）中得到-195。</p>
    <p class="">We can do as follows.</p>
    <p class="line_zh">我们可以做如下。</p>
    <p class="">We can first compute the sum of 8 and 7.</p>
    <p class="line_zh">我们可以先计算8和7的总和。</p>
    <p class="">This gives us 15.</p>
    <p class="line_zh">这给了我们15。</p>
    <p class="">And then to multiply it by the result of the second subexpression.</p>
    <p class="line_zh">然后将它乘以第二个子表达式的结果。</p>
    <p class="">Well, now it remains to find out how to get -13 out of this subexpression for 6, but in this small example, it is already
        easy to get -13.</p>
    <p class="line_zh">那么，现在仍然需要找出如何从6的子表达式中获得-13，但在这个小例子中，它已经很容易得到-13。</p>
    <p class="">Well, we just first compute the sum of 8 and 9 and then subtract it from 4, right.</p>
    <p class="line_zh">好吧，我们首先计算8和9之和，然后从右边减去4。</p>
    <p class="">So this way we reconstructed the whole solution, I mean, an optimal parenthesizing, or an optimal ordering, of our arithmetic
        operations, leading to this value, to this maximal value, 200.</p>
    <p class="line_zh">所以这样我们重建整个解决方案，我的意思是，我们的算术运算的最佳括号或最佳排序，导致这个值，达到这个最大值，200。</p>
    <p class="">Let's just check it once again that our parenthesizing leads to the value 200, indeed.</p>
    <p class="line_zh">让我们再次检查一下，我们的括号确实导致了值200。</p>
    <p class="">So we first compute the sum of 8 and 9.</p>
    <p class="line_zh">所以我们首先计算8和9的总和。</p>
    <p class="">This gives us 17.</p>
    <p class="line_zh">这给了我们17。</p>
    <p class="">We then subtract 17 from 4.</p>
    <p class="line_zh">然后我们从4中减去17。</p>
    <p class="">And this gives us -13.</p>
    <p class="line_zh">这给了我们-13。</p>
    <p class="">We then compute the sum of 8 and 7.</p>
    <p class="line_zh">然后我们计算8和7的总和。</p>
    <p class="">This gives us 15.</p>
    <p class="line_zh">这给了我们15。</p>
    <p class="">We multiply 15 by -13.</p>
    <p class="line_zh">我们将15乘以-13。</p>
    <p class="">It gives us -195, and, finally, we subtract this number from 5, and we get 200, indeed.</p>
    <p class="line_zh">它给了我们-195，最后，我们从5中减去这个数字，确实得到200。</p>
    <p class="">So we reconstructed the whole solution.</p>
    <p class="line_zh">所以我们重建了整个解决方案。</p>
    <p class="">In general, I mean for an expression consisting of n digits and n minus 1 operations they can respond, an algorithm makes
        roughly quadratic number of steps, because it needs to reconstruct n minus one operations, I mean, an order of n
        minus one operations, going from last one to the first one.</p>
    <p class="line_zh">一般来说，我的意思是对于一个由n个数字组成的表达式和它们可以响应的n减1个操作，算法会产生大致二次数的步骤，因为它需要重构n减去一个操作，我的意思是，n的顺序减去一个操作从最后一个到第一个。</p>
    <p class="">And for each operation, it potentially needs to go through all possible splittings into two subexpressions, and this
        number is at most M.</p>
    <p class="">并且对于每个操作，它可能需要经历所有可能的分裂成两个子表达式，并且该数量最多为M.</p>
    <p class="">So the running time is bigger of ten times M, which is bigger of M squared.</p>
    <p class="line_zh">因此运行时间大于M的十倍，这是M平方的较大值。</p>
    <p class="">And this technique is quite general.</p>
    <p class="line_zh">这种技术非常普遍。</p>
    <p class="">It applies in many cases in the dynamic problem in algorithms.</p>
    <p class="line_zh">它在许多情况下适用于算法中的动态问题。</p>

    <script src="./main.js"></script>
</body>